<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java | Lollipop</title><meta name="keywords" content="Java"><meta name="author" content="金腾欢"><meta name="copyright" content="金腾欢"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="用于复习JavaSE,以后JavaWeb和反射原理也会整合在这里">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="https://github.com/xiaojingangxiaoxiang/xiaojingangxiaoxiang.github.io/2022/05/12/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Lollipop">
<meta property="og:description" content="用于复习JavaSE,以后JavaWeb和反射原理也会整合在这里">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/xiaojingangxiaoxiang/xiaojingangxiaoxiang.github.io/img/14.jpg">
<meta property="article:published_time" content="2022-05-12T04:48:52.000Z">
<meta property="article:modified_time" content="2022-11-30T03:11:53.736Z">
<meta property="article:author" content="金腾欢">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/xiaojingangxiaoxiang/xiaojingangxiaoxiang.github.io/img/14.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/xiaojingangxiaoxiang/xiaojingangxiaoxiang.github.io/2022/05/12/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-30 11:11:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/14.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lollipop</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-12T04:48:52.000Z" title="发表于 2022-05-12 12:48:52">2022-05-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-30T03:11:53.736Z" title="更新于 2022-11-30 11:11:53">2022-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/05/12/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/05/12/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<p>[TOC]</p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a><font color="#6dc1f7">JDK JRE JVM</font></h2><blockquote>
<p><strong>JDK</strong>  Java 的开发工具</p>
<p><strong>JRE</strong> JAVA 的运行环境</p>
<p><strong>JVM</strong> Java虚拟机</p>
</blockquote>
<h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a><font color="#6dc1f7">自动类型转换</font></h2><p>自动类型转换精度小的类型可以自动转换成精度大的数据</p>
<p><em>Boolean型</em> 不参与运算</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E5%A4%A7%E5%B0%8F.png" alt="自动类型转换"></p>
<mark class="hl-label red">注意</mark>  

<p><em>1、</em>如果Java中出现一个小数它默认是 double类型的将一个小数结果赋值给float 类型时就会报错将一个精度大的赋值给精度小的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">d</span> <span class="operator">=</span> n + <span class="number">1.1</span>;   <span class="comment">//报错</span></span><br><span class="line"><span class="type">float</span> <span class="variable">d1</span> <span class="operator">=</span> n + <span class="number">1.1</span>;  </span><br></pre></td></tr></table></figure>

<p><em>2、</em> byte类型直接给整数数据的时候，先判段是否在-128-127这个范围内。符合即可</p>
<p>要是变量赋值就需要判断它的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span>  <span class="operator">=</span> n;   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><em>3、</em> byte char short 三个数据不能相互自动类型转换  他们三个在互相参与运算的时候会将精度提升到<strong>int</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a3</span> <span class="operator">=</span> a1 + a2;</span><br><span class="line"><span class="type">short</span> <span class="variable">a4</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a5</span> <span class="operator">=</span> a1 + a2 + a4;</span><br></pre></td></tr></table></figure>

<p><em>4、</em> 自动提升原则，多个精度参与运算的时候会将精度提升到最大的那个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">a4</span> <span class="operator">=</span> a1 + a2 + a3;   <span class="comment">//报错  用低精度的float接高精度的double 报错了</span></span><br><span class="line"><span class="type">double</span> <span class="variable">a5</span> <span class="operator">=</span> a1 + a2 + a3;</span><br></pre></td></tr></table></figure>

<h2 id="强制类型转化"><a href="#强制类型转化" class="headerlink" title="强制类型转化"></a><font color="#6dc1f7">强制类型转化</font></h2><p><em>1、</em> 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型使用时候加上强制类型转化符号（），但是可能造成精度降低或溢出 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> = (<span class="type">int</span>)<span class="number">1.1</span>;  <span class="comment">//精度丢失</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span> <span class="number">1000</span>);  <span class="comment">//-24</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label green">补充</mark>  ： 计算机的反码、补码、源码。 正数的反码和源码一样，负数的反码和源码有区别。

<p>byte 在Java中。由八位二进制表示最高0表示正数 1代表负数。 计算机中都是储存反码，负数反码规则是最高位不变前七位取反然后加1；10000000 原本是-0 byte里面表示-128 ;10000001是127的反码也就是-127。-127和-128相差1也很合理这样既不浪费-0 这个数 正负大概区分是（-128- -1）（0-127）</p>
<p><em>2、</em> 强制类型转换只对于最近的操作数有效，往往使用括号提升优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10</span>*<span class="number">0.1</span>+<span class="number">10.1</span>;   <span class="comment">//编译出错 不能将double给int</span></span><br></pre></td></tr></table></figure>

<p><em>3、</em> char 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">a= (<span class="type">char</span>)b; <span class="comment">//输出ASCII 码中的10</span></span><br></pre></td></tr></table></figure>

<p><em>4、</em> byte short char 类型在进行运算时，当作int类型处理。</p>
<mark class="hl-label orange">练习题</mark> :

<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BB%83%E4%B9%A0%E9%A2%98.png" alt="类型转换题目"></p>
<h2 id="String和其他类型转换"><a href="#String和其他类型转换" class="headerlink" title="String和其他类型转换"></a><font color="#6dc1f7">String和其他类型转换</font></h2><h3 id="其他类型转换成String"><a href="#其他类型转换成String" class="headerlink" title="其他类型转换成String"></a><font color="#5cb85c">其他类型转换成String</font></h3><p>一般在其他类型后面凭借一个””。完成类型转换</p>
<h3 id="String-转换成其他类型"><a href="#String-转换成其他类型" class="headerlink" title="String 转换成其他类型"></a><font color="#5cb85c">String 转换成其他类型</font></h3><p>调用相应的包装类来实现。</p>
<p>例如：<code>int s =Integer.parseInt(&quot;33&quot;);</code> 其他数据类型相应调用包装类</p>
<p>char数据类型不能使用。因为String就是由一个一个char组成的。使用String.charAt(位置)；</p>
<mark class="hl-label default">异常</mark> ：如果String类型里面是文字 要转换成int类型等则会异常。

<h2 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a><font color="#6dc1f7">原码 反码 补码</font></h2><blockquote>
<p><em>1、</em> 二进制最高位是符号位：0表示正数，1表示负数；</p>
<p><em>2、</em> 正数的原码、反码、补码都一样（三码合一）；</p>
<p><em>3、</em> 负数的反码&#x3D;它的原码符号位不变。其他位取反（0&gt;1,1&gt;0)；</p>
<p><em>4、</em> 负数的补码&#x3D;它的反码+1，负数的反码&#x3D;负数的补码-1</p>
<p><em>5</em>、0 的反码，补码都是0；</p>
<p><em>6、</em> Java没有无符号数，也就是Java中的数都是有符号的；</p>
<p><em>7、</em> 在计算机运算的时候，都是以补码的方式来运算的。（补码可以用来计算负数）</p>
<p><em>8、</em> 当我们看运算结果的时候，要看他的原码;</p>
</blockquote>
<h2 id="求余"><a href="#求余" class="headerlink" title="求余%"></a><font color="#6dc1f7">求余%</font></h2><p>a%b 当a是小数时，公式&#x3D;a-(int)a&#x2F;b*b; </p>
<h2 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a><font color="#6dc1f7">While循环</font></h2><ul>
<li>基本语法</li>
</ul>
<p>​	循环变量初始化；</p>
<p>​	while(循环条件) {</p>
<p>​			循环体(语句)；</p>
<p>​			循环变量迭代；</p>
<p>​	}</p>
<ol>
<li>while循环也有四个要素</li>
<li>只是四要素放的位置不同，不一样。</li>
</ol>
<mark class="hl-label red">注意</mark> ：

<p>循环条件中不能初始化，必须在循坏上面初始化，否者会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="type">int</span> i &lt; <span class="number">7</span>)&#123;<span class="comment">//会报错</span></span><br><span class="line">``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><font color="#6dc1f7">二维数组</font></h2><h3 id="动态创建静态创建"><a href="#动态创建静态创建" class="headerlink" title="动态创建静态创建"></a><font color="#5cb85c">动态创建静态创建</font></h3><h4 id="动态创建"><a href="#动态创建" class="headerlink" title="动态创建"></a><font color="#ffd253">动态创建</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>][<span class="number">3</span>];   <span class="comment">//创建一个含有3个一维数组的二维数组并且每个一维数组都是3的长度</span></span><br><span class="line"><span class="type">int</span> [][] arr1 =<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>][];     <span class="comment">//创建一个含有3个一维数组的二维数组但是不能确定长度。</span></span><br><span class="line"><span class="type">int</span> [] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];      <span class="comment">//动态初始化一维数组</span></span><br><span class="line">arr[<span class="number">0</span>]= arr1;                <span class="comment">//将一维数组arr1 赋予给二维数组arr的第0个数</span></span><br><span class="line"><span class="type">int</span> [] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>&#125;;  <span class="comment">// 静态初始化一维数组</span></span><br><span class="line">arr[<span class="number">1</span>] = arr3;               <span class="comment">// 将一维数组arr1 赋予给二维数组arr的第1个数</span></span><br></pre></td></tr></table></figure>

<h4 id="静态创建"><a href="#静态创建" class="headerlink" title="静态创建"></a><font color="#ffd253">静态创建</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [][] &#123;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">4</span>&#125;&#125;;    <span class="comment">//静态创建 两个元素的二维数组 第一个元素是&#123;3，4，5&#125;   可以不是“长方形” 就是4X4之类的  ，也可以是不统一的</span></span><br><span class="line"><span class="type">int</span> [] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">12</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> [] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> [][] arr1 =<span class="keyword">new</span> <span class="title class_">int</span> [][]&#123;arr2,arr3&#125;;    <span class="comment">//静态创建当然里面也可以直接放创建好的数组（动态静态都可以）</span></span><br></pre></td></tr></table></figure>

<h3 id="数组数据传递机制"><a href="#数组数据传递机制" class="headerlink" title="数组数据传递机制"></a><font color="#5cb85c">数组数据传递机制</font></h3><p><img src="/images/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86.png" alt="二维数组内存"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] arr1 =&#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;5&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span>[] arr2 = arr1;</span><br><span class="line">arr1[<span class="number">2</span>] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">System.out.println(arr2);   <span class="comment">//字符串数组不需要tostring</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">总结</mark> 

<p>输出结果为sww5，因为arr1和arr2执行的是同一个空间，他们打印出来的元素都是相同的。数组传递机制如下图所示：</p>
<p><img src="/images/%E6%95%B0%E7%BB%84%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6.png" alt="数组传递机制"></p>
<h2 id="数组算法：双指针"><a href="#数组算法：双指针" class="headerlink" title="数组算法：双指针"></a><font color="#6dc1f7">数组算法：双指针</font></h2><blockquote>
<p>双指针，就是<strong>定义两个指针在指定的数组&#x2F;链表上游走，在做一些自定义的操作</strong>。 如果要细分的话，双指针有 左右指针 ， 快慢指针 ， 滑动窗口 三种类型，一般时间复杂度为O (n)，空间复杂度为O (1),这就是双指针的精妙之处。</p>
<p>不用再去创建一个数组。</p>
</blockquote>
<mark class="hl-label orange">案例1</mark> ：在数组中移除对应对应的数(val)——快慢指针判断有条件判断指针2是否前进

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElementcorrection</span><span class="params">(<span class="type">int</span> [] nums , <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      双指针思想</span></span><br><span class="line"><span class="comment">      个人理解： 两个指针都会遍历数组 一个用来比较是否是要移除的元素 第二个指针相当于新建一个数组：大小和原来一样</span></span><br><span class="line"><span class="comment">      并且如果是符合这个数组（即不等于要被移除的数）那么第二个指针就会自增1 那么有多少个数符合那么第二个指针就会有多长</span></span><br><span class="line"><span class="comment">      最坏的情况就是这个数组没有要移除的数那么两个指针都会遍历数组一遍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left1</span> <span class="operator">=</span> <span class="number">0</span> ; left1 &lt; len ; left1++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left1] != val) &#123;</span><br><span class="line">            nums[left] = nums[left1];</span><br><span class="line">            left++;    <span class="comment">//即完成移除元素 也记录了符合的数的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8C%E6%8C%87%E9%92%88.png" alt="双指针经典案例"></p>
<mark class="hl-label orange">案例2</mark> ：类似双指针——两个数组双指针(快慢指针)

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *一个升序数组要求加入一个元素后还是升序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] paixu(<span class="type">int</span>[] arr, Scanner sc) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  1、第一步找位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= arr[i]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">//关键不然一直要么是最后一个要么是倒数第二个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==-<span class="number">1</span>) &#123;</span><br><span class="line">            index = len;   <span class="comment">//没有找到位置那就是最后一个啦</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  2、数组扩容</span></span><br><span class="line">        <span class="type">int</span> [] Newarr = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 3、 类似双指针  最外层指针在扩容数组上 里面一层在旧数组上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>; i&lt; Newarr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">                Newarr [i] = arr [j];</span><br><span class="line">                j++;  <span class="comment">//非常的关键一步很牛叉的思想</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;   <span class="comment">// else 就说明是要插入的位置</span></span><br><span class="line">                 Newarr [i] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Newarr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">总结</mark> 

<blockquote>
<p>这是两个指针在不同数组上的应用，最明显的作用是减少代码量。<code>j++</code>这个很关键。</p>
</blockquote>
<h2 id="一些数组排序"><a href="#一些数组排序" class="headerlink" title="一些数组排序"></a><font color="#6dc1f7">一些数组排序</font></h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><font color="#5cb85c">冒泡排序</font></h3><blockquote>
<p>思想：总体像是水中小泡一个个有顺序（按一定的<strong>规则</strong>）冒出</p>
<blockquote>
<p>​		    第一次排序，找出数组中最大或者最小的数。</p>
<blockquote>
<p>​		    第二次排序，将第一次排序找出的最大值或者最大值排除，在剩下的数组中找出最大或者最小的</p>
<p>​            ~~</p>
</blockquote>
<p>排序次数&#x3D; n-1， n是数组中元素总个数。</p>
</blockquote>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] arr =<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>，<span class="number">34</span>，<span class="number">67</span>，<span class="number">7845</span>，<span class="number">341</span>，<span class="number">213</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;     <span class="comment">//两层嵌套循环实现每次i++ 。`j &lt; arr.length-i-1`  j的上限减一遍历范围减一 那么就相当于排好一个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-i-<span class="number">1</span>; j++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j+<span class="number">1</span>];         <span class="comment">//规则：这里是倒叙 当然也可以是升序~~等</span></span><br><span class="line">                    arr[j+<span class="number">1</span>] = arr[j]; </span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java函数方法"><a href="#Java函数方法" class="headerlink" title="Java函数方法"></a><font color="#6dc1f7">Java函数方法</font></h2><h3 id="方法的调用机制"><a href="#方法的调用机制" class="headerlink" title="方法的调用机制"></a><font color="#5cb85c">方法的调用机制</font></h3><blockquote>
<p>首先在<strong>栈</strong>里面创建一个空间，如果要创建对象（new）那么在<strong>堆</strong>内存中创建一个空间。再运行到方法时候，会在<strong>栈</strong>内存再开一个空间，如果要有参数。那么会对应传入。return语句则会相应返回：底层原理先会记住这个方法的地址最后在return语句中返回原来的地址。当return语句执行后，方法的栈内存则会<strong>释放</strong>。简单实例如下图所示。</p>
</blockquote>
<p><img src="/images/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6.png" alt="方法调用机制"></p>
<p>最后在方法执行（println）完成后，栈中的main方法也会释放。</p>
<h3 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a><font color="#5cb85c">递归思想</font></h3><blockquote>
<p>简单的说：递归方法自己调用自己，每次调用的时传入不同的变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。如算法中 二分查找，快排，归并排序，分治算法等就用到了递归思想。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">digui</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n==<span class="number">1</span> || n==<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> digui (n-<span class="number">1</span>) +digui (n-<span class="number">2</span>);   <span class="comment">//递归调用思想</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您输入的数据有误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">案例1</mark> ：斐波那契数（1，1，2，3，5，8 ~~~），上图所示代码完成返回第几位的值。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">taozi</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (day == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">if</span> (day &gt;= <span class="number">1</span> || day &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (taozi(day + <span class="number">1</span>) + <span class="number">1</span>) *<span class="number">2</span>;     <span class="comment">//递归</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;天数不符合实际&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">案例2</mark> ：猴子吃桃，每次吃掉前一天的一半并多一个，第十天剩1个。用递归求得每天的桃子个数。

<mark class="hl-label orange">案例3</mark> ：老鼠出迷宫。制定起始点、终点和障碍物。求出路线。

<p>1、迷宫生成、打印和方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [][] migong = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;   </span><br><span class="line">            migong [<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            migong [<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            migong [i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            migong [i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	migong [<span class="number">3</span>][<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">        migong [<span class="number">3</span>][<span class="number">2</span>] =<span class="number">1</span>;  </span><br><span class="line">    	<span class="comment">//二维迷宫生成。</span></span><br><span class="line">        <span class="type">migong</span> <span class="variable">laoshu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">migong</span> ();</span><br><span class="line">        laoshu.findway(migong,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ele : migong) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(ele));    <span class="comment">//for each 遍历二维数组。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2、寻找路的一种办法（findway）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    制定一个自动寻路方法：</span></span><br><span class="line"><span class="comment">    1、能够走通则返回true，不能走通或者走过了都返回false</span></span><br><span class="line"><span class="comment">    2、int [][] migong 是传入的迷宫 int i int j 代表起始位置</span></span><br><span class="line"><span class="comment">    3、递归找路先指定各个含义 ：</span></span><br><span class="line"><span class="comment">        0、代表可以走通</span></span><br><span class="line"><span class="comment">        1、代表障碍物</span></span><br><span class="line"><span class="comment">        2、代表走过的路可以通过(不好表示，如果终点为2那么已完成寻路，如果在平时遇到2需要返回false而不是true，不然会死循环)</span></span><br><span class="line"><span class="comment">        3、代表死路（当四面围墙的时候才会出现或者回溯现象）。</span></span><br><span class="line"><span class="comment">    4、寻路法则： 下&gt;右&gt;上&gt;左。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findway</span> <span class="params">(<span class="type">int</span> [][] migong , <span class="type">int</span> i , <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">//首先制定终点</span></span><br><span class="line">        <span class="keyword">if</span> (migong [<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (migong [i][j]==<span class="number">0</span>) &#123; <span class="comment">//先判断起点是没有障碍物的  也是判断下一个递归的位置有没有障碍物</span></span><br><span class="line">            migong [i][j]=<span class="number">2</span>;<span class="comment">// 先将这个点标记为可以通过的路，这个很关键下次递归选择也需要用得到</span></span><br><span class="line">            <span class="comment">//这里经行寻路法则： 下&gt;右&gt;上&gt;左。</span></span><br><span class="line">            <span class="keyword">if</span> (findway(migong,i+<span class="number">1</span>,j)) &#123;  <span class="comment">//很巧妙的将这个方法返回是Boolean和递归if结合</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (findway(migong,i,j+<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (findway(migong,i-<span class="number">1</span>,j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(findway(migong,i,j-<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                migong[i][j] = <span class="number">3</span>;<span class="comment">//不是j+1或者i+1,很巧妙。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//这个else是相较于寻路法则的else 第一句的终点判断可以相当是独立判断的。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//上下左右都是障碍物(1) 则返回false死路</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3、结果展示。</p>
<p><img src="/images/image-20220531172208441.png" alt="image-20220531172208441"></p>
<p>4、回溯现象。</p>
<p>由于此算法是不会走回头路的，下面就会出现回溯现象。</p>
<p><img src="/images/image-20220531223157742.png" alt="image-20220531223157742"></p>
<p>结果：</p>
<p><img src="/images/%E5%9B%9E%E6%BA%AF.png" alt="回溯"></p>
<p>这里就体现出来<mark class="hl-label red">3:代表死路</mark> 的重要性。</p>
<blockquote>
<p>总结：递归可以求已知某个结果，然后根据某一个条件可以依次推出别的结果。递归思想可以从已知结果开始推，如斐波那契数知道第一位第二位，就从这里着手。而猴子吃桃是知道第十天的桃子数量，就需要反推。老鼠出迷宫这个有点难度，但是最终还是找规律，递归需定一个范围。</p>
</blockquote>
<h4 id="递归与循环的区别于联系"><a href="#递归与循环的区别于联系" class="headerlink" title="递归与循环的区别于联系"></a><font color="#ffd253">递归与循环的区别于联系</font></h4><blockquote>
<p>相同点：<br>（1）都是通过控制一个变量的边界（或者多个），来改变多个变量为了得到所需要的值，而反复而执行的；<br>（2）都是按照预先设计好的推断实现某一个值求取；（请注意，在这里循环要更注重过程，而递归偏结果一点）</p>
<p>不同点：<br>（1）递归通常是逆向思维居多，“递”和“归”不一定容易发现（比较难以理解）；而循环从开始条件到结束条件，包括中间循环变量，都需要表达出来（比较简洁明了）。</p>
<p>简单的来说就是：用循环能实现的，递归一般可以实现，但是能用递归实现的，循环不一定能。因为有些题目①只注重循环的结束条件和循环过程，而往往这个结束条件不易表达（也就是说用循环并不好写）；②只注重循环的次数而不注重循环的开始条件和结束条件（这个循环更加无从下手了）。</p>
</blockquote>
<h2 id="可变参数的使用-重载类似升级"><a href="#可变参数的使用-重载类似升级" class="headerlink" title="可变参数的使用(重载类似升级)"></a><font color="#6dc1f7">可变参数的使用(重载类似升级)</font></h2><blockquote>
<p>可变参数相当于重载的任意形式，你可以往里面加任意个制定的类型组<br> 1、int…表示接受的是可变参数，类型是int，即可以接受多个int(0-n)个<br> 2、使用可变参数时，可以当作数组来使用，即nums相当于数组使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo1</span> <span class="variable">a</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Demo1</span>();</span><br><span class="line">    a.sum(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span>...nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ele :nums) &#123;</span><br><span class="line">        sum = sum +ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum1</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span>...nums1,<span class="type">int</span>...nums2)</span>&#123; <span class="comment">//报错，只能有一个可变参数</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> 

<ul>
<li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</li>
<li>由于可变参数必须是最后一个参数，所以一个函数最多只能有一个可变参数</li>
<li>Java的可变参数，会被编译器转型为一个数组</li>
<li>变长参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立</li>
</ul>
<mark class="hl-label purple">总结</mark> 

<p>可变参数的使用使得重载使用范围更广，也更为灵活。得益于其随意可以输入n个数，作为数组。同时又可以带入其他普通形参(用来接收调用该方法时传递的参数)。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a><font color="#6dc1f7">this关键字</font></h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a><font color="#5cb85c">问题引出</font></h3><mark class="hl-label orange">构造器</mark> 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">dog</span><span class="params">(String dname,<span class="type">int</span> dage)</span>&#123;</span><br><span class="line">        name = dname;</span><br><span class="line">        age = dage;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造器的形参，能够直接写成属性名就更好了。</p>
<p>但是有一个问题就是，根据变量名的作用域原则。如果把dname改成name。那么构造器重name&#x3D;name。那就是将形参传入进来的name赋值给形参传入进来的name。没有作用。</p>
<p>所以需要<font color="ED5A65"><strong>this关键字</strong></font>。</p>
<h3 id="this入门"><a href="#this入门" class="headerlink" title="this入门"></a><font color="#5cb85c">this入门</font></h3><ul>
<li><p>什么是this</p>
<p>Java虚拟机会给每个对象(不是类，new出来的很多对象)分配this，代表当前对象。</p>
<mark class="hl-label orange">例子</mark> ：[上帝创世界小故事]

<p><img src="/images/image-20220625133232693.png" alt="image-20220625133232693"></p>
</li>
<li><p>使用this解决前面变量命名问题</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...main&#123;</span><br><span class="line">    <span class="type">dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">dog</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="comment">//this.name 就是当前对象的属性name。</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this本质"><a href="#this本质" class="headerlink" title="this本质"></a><font color="#5cb85c">this本质</font></h3><p>通过内存理解this。</p>
<p><img src="/images/image-20220625165832754.png" alt="image-20220625165832754"></p>
<p>上图堆中的this指针是隐藏的，是指向对应的对象（每个对象都有对应的this）。</p>
<p>由于是运行在JVM虚拟机上面的，所以不能获得对象正真地址，可以使用对象的方法hashcode()来获得虚拟地址。来验证this地址与其对应对象是否相等。如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">dog1.hashcode();</span><br><span class="line">...</span><br><span class="line"><span class="built_in">this</span>.hashcode();  <span class="comment">//写在构造方法里面  dog类里面的方法用this.hashcode()也一样。</span></span><br></pre></td></tr></table></figure>

<p>可以得出结论是this与其对应对象的地址是一样的。</p>
<h3 id="this小结"><a href="#this小结" class="headerlink" title="this小结"></a><font color="#5cb85c">this小结</font></h3><blockquote>
<p>简单的说，哪个<font color="ED5A65">对象调用</font>，this就代表哪个<font color="ED5A65">对象</font>。不是类哦注意!!!</p>
</blockquote>
<h3 id="this使用细节"><a href="#this使用细节" class="headerlink" title="this使用细节"></a><font color="#5cb85c">this使用细节</font></h3><blockquote>
<ol>
<li>this关键字可以用来访问本类的属性、方法、构造器。</li>
<li>this用于区分当前类的属性和局部变量。</li>
<li>访问成员方法的语法：this.方法名(参数列表)；</li>
<li>访问构造器语法：this(参数列表)；注意只能在构造器中使用(即只能在构造器中访问另一个构造器，必须放在第一条语句)</li>
<li>this不能在类定义的外部使用，只能在类定义的方法中使用。</li>
</ol>
</blockquote>
<p><font color="7E2065">访问本类语法：this.属性名</font></p>
<p><font color="7E2065">访问本类方法：this.方法名(形参);</font></p>
<p><font color="7E2065">访问本类构造器：this(形参)；</font></p>
<mark class="hl-label orange">案例1</mark> 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">this</span>细节&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;xx&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1方法调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;xx1&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;f2方法被调用&quot;</span>);</span><br><span class="line">        <span class="comment">//调用f1方法</span></span><br><span class="line">        <span class="comment">//1、</span></span><br><span class="line">        <span class="built_in">this</span>.f1();</span><br><span class="line">        <span class="comment">//2、直接调用</span></span><br><span class="line">        f1();</span><br><span class="line">        <span class="comment">//属性调用演示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;this调用&quot;</span>+<span class="built_in">this</span>.name+<span class="string">&quot;\t&quot;</span>+<span class="built_in">this</span>.age); <span class="comment">//一定调用本类属性xx 19 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;直接调用&quot;</span>+name+<span class="string">&quot;\t&quot;</span>+age);   <span class="comment">//结果根据局部变量 就近原则 xx1 19</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种调用方法有区别，在继承中体现。</p>
<mark class="hl-label orange">案例2</mark> :解释第四条

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">T</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//this调用构造器 ,必须要在第一行</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;lwt&quot;</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：一个构造器要访问另一个构造器的时候，必须要写在<font color="EEA2A4">构造器第一行</font>。调用的构造中形参的类型和位置要对应。

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><font color="#6dc1f7">继承</font></h2><h3 id="继承原理示意图"><a href="#继承原理示意图" class="headerlink" title="继承原理示意图:"></a><font color="#5cb85c">继承原理示意图:</font></h3><p><img src="/images/image-20220604133015736.png" alt="image-20220604133015736"></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a><font color="#6dc1f7">多态</font></h2><p>多态的注意事项和细节讨论：</p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a><font color="#5cb85c">向上转型</font></h3><p>多态的前提是：有继承&#x2F;实现关系；有父类引用指向子类的对象；有方法重写</p>
<p>多态的向上转型：将子类提升到父类，（我们默认父类在子类上面）</p>
<p>1)<mark class="hl-label green">本质</mark> :父类的引用指向了子类的对象。</p>
<p>2)<mark class="hl-label green">语法</mark> :父类类型  引用名 &#x3D; new 子类类型()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();  <span class="comment">//多态的对象创建方法 有父类引用指向子类的对象；</span></span><br></pre></td></tr></table></figure>

<p>3)<mark class="hl-label green">特点</mark> :特点编译类型（编译时）看左边 ，运行类型（运行时）看右边。可以调用父类中的所有成员(需遵循访问权限)，如：属性如果是private——但是事实上private类型成员应该也是继承给了子类，只是他是私密的。就像你继承了你爸爸的一个保险箱，实质上已经继承了但是需要密码。Java中get，set就是密钥。继承也是这样的。</p>
<p><img src="/images/image-20220604134717209.png" alt="image-20220604134717209"></p>
<p>不能调用子类中特有成员(方法和方法)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();  <span class="comment">//多态的对象创建方法</span></span><br><span class="line">dog.dogeat();   <span class="comment">//dogeat是子类的一个方法   报错。因为写代码时是在编译，编译的时候看左边，dog是animal类型，没有子类的方法，编译器报错（Javac）。</span></span><br></pre></td></tr></table></figure>

<p>最终运行效果看子类的具体实现。（如：重写了父类的方法），即运行的时候看左边子类，如果子类没有对应的属性和方法就调用父类的（继承）。</p>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a><font color="#5cb85c">向下转型</font></h3><p>多态的向下转型：</p>
<p>1)<mark class="hl-label green">语法</mark> : 子类类型 引用名 &#x3D;  （子类类型）父类引用；</p>
<p>2)只能强转父类的引用，不能强转父类的对象</p>
<p>3)要求父类的引用必须指向的是当前目标类型的对象</p>
<p>4)当向下转型后，可以调用子类类型中所有的成员(方法和属性)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 是 cat 和dog的父类</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (cat) animal  <span class="comment">//向下转型</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (dog) animal <span class="comment">//编译没问题 ，会抛出异常</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">试例</mark> :

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">a</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">b</span>();    <span class="comment">//父类的引用指向子类</span></span><br><span class="line">        System.out.println(s.age);   <span class="comment">//因为没有向下转型 ，调用属性的时候不会想方法一样，直接调用子类重写的方法，这里就只能调用父类的age（动态绑定机制）</span></span><br><span class="line">        s.sum();     <span class="comment">//由于子类有重写，动态绑定机制，调用子类中重写的sum（）方法</span></span><br><span class="line">        System.out.println(s.name);  <span class="comment">//这里就直接调用了，没啥好说 的，子类没有特有的name属性</span></span><br><span class="line">        <span class="type">b</span> <span class="variable">s1</span> <span class="operator">=</span> (b) s;   <span class="comment">//向下转型后</span></span><br><span class="line">        System.out.println(s1.age);  <span class="comment">//调用子类特有的属性</span></span><br><span class="line">        s1.sum();   <span class="comment">//和没有向下转型的一样，由于动态绑定机制，没有转型也会输出子类重写的方法</span></span><br><span class="line">        System.out.println(s.name); <span class="comment">//这里就输出子类继承自父类的name属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">name</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span> <span class="keyword">extends</span> <span class="title class_">a</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">总结</mark> ：多态的优点右边对象可以实现解耦合，便于扩展和维护。比如接口collection你想使用Arraylist ，后面要改LinkedList 。只需将`Collection<String> arr = new ArrayList<>();`改成`Collection<String> arr = new LinkedList<>();`arr就从ArryList 变成LinkedList。缺点是不能直接调用子类的特有方法，就需要向下转型。如上面代码块显示。<br>

<mark class="hl-label red">注意</mark> ：类型不能转换错误`Dog dog = (dog) animal`则会抛出异常。<br>

<mark class="hl-label default">异常</mark> ：ClassCastException  <br>

<p>可以使用instanceof：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lwt <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">	<span class="type">Dog</span> <span class="variable">lwt1</span> <span class="operator">=</span> (Dog) lwt;</span><br><span class="line">	lwt1.eat();  <span class="comment">//这样强制类型转换可以调用多态的独有方法 ，弥补缺点</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(lwt <span class="keyword">instanceof</span> niu)&#123;</span><br><span class="line">    <span class="type">niu</span> <span class="variable">lwt2</span> <span class="operator">=</span> (niu) lwt;</span><br><span class="line">    lwt2.play();  <span class="comment">//这样强制类型转换可以调用多态的独有方法 ，弥补缺点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a><font color="#5cb85c">动态绑定机制</font></h3><mark class="hl-label orange">重要</mark> <br>

<p><img src="/images/image-20220606230737208.png" alt="image-20220606230737208"></p>
<p>前面学习的向上转型原则可以很简单的得出<code>Systems.out.println(a.sum()); //40</code> <code>Systems.out.println(a.sum1()); //30</code><br></p>
<p>但是当将子类的sum()和sum1()方法都除去时。如下图所示。</p>
<p><img src="/images/image-202206062307372081.png" alt="image-20220606230737208 - 副本.png"></p>
<p>更具Java的动态调用机制，当调用对象方法的时候，该方法会和该对象的<strong>内存地址(堆中产生的)&#x2F;运行类型绑定</strong>。所以即时在父类调用<code>sum()</code>方法时又遇到了<code>getI()</code>方法,这时候还是会先从子类开始找起。所以代码更改后的结果为，30和20。这个20根据属性没有动态绑定机制，所以i&#x3D;父类中10。<br></p>
<mark class="hl-label purple">总结</mark> ：<br>

<p>动态绑定机制，方法会绑定：子类有方法重写就用子类的即使是在父类中调用(由于多态的向上转型)。属性没有动态绑定机制，哪里访问就调用哪里（继承需遵守_没有重写的话)、(作用域)。</p>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a><font color="#6dc1f7">Object 类</font></h2><h3 id="x3D-x3D-比较运算符"><a href="#x3D-x3D-比较运算符" class="headerlink" title="&#x3D;&#x3D;比较运算符"></a><font color="#5cb85c">&#x3D;&#x3D;比较运算符</font></h3><p>&#x3D;&#x3D;和equals的对比<mark class="hl-label red">面试题</mark> </p>
<p>&#x3D;&#x3D;是一个比较运算符</p>
<p>1· &#x3D;&#x3D;：既可以判断基本类型，又可以判断引用类型</p>
<p>2· &#x3D;&#x3D;：如果判断基本类型，判断的是值是否相等。<mark class="hl-label orange">试例</mark> ：<code>int i = 10; double s = 10;</code></p>
<p>3· &#x3D;&#x3D;：如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象<mark class="hl-label orange">试例</mark> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> a;        <span class="comment">// 在栈里面创建一个c、b指向堆内存中的a；所以他们的地址都是一样的</span></span><br><span class="line">System.out.println(b==c);  <span class="comment">//true</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">//这是分别栈内存中开了两个内存，那么地址肯定也是不一样的</span></span><br><span class="line">System.out.println(e==f);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a><font color="#5cb85c">equals方法</font></h3><p>equals:是object类中的方法，只能判断引用类型——即默认判断的是地址是否相等，子类中往往<mark class="hl-label red">重写</mark> 该方法，用于判断内容是否相等。比如Object类的子类Integer，重写Object的equals的方法用于判断两个值是否相等<br></p>
<mark class="hl-label orange">试例</mark> :<br>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line">System.out.println(integer1 == integer2);  <span class="comment">//false 因为两个integer是引用类型地址不一样</span></span><br><span class="line">System.out.println(integer1.equals(integer2)); <span class="comment">//false 没有重写了equals方法</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">案例</mark> :

<p><img src="/images/image-20220607141515826.png" alt="image-20220607141515826"></p>
<h3 id="hashcode方法"><a href="#hashcode方法" class="headerlink" title="hashcode方法"></a><font color="#5cb85c">hashcode方法</font></h3><blockquote>
<p>1)提高具有哈希结构的容器的效率！</p>
<p>2)两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</p>
<p>3)两个引用，如果指向的是不同对象，则哈希值是不一样的</p>
<p>4)哈希值主要根据地址号来的！不能完全将哈希值等价于地址</p>
<p>5）后面在集合中hashcode如果需要的话，也会重写。</p>
</blockquote>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">a</span> <span class="variable">a1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">a</span>();</span><br><span class="line"><span class="type">a</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">a</span>();</span><br><span class="line">System.out.println(a1.hashCode());   <span class="comment">//返回哈希值</span></span><br><span class="line">System.out.println(a2.hashCode());  <span class="comment">//两者肯定不同</span></span><br><span class="line"><span class="type">a</span> <span class="variable">a3</span> <span class="operator">=</span> a1;</span><br><span class="line">System.out.println(a3.hashCode());  <span class="comment">//返回的哈希值和a1是一样的</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220606235220368.png" alt="image-20220606235220368"></p>
<mark class="hl-label purple">总结</mark> ：<br>

<p>hashcode是根据对象的内部地址(和java的地址不同，因为java是跑在虚拟机上面的，底层C语言可以获得内部地址)返回一个值。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><font color="#5cb85c">toString</font></h3><mark class="hl-label purple">基本介绍</mark> ：<br>

<blockquote>
<p>默认返回：全类名+@+哈希值的十六进制，<mark class="hl-label red">查看Object的toString方法</mark> </p>
<p>子类往往重写toString方法，用于返回对象的属性信息。</p>
<mark class="hl-label purple">Object的toString方法</mark> ：

<p><img src="/images/image-20220607142231150.png" alt="image-20220607142231150"></p>
<p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。</p>
<p>当直接输出一个对象的时候，toString方法会默认调用。(System.out.prinln();)</p>
</blockquote>
<mark class="hl-label orange">源码解释</mark> ：

<p>(1)getClass().getName() 类的全类名(包名+类名)</p>
<p>(2)Integer.toHexString(hashCode()) 将对象的hashCode值转成16进制字符串</p>
<mark class="hl-label orange">案例</mark> ：toString重写

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">wuhu</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">wuhu</span>(<span class="string">&quot;lwt&quot;</span>,<span class="number">2</span>,<span class="number">123.0</span>);</span><br><span class="line">        System.out.println(s);     <span class="comment">//默认输出的时候会使用toString</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wuhu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    wuhu(String name, <span class="type">int</span> age ,<span class="type">double</span> salary) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;   <span class="comment">//idea可以自动生成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;wuhu&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, salary=&quot;</span> + salary +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="finalize-已弃用"><a href="#finalize-已弃用" class="headerlink" title="finalize(已弃用)"></a><font color="#5cb85c"><del>finalize</del>(已弃用)</font></h3><ol>
<li>当对象被回收时，系统自动调用该对象的finalize方法。子类可以<font color="EC8AA4">重写</font>该方法.做一些<font color="0F59A4">释放资源</font>的操作</li>
<li>什么时候被回收：当某个对象没有任何引用的时候，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。</li>
<li>垃圾回收机制的调用，是由系统来决定(有自己的GC算法)，也可以通过System.gc()主动触发垃圾回收机制</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">finalize</span>练习<span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">car</span>(<span class="string">&quot;lwt&quot;</span>);</span><br><span class="line">        car = <span class="literal">null</span>; <span class="comment">//这时候 car对象是垃圾.垃圾回收器就会回收(销毁)对象.把对应的堆空间释放.</span></span><br><span class="line">        <span class="comment">//在销毁对象前,会调用finalize方法.</span></span><br><span class="line">        <span class="comment">//程序员可以在这个方法中写自己的业务逻辑.(比如数据库连接,或者打开的文件)</span></span><br><span class="line">        <span class="comment">//如果程序员不重写,则什么事都不做</span></span><br><span class="line">        System.gc(); <span class="comment">//主动调用垃圾回收器,并且程序不会阻塞.</span></span><br><span class="line">        System.out.println(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">car</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;把你😀了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><font color="#6dc1f7">抽象类</font></h2><ul>
<li>引出</li>
</ul>
<p><img src="/images/image-20220728170713624.png" alt="image-20220728170713624"></p>
<mark class="hl-label orange">小结</mark> ：

<p>当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类</p>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abstract01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span> <span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里实现了这个方法没有什么意义。</span></span><br><span class="line">    <span class="comment">//即：父类方法不确定性的问题。不同动物吃的方法不同</span></span><br><span class="line">    <span class="comment">//考虑将这个方法设计为抽象(abstract)方法</span></span><br><span class="line">    <span class="comment">//所谓抽象方法就是没有实现的方法把他抽象了。</span></span><br><span class="line">    <span class="comment">//没有实现就是没有方法体</span></span><br><span class="line">    <span class="comment">//当一个类中存在抽象方法时需要将该类声明为abstract类</span></span><br><span class="line">    <span class="comment">//一般来说，抽象类会被继承，由其子类来实现方法</span></span><br><span class="line"><span class="comment">//    public void eat()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这是一个动物，但是不知道吃什么&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决之道-抽象类快速入门</li>
</ul>
<p>​		当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰类就是抽象类。</p>
<h3 id="抽象类使用细节1"><a href="#抽象类使用细节1" class="headerlink" title="抽象类使用细节1"></a><font color="#5cb85c">抽象类使用细节1</font></h3><ul>
<li>抽象类的介绍</li>
</ul>
<ol>
<li>用abstract关键字来修饰一个类时，这个类就叫抽象类<br>访问修饰符 abstract 类名 {}</li>
<li>用abstract 关键字来修饰一个方法时，这个方法就是抽象方法<br>访问修饰符 abstract 返回类型 方法名(参数列表)；&#x2F;&#x2F;没有方法体</li>
<li>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类（）</li>
<li>抽象类，<font color="F07C82">是考官比较爱问的知识点</font>，在框架和设计模式使用较多</li>
</ol>
<ul>
<li>抽象类使用的注意事项和细节讨论</li>
</ul>
<ol>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含abstract方法。也就是说，抽象了可以没有abstract方法</li>
<li>一旦类包含了abstract方法，则这个类<font color="F07C82">必须声明为abstract</font></li>
<li>abstract只能修饰类和方法，不能修饰属性和其它的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDetial01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//抽象类不能被实例化</span></span><br><span class="line">        <span class="comment">//new A(); //false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类不一定要包含abstract方法，也就是说，抽象类可以没有abstract方法</span></span><br><span class="line"><span class="comment">//还可以有实现的方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//可以有实现的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有抽象方法的类必须为抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">//只能抽象类和方法其他不能抽象</span></span><br><span class="line">    <span class="comment">//abstract int A; //false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">S</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类的使用细节2"><a href="#抽象类的使用细节2" class="headerlink" title="抽象类的使用细节2"></a><font color="#5cb85c">抽象类的使用细节2</font></h3><ul>
<li>抽象类使用注意事项和细节2</li>
</ul>
<p>​	5、抽象类可以有任意成员[因为抽象的类还是类]，比如：非抽象方法，构造器，静态属性等等</p>
<p>​	6、抽象方法不能有主体，即不能实现</p>
<p><img src="/images/image-20220728173808898.png" alt="image-20220728173808898"></p>
<p>​	7、如果一个类继承了抽象类，则它必须<font color="F07c82">实现抽象类的所有抽象方法</font>，除非它自己也声明为abstrct类。</p>
<p>​	8、抽象方法不能使用<font color="F07C82">private、final和static来修饰</font>，因为这些关键字都是和<font color="f07c82">重写</font>相违背的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以有实现的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sss</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须把抽象父类的所有抽象方法实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sss</span><span class="params">()</span> &#123;  <span class="comment">//语法上只要有了&#123;&#125;就为方法实现</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个类都是抽象的时候就不用实现父类的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以有实现的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sss</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//有抽象方法的类必须为抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只能抽象类和方法其他不能抽象如：变量等。 抽象方法不能使用private、final和static修饰。</span></span><br><span class="line">    <span class="comment">//abstract int A; //false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">S</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">注意</mark> ：

<p>语法上只要有了{}（方法体）就为方法实现。</p>
<h3 id="抽象类课堂练习"><a href="#抽象类课堂练习" class="headerlink" title="抽象类课堂练习"></a><font color="#5cb85c">抽象类课堂练习</font></h3><p><img src="/images/image-20220728230845344.png" alt="image-20220728230845344"></p>
<mark class="hl-label orange">解答</mark> ：

<ol>
<li>不能通过，以为抽象方法一定需要被子类重写，而final表示这个方法已经满足需求，不用在被子类继承修改重写等。违背了abstract关键字。</li>
<li>不能通过，因为static表示类方法，这个方法是类所有。和重写没关系，所以这两个组合是错误的</li>
<li>不能通过，因为private关键字别的类不能访问，子类也不能，当然也不能被重写</li>
<li>看代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abstract</span>练习 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CommonEmployee</span> <span class="variable">lwt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonEmployee</span>(<span class="string">&quot;lwt&quot;</span>, <span class="number">454545</span>, <span class="number">3000</span>);</span><br><span class="line">        System.out.println(lwt.work(lwt.getName(), lwt.getId(), lwt.getSalary()));</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">jth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;jth&quot;</span>, <span class="number">898989</span>, <span class="number">30000</span>, <span class="number">2000</span>);</span><br><span class="line">        System.out.println(jth.work(jth.getName(), jth.getId(), jth.getSalary()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span> <span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">work</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBonus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBonus</span><span class="params">(<span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary, <span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, id, salary);</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">work</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        System.out.println(name + id + <span class="string">&quot;i am working&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bonus + salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommonEmployee</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonEmployee</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, id, salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">work</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        System.out.println(name + id +<span class="string">&quot;i am working&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象模板模式"><a href="#抽象模板模式" class="headerlink" title="抽象模板模式"></a><font color="#5cb85c">抽象模板模式</font></h3><p>需求：</p>
<ol>
<li>有多个类，完成不同的任务job</li>
<li>要求能够得到各自完成任务的时间</li>
<li>请编程实现</li>
</ol>
<mark class="hl-label blue">问题引出</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 抽象模板模式 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        aa.job();</span><br><span class="line"></span><br><span class="line">        <span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        bb.job();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="comment">//计算任务</span></span><br><span class="line">    <span class="comment">//1+……+10000；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//得到开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> time1 - time;</span><br><span class="line">        System.out.println(<span class="string">&quot;花费时间&quot;</span> + time2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//得到开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> time1 - time;</span><br><span class="line">        System.out.println(<span class="string">&quot;花费时间&quot;</span> + time2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要统计多个对象的job时间代码重复度高，可用模板模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 抽象模板模式 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        aa.calculateTime();</span><br><span class="line"></span><br><span class="line">        <span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        bb.calculateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="comment">//计算任务</span></span><br><span class="line">    <span class="comment">//1+……+10000；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Job</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//得到开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Job();<span class="comment">//子类重写就会调用子类的job,从而实现代码复用度高</span></span><br><span class="line">        <span class="comment">//得到结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> time1 - time;</span><br><span class="line">        System.out.println(<span class="string">&quot;花费时间&quot;</span> + time2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">注意</mark> ：

<p>动态绑定机制，不一定需要有多态，只要是继承关系，就会使用。应该是任何情况下。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><font color="#6dc1f7">接口</font></h2><ul>
<li>为什么有接口</li>
</ul>
<p><img src="/images/image-20220811135132731.png" alt="image-20220811135132731"></p>
<ul>
<li>基本介绍</li>
</ul>
<p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。语法：<br>interface 接口名{</p>
<p>​	&#x2F;&#x2F;属性名</p>
<p>​	&#x2F;&#x2F;抽象方法</p>
<p>}</p>
<p>class 类名 implements 接口 {</p>
<p>​	自己属性；</p>
<p>​	自己方法；</p>
<p>​	必须实现的接口的抽象方法</p>
<p>}</p>
<p>小结：接口是更加抽象的抽象的类，抽象类里面的方法可以有方法体，接口里的所有方法都没有方法体[jdk7.0].接口体现了程序设计的多态的高内聚低偶合的设计思想。<br>特别说：jdk8.0后接口类可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现。 </p>
<p><img src="/images/image-20220811145509931.png" alt="image-20220811145509931"></p>
<mark class="hl-label blue">注意</mark> ：

<p>implements关键字就是实现的意思，所以叫实现接口</p>
<p>default是默认方法关键字，也可重写 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hh</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hh</span><span class="params">()</span> &#123;</span><br><span class="line">    Usb.<span class="built_in">super</span>.hh();</span><br><span class="line">    System.out.println(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是接口方法，下面是重写。</p>
<p>static静态方法不能被重写。</p>
<ul>
<li>接口快速入门</li>
</ul>
<p>这样的设计需求在Java编程&#x2F;php&#x2F;.net&#x2F;go中也是会大量存在的，我曾经说过，一个程序就是一个世界，在现实世界存在的情况，在程序中也会出现，我们用程序来模拟一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="comment">//规定相关方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;<span class="comment">//方法默认是 public abstract的所以不用写也没事</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Usb</span>设备<span class="number">1</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机断开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Usb</span>设备<span class="number">2</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">    <span class="comment">//这里就相当于使用usb这个规范，就比如现实世界中，</span></span><br><span class="line">    <span class="comment">// 手柄有usb接口可用，要有这个接口就必须符合它制定的规范</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手柄启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手柄断开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Usb</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Usb</span>设备<span class="number">1</span>();</span><br><span class="line">        Usb设备<span class="number">1</span> usb设备<span class="number">1</span> = <span class="keyword">new</span> <span class="title class_">Usb</span>设备<span class="number">1</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Computer</span>().work(usb);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Computer</span>().work(usb设备<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Usb usb)</span> &#123;</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果当然都是Usb设备1里面的内容啦。</p>
<p>进一步证明动态绑定机制的重要性。</p>
<ul>
<li>深入探讨</li>
</ul>
<p>难的是不知道什么时候能使用接口</p>
<ol>
<li>说现在要制造战斗机，武装直升机，专家只需要把飞机需要的功能&#x2F;规定定下来即可，然后让别人具体实现就可以</li>
<li>说现在有一个项目经理，管理三个程序员，功能开发一个软甲，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员具体实现。<br>实际要求：3个程序员，编写三个类，分别完成对Mysql，Oracle，DB2数据库的连接 connect，close。。。<br><img src="/images/image-20220811152031678.png" alt="image-20220811152031678"><br>就是一种规定和管理，这里管理程序员的方法名。</li>
</ol>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a><font color="#5cb85c">使用细节</font></h3><ol>
<li>接口不能被实例化</li>
<li>接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰<br><img src="/images/image-20220811152836644.png" alt="image-20220811152836644"></li>
<li>一个普通类实现接口，就必须将接口的所有方法都是实现。默认方法已经有方法体就不用实现，重不重写都可以，static方法一定不能重写。</li>
<li>抽象类实现，可以不用实现接口的方法(抽象类可以包含抽象方法。)</li>
<li>一个类同时可以实现多个接口</li>
<li>接口中的属性，只能是final的，而且是public static final 修饰符。比如：int a &#x3D; 1；实际上是public static final int a &#x3D; 1；(必须初始化)</li>
<li>接口中属性的访问形式:接口名.属性名</li>
<li>一个接口不能继承其他的类，但是可以继承多个别的接口<br><img src="/images/image-20220811154207966.png" alt="image-20220811154207966"></li>
<li>接口的修饰符只能是public 和默认，这点和类的修饰符是一样的。</li>
</ol>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a><font color="#5cb85c">课堂练习</font></h3><p><img src="/images/image-20220811161737651.png" alt="image-20220811161737651"></p>
<mark class="hl-label blue">注意</mark> ：

<p>重要概念，static修饰的可以被继承和引用，但是不能重写，<font color="EE3F4D">static是可以被继承和引用的。</font></p>
<h3 id="接口VS继承"><a href="#接口VS继承" class="headerlink" title="接口VS继承"></a><font color="#5cb85c">接口VS继承</font></h3><h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常-Exception"></a><font color="#6dc1f7">异常-Exception</font></h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><font color="#5cb85c">基本概念</font></h3><blockquote>
<p>Java语言中，将程序执行中发生的不正常情况称为“<mark class="hl-label default">异常</mark> ”。(开发过程中的语法错误和逻辑错误不是异常)。</p>
<p>执行过程中所发生的异常事件可分为两类</p>
<p>1)Error(错误)：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError[栈溢出]和OOM(out of memory)，Error是严重错误，程序会崩溃。</p>
<p>2)Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等。Exception分为两大类：运行时异常[]和编译时异常[]。</p>
</blockquote>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1、num1/num2 = 10/0</span></span><br><span class="line">    <span class="comment">//2、当程序执行到num1/num2时，因为分母为0程序会抛出异常 ArithmeticException</span></span><br><span class="line">    <span class="comment">//3、当抛出异常后，程序退出，崩溃了，下面的代码就不在运行</span></span><br><span class="line">    <span class="comment">//4、但是这样并不好，一个不致命的错误就导致整个代码奔溃</span></span><br><span class="line">    <span class="comment">//5、java设计者，提供了一个叫 异常处理机制来解决该问题</span></span><br><span class="line">    <span class="comment">//如果程序员，认为一段代码可能出现异常/问题，可以使用try-catch异常处理机制来解决</span></span><br><span class="line">    <span class="comment">//保证代码的健壮度</span></span><br><span class="line">    <span class="comment">//idea快捷键 ctrl + alt + t -&gt; 选中try-catch</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> num1 / num2 ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();       </span><br><span class="line">        System.out.println(e.getMessage());  <span class="comment">//输出异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;代码继续运行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">结果</mark> ：

<p><img src="/images/image-20220607154948429.png" alt="image-20220607154948429"></p>
<mark class="hl-label purple">总结</mark> ：

<p>可以看到这个代码有异常出现的时候还能继续执行下面。异常保证了代码的健壮度。</p>
<h3 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a><font color="#5cb85c">异常体系图</font></h3><p><img src="/images/image-20220607155937584.png" alt="image-20220607155937584"></p>
<p><img src="/images/image-20220607155703202.png" alt="image-20220607155703202"></p>
<mark class="hl-label purple">总结</mark> ：

<p>该图只是举例几个常见的异常，还有很多异常。总体上继承Throwable这个类，然后这个类实现了Serializable接口的方法。有编译时候异常，运行时候异常。还有一大类就是错误。</p>
<h2 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a><font color="#6dc1f7">事件处理机制</font></h2><p>收录到文章<font color="#1661AB">坦克大战</font>中。</p>
<h2 id="八大Wrapper-包装-类"><a href="#八大Wrapper-包装-类" class="headerlink" title="八大Wrapper(包装)类"></a><font color="#6dc1f7">八大Wrapper(包装)类</font></h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a><font color="#5cb85c">包装类</font></h3><ul>
<li>包装类的分类</li>
</ul>
<ol>
<li>针对八种基本数据类型相应的引用类型——包装类</li>
<li>有了类的特点，就可以调用类中的方法</li>
</ol>
<p><img src="/images/image-20220712125028970.png" alt="image-20220712125028970"></p>
<mark class="hl-label blue">解析</mark> ：

<p>黄色区域的父类都是：Number。</p>
<p>由于都是类就可以调用其中许多方法。</p>
<mark class="hl-label red">Boolean</mark> ：-> boolean

<p><img src="/images/image-20220712153022330.png" alt="image-20220712153022330"></p>
<mark class="hl-label purple">Character</mark> ： -> char

<p><img src="/images/image-20220712153213992.png" alt="image-20220712153213992"></p>
<mark class="hl-label blue">Number</mark> ： -> Byte、Short 、Integer 、Long、Float、Double

<p><img src="/images/image-20220712154422681.png" alt="image-20220712154422681"> </p>
<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a><font color="#5cb85c">装箱和拆箱</font></h3><ul>
<li>包装类和基本数据的转换<ol>
<li>jdk5前的手动装箱和拆箱方式，装箱：基本类型-&gt;包装类型，反之，拆箱</li>
<li>jdk5以后(含jdk5)的自动装箱和拆箱方式</li>
<li>自动装箱底层调用的是valueOf方法，比如Integer.valueOf()</li>
</ol>
</li>
</ul>
<mark class="hl-label blue">案例Integer</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//jdk5以前是手动拆箱和装箱</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);<span class="comment">//手动装箱</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1);<span class="comment">//手动装箱</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();<span class="comment">//手动拆箱</span></span><br><span class="line">    <span class="comment">//jdk5和jdk5以后就可以自动装箱和拆箱</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> n2; <span class="comment">//自动装箱  底层用的是Integer.valueOf(int int); 断点调试</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> integer2; <span class="comment">// 自动拆箱，底层仍然使用的是intValue()方法 .断点调试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">断点Debug</mark> ：

<p><img src="/images/image-20220712163144537.png" alt="image-20220712163144537"></p>
<p><img src="/images/image-20220712163500982.png" alt="image-20220712163500982"></p>
<blockquote>
<p>其他包装类的用法类似。</p>
</blockquote>
<mark class="hl-label purple">练习</mark> ：

<p><img src="/images/image-20220712193431936.png" alt="image-20220712193431936"></p>
<mark class="hl-label red">知识补充</mark> ：

<blockquote>
<p>添加尾缀说明</p>
<p>Java在变量赋值的时候，其中float、double、long数据类型变量，需要在赋值直接量后面分别添加f或F、d或D、l或L尾缀来说明。其中，long类型最好以大写L来添加尾缀，因为小写l容易和数字1混淆。</p>
</blockquote>
<p><img src="/images/image-20220712194150836.png" alt="image-20220712194150836"></p>
<mark class="hl-label red">注意</mark> ：

<blockquote>
<p>三元运算符是一个整体，虽然输出int类型，但是整体已经上升到double的精度。</p>
</blockquote>
<p><img src="/images/image-20220712200702129.png" alt="image-20220712200702129"></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><font color="#6dc1f7">集合</font></h2><p><img src="/images/image-20220722115722496.png" alt="image-20220722115722496"></p>
<h3 id="集合介绍"><a href="#集合介绍" class="headerlink" title="集合介绍"></a><font color="#5cb85c">集合介绍</font></h3><mark class="hl-label purple">集合的理解和好处</mark> ：

<p>前面我们保存多个数据使用的是数组，那么数组有不足的地方，我们分析一下。</p>
<ul>
<li>数组</li>
</ul>
<ol>
<li>长度开始时必须指定，而且一旦指定，不能更改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行增加&#x2F;删除元素的示意代码–比较麻烦</li>
</ol>
<mark class="hl-label purple">案例</mark> ：

<p>&#x2F;&#x2F;增加新的Person对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person[] pers2 = <span class="keyword">new</span> <span class="title class_">Person</span>[pers1.length+<span class="number">1</span>]; <span class="comment">//创建新的数组：长度比原来多一</span></span><br><span class="line"><span class="keyword">for</span>&#123;&#125; <span class="comment">//拷贝数组</span></span><br><span class="line">pers2[pers2.length-<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//添加新增的对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>集合</li>
</ul>
<ol>
<li>可以<font color="EE3F4D">动态保存</font>任意多个对象，使用比较方便！</li>
<li>提供了一系列方便的操作对象的方法：add、remove、set、get等</li>
<li>使用集合添加，删除新元素的示意代码–简洁了</li>
</ol>
<h3 id="集合体系图"><a href="#集合体系图" class="headerlink" title="集合体系图"></a><font color="#5cb85c">集合体系图</font></h3><p><img src="/images/image-20220711231316037.png" alt="image-20220711231316037"></p>
<ol>
<li>集合主要是两组(单列集合，双列集合)</li>
<li>Collection  接口有两个重要的子接口 List Set(如上图所示)，他们的实现子类都是单列集合</li>
<li>Map 接口的实现子类 是双列集合，存放的&lt;K,V&gt; (如下图所示)</li>
</ol>
<p><img src="/images/image-20220712113701593.png" alt="image-20220712113701593"></p>
<mark class="hl-label purple">示例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collection01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">// Collection</span></span><br><span class="line">       <span class="comment">// Map</span></span><br><span class="line">        ArrayList&lt;Object&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;lwt&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="number">1</span>,<span class="string">&quot;lwt&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="number">2</span>,<span class="string">&quot;lwt2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collection方法"><a href="#Collection方法" class="headerlink" title="Collection方法"></a><font color="#5cb85c">Collection方法</font></h3><ul>
<li>Collection接口实现类的特点：</li>
</ul>
<p>​		public interface Collection&lt; E &gt; extends Iterable&lt; E &gt;</p>
<ol>
<li>Collection实现子类可以存放多个元素，每个元素可以是Object</li>
<li>有些Collection的实现类，可以存放重复的元素，有些不可以</li>
<li>有些Collection的实现类，有些是有序的(List),有些不是有序(Set)</li>
<li>Collection接口没有直接的实现子类，是通过它的接口Set和List来实现的</li>
</ol>
<ul>
<li>Collection接口常用方法，以实现子类</li>
</ul>
<ol>
<li>add:添加单个元素<font color="681752">（返回boolean值）</font></li>
<li>remove:删除指定元素<font color="681752">（返回boolean值）</font></li>
<li>contains:查找元素是否存在<font color="681752">（返回boolean值）</font></li>
<li>size:获取元素个数<font color="681752">（返回长度int）</font></li>
<li>isEmpty:判断是否为空<font color="681752">（返回boolean值）</font></li>
<li>clear:清空<font color="681752">（void）</font></li>
<li>addAll:添加多个元素<font color="681752">（传入集合，返回boolean值）</font></li>
<li>containAll:查找多个元素是否都存在<font color="681752">（传入集合，返回boolean值）</font></li>
<li>removeAll:删除多个元素<font color="681752">（传入集合，返回boolean值）</font></li>
</ol>
<mark class="hl-label purple">ArrayList演示</mark> ：

<p>因为只有实现了这个接口的类才可以被实例化，选用ArrayList集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionMethod01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// add:添加单个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="number">10</span>); <span class="comment">//自动装箱 变成Integer</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="literal">true</span>);<span class="comment">//自动装箱</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// remove: 删除对象</span></span><br><span class="line">        list.remove(<span class="string">&quot;jack&quot;</span>); <span class="comment">//指定删除某个对象，并返回boolean值。这里就删除第一个jack不会删除两个jack</span></span><br><span class="line">        list.remove(<span class="number">0</span>); <span class="comment">//根据索引删除 。这里删除第0位置的元素,并返回删除元素Object</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//contains: 查找元素是否存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="literal">true</span>)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//size: 集合的长度 获取元素的个数</span></span><br><span class="line">        System.out.println(list.size()); <span class="comment">//2</span></span><br><span class="line">        <span class="comment">//isEmpty: 判断元素是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());<span class="comment">// false</span></span><br><span class="line">        <span class="comment">//clear: 清空</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//addAll: 添加多个元素。传入一个集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list2.add(<span class="string">&quot;qwer&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        <span class="comment">//containsAll: 查找多个元素是否存在,传入的是一个集合</span></span><br><span class="line">        System.out.println(list.containsAll(list2)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//removeAll: 删除多个元素 ，也是传入一个集合</span></span><br><span class="line">        list.add(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line">        list.removeAll(list2); <span class="comment">//返回boolean值</span></span><br><span class="line">        System.out.println(list); <span class="comment">// &quot;ssss&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a><font color="#5cb85c">迭代器遍历</font></h3><ul>
<li><p>Collection接口遍历元素<font color="#EE4866">方式1-使用Iterator(迭代器)</font></p>
<p>基本介绍：</p>
<p><img src="/images/image-20220714132634184.png" alt="image-20220714132634184"></p>
<ol>
<li>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。</li>
<li>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器。</li>
<li>Iterator的结构图。</li>
<li>Iterator仅用于遍历集合，Iterator本身并不存放对象。</li>
</ol>
</li>
<li><p>迭代器的执行原理</p>
</li>
</ul>
<p>​		Iterator iterator &#x3D; coll.iterator();  &#x2F;&#x2F;<code>iterator();</code><font color="#EE4866">返回一个迭代器Iterator</font>。</p>
<p>​		&#x2F;&#x2F;hasNext();判断是否还有下一个元素,这是<font color="#EE4866">迭代器里面的方法</font>,从-1开始。</p>
<p>​		while(iterator.hasNext()){</p>
<p>​		&#x2F;&#x2F;next(); 1、指针下移 2 、将下移后集合指针位置上的元素返回</p>
<p>​		System.out.println(iterator.next());</p>
<p>​		}</p>
<p><img src="/images/image-20220714150451660.png" alt="image-20220714150451660"></p>
<p><img src="/images/image-20220714151718187.png" alt="image-20220714151718187"></p>
<mark class="hl-label red">注意</mark> ：

<p>在调用iterator.next()方法之前必须要调用iterator.hasNext()进行检测。若不调用，且下一条记录无效，直接调用iterator.next()会抛出NoSuchElementException异常。</p>
<mark class="hl-label purple">演示</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;西游记&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>,<span class="number">89</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;你在干什么&quot;</span>,<span class="string">&quot;氢气球&quot;</span>,<span class="number">998</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;配哦我看到看到&quot;</span>,<span class="string">&quot;威威企鹅&quot;</span>,<span class="number">9878</span>));</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="comment">//1、得到集合的迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span>col.iterator();</span><br><span class="line">        <span class="comment">//2、使用while集合遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//返回下一个元素，类型的Object</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(obj);  <span class="comment">//这里涉及到动态绑定机制，obj编译类型确实是Object类，运行类型是book</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快捷键（itit）  或者ctrl+J 可以提示当前的快捷键</span></span><br><span class="line">        <span class="comment">//3、当迭代器退出while循环后，这时候iterator迭代器指向最后一个元素</span></span><br><span class="line">        iterator.next(); <span class="comment">//在取一个就会超出，报出异常NoSuchElementException</span></span><br><span class="line">        <span class="comment">//4、如果需要再次遍历集合，需要重置遍历器</span></span><br><span class="line">        iterator = col.iterator(); <span class="comment">//重置遍历器</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">book</span><span class="params">(String name, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p><code>iterator.next();</code>返回的是Object类型，在<code>print</code>的时候会调用toString，因为book是Object的子类，并且也有重写toString。这是动态绑定机制，最终调用book里面的toString方法完成<code>print</code>。迭代器的快捷键是itit。其他快捷键是<code>Ctrl加J</code>。</p>
<ul>
<li>Collection接口遍历对象<font color="#EE4866">方式2-for循环增强</font></li>
</ul>
<p>​		增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样。<font color="#EE4866">只能用于遍历集合或数组</font>。</p>
<p>​	基本语法</p>
<p>​	for(元素类型 元素名：集合名或数组名) {</p>
<p>​		访问元素</p>
<p>​	}</p>
<mark class="hl-label purple">演示</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionFor</span>遍历 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;西游记&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>,<span class="number">89</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;你在干什么&quot;</span>,<span class="string">&quot;氢气球&quot;</span>,<span class="number">998</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;配哦我看到看到&quot;</span>,<span class="string">&quot;威威企鹅&quot;</span>,<span class="number">9878</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用增强for遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Object book : col) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//增强for也可以直接在数组上使用</span></span><br><span class="line">        <span class="type">int</span> [] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j: nums) &#123;</span><br><span class="line">            System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Debug源码来证明</p>
<p><img src="/images/image-20220714203113831.png" alt="image-20220714203113831"></p>
<p><img src="/images/image-20220714203125711.png" alt="image-20220714203125711"></p>
<p><img src="/images/image-20220714203228508.png" alt="image-20220714203228508"></p>
<mark class="hl-label purple">小结</mark> ：

<ol>
<li>可以得到增强for<font color="#EE4866">底层原理是iterator迭代器</font>。</li>
<li>增强for可以理解成简化版本的迭代器遍历。</li>
<li>快捷键是大写<font color="#EE4866"> I</font>。</li>
</ol>
<mark class="hl-label blue">课堂练习</mark> ：

<blockquote>
<p>1、创建3个Dog{name,age}对象,放入到ArrayList中,赋给List引用<br>2、用迭代器和增强for循环两种方式来遍历<br>3、重写Dog的toString方法,输出name和age</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collection</span>课堂练习 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;Object&gt; collection = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//向上转型</span></span><br><span class="line">        collection.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;lwt&quot;</span>,<span class="number">11</span>));</span><br><span class="line">        collection.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;牧羊犬&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        <span class="keyword">for</span> (Object o : collection) &#123;<span class="comment">//增强for</span></span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();<span class="comment">//迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">Dog</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(Dog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>集合由于有许多接口，用到许多多态写法<code>Iterable list = new ArrayList&lt;&gt;();</code>这种写法也是可以的。但是<code>Iterable</code>中没有<code>add()</code>等方法。</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a><font color="#5cb85c">List接口</font></h3><ul>
<li>List接口基本介绍</li>
</ul>
<p>​	List接口是Collection接口的子接口</p>
<ol>
<li>List集合类中元素<font color="#EE4866">有序(即添加顺序和取出顺序一致)、且可重复</font>。</li>
<li>List集合中的每个元素都有其对应的顺序索引，即支持索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类有：</li>
</ol>
<p><img src="/images/image-20220714212356328.png" alt="image-20220714212356328"></p>
<mark class="hl-label blue">案例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、List集合类中元素有序(即添加顺序和取出顺序一致)、且可重复[案例]</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;milk&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[jack, tom, milk, mary]</span></span><br><span class="line">        <span class="comment">//2、List集合中的每个元素都有其对应的顺序索引，即支持索引</span></span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>)); <span class="comment">//当然索引是从0开始的 得到jack</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>List接口的常用方法</li>
</ul>
<p>​	List集合里添加了一些根据索引来操作集合元素的方法</p>
<ol>
<li>void add(int index, Object ele):在index位置插入ele元素,没有索引默认加在最后</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index): 获取指定index位置的元素</li>
<li>int indexOf(Object obj): 返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj): 返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele): 设置指定index位置的元素为ele，相当于是替换，返回被删除的元素</li>
<li>List subList(int fromIndex, int toIndex): 返回从fromIndex到toIndex位置的子集合</li>
</ol>
<mark class="hl-label blue">演示</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//多态写法，向上转型</span></span><br><span class="line">        list.add(<span class="string">&quot;小狗&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;小猫&quot;</span>);</span><br><span class="line"><span class="comment">//        1. void add(int index, Object ele):在index位置插入ele元素,没有索引默认加在最后</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;小狼&quot;</span>); <span class="comment">//注意是从0开始索引就行</span></span><br><span class="line">        System.out.println(list); <span class="comment">//[小狗, 小狼, 小猫]</span></span><br><span class="line"><span class="comment">//        2. boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;milk&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.addAll(list1);</span><br><span class="line">        System.out.println(list);<span class="comment">//[小狗, 小狼, 小猫, mary, milk, tom]</span></span><br><span class="line"><span class="comment">//        3. Object get(int index): 获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>)); <span class="comment">//&quot;小狼&quot;</span></span><br><span class="line"><span class="comment">//        4. int indexOf(Object obj): 返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;小猫&quot;</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//        5. int lastIndexOf(Object obj): 返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        list.add(<span class="string">&quot;小猫&quot;</span>);</span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;小猫&quot;</span>));<span class="comment">//6</span></span><br><span class="line"><span class="comment">//        6. Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        System.out.println(list.remove(<span class="number">2</span>));<span class="comment">//小猫</span></span><br><span class="line"><span class="comment">//        7. Object set(int index, Object ele): 设置指定index位置的元素为ele，相当于是替换。</span></span><br><span class="line">        System.out.println(list.set(<span class="number">5</span>, <span class="string">&quot;Tom&quot;</span>));<span class="comment">//返回被删除的对象</span></span><br><span class="line"><span class="comment">//        8. List subList(int fromIndex, int toIndex): 返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        System.out.println(list.subList(<span class="number">0</span>, <span class="number">3</span>));<span class="comment">//[小狗, 小狼, mary]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">练习</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    添加10个以上的元素(比如String &quot;hello&quot;)，</span></span><br><span class="line"><span class="comment">    在2号位插入一个元素&quot;韩顺平教育&quot;，获得第5个元素，删除第6个元素，</span></span><br><span class="line"><span class="comment">    修改第7个元素，在使用迭代器遍历集合，要求:使用List的实现类ArrayList完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List</span>练习 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//多态写法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;hello&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;韩顺平教育&quot;</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">4</span>));</span><br><span class="line">        list.remove(<span class="number">5</span>);</span><br><span class="line">        list.set(<span class="number">6</span>,<span class="string">&quot;修改&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.print(next+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>注意一下索引和位置的差别，索引从0开始</p>
<h4 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a><font color="#ffd253">List遍历</font></h4><ul>
<li>List的三种遍历方式</li>
</ul>
<ol>
<li><p>方式一：使用iterator</p>
<p>Iterator iter &#x3D; col.iterator();</p>
<p>​		while(iter.hasNext()){</p>
<p>​			Object o &#x3D; iter.next();</p>
<p>​		}</p>
</li>
<li><p>方式二：使用增强for<br>for(Object o : col){<br>}</p>
</li>
<li><p>方式三： 使用普通for<br>for(int i&#x3D;0; i&lt;list.size(); i++){</p>
<p>Object object &#x3D; list.get(i);</p>
<p>System.out.println(Object);<br>}</p>
</li>
</ol>
<p>	</p>
<mark class="hl-label blue">说明</mark> ：

<p>使用<font color="#0F59A4">List子类</font>的完成使用方式和ArrayList一样，都能使用这三种方式。</p>
<mark class="hl-label blue">演示</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List</span>遍历 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;mike&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、迭代器iterator遍历</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="comment">//2、增强for</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="comment">//3、普通for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">练习</mark> ：

<p><img src="/images/image-20220715143755603.png" alt="image-20220715143755603"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List</span>练习<span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//      List&lt;Book7&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">//      List&lt;Book7&gt; list = new LinkedList&lt;&gt;();</span></span><br><span class="line">        List&lt;Book7&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//使用了泛型，list里面不是Object所以就不用向下转型</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book7</span>(<span class="string">&quot;水浒传&quot;</span>,<span class="number">99</span>,<span class="string">&quot;施耐庵&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book7</span>(<span class="string">&quot;西游记&quot;</span>,<span class="number">77</span>,<span class="string">&quot;吴承恩&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book7</span>(<span class="string">&quot;三国演义&quot;</span>,<span class="number">120</span>,<span class="string">&quot;罗贯中&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book7</span>(<span class="string">&quot;ss&quot;</span>,<span class="number">2</span>,<span class="string">&quot;s&quot;</span>));</span><br><span class="line">        sort(list);</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;Book7&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">Book7</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; list.size()-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(j).getPrice() &gt; list.get(j+<span class="number">1</span>).getPrice()) &#123;</span><br><span class="line">                    temp = list.get(j);</span><br><span class="line">                    list.set(j,list.get(j+<span class="number">1</span>));</span><br><span class="line">                    list.set(j+<span class="number">1</span>,temp);</span><br><span class="line">                    <span class="comment">//或者将交换的对象都赋给Book7类，这样不用temp</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book7</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book7</span><span class="params">(String name, <span class="type">double</span> price, String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>这里使用了泛型，不用泛型在取<code>price</code>的时候需要向下转型。使用<code>Vector</code> <code>LinkedList</code> ，只需将<code>ArrayList</code>换成对应即可，这是多态的一个好处:易扩展和维护。</p>
<h4 id="ArrayList的注意事项"><a href="#ArrayList的注意事项" class="headerlink" title="ArrayList的注意事项"></a><font color="#ffd253">ArrayList的注意事项</font></h4><ul>
<li>ArrayList的注意事项</li>
</ul>
<ol>
<li>permits all elements, including null, Arraylist可以加入null,并且多个</li>
<li>ArrayList 是由数组来实现数据存储的</li>
<li>Arraylist基本等同于Vector，除了ArrayList是线程不安全(执行效率高)看源码，在多线程情况下，不建议使用ArrayList</li>
</ol>
<p><img src="/images/image-20220715143715733.png" alt="image-20220715143715733"></p>
 <mark class="hl-label blue">解释</mark> ：

<p>可以看到add方法前面没有synchronized(同步锁)，所以他线程不安全。</p>
<p><img src="/images/image-20220715144252948.png" alt="image-20220715144252948"></p>
<p>这是Vector集合的add方法。用有synchronized(同步锁)。</p>
<h4 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a><font color="#ffd253">ArrayList扩容机制</font></h4><ul>
<li>ArrayList的底层操作机制源码分析<font color="#FBDA41">(重难点)</font></li>
</ul>
<ol>
<li>ArrayList中维护了一个Object类型的数组elementData.[debug看源码]<br>transient Object[] elementData; &#x2F;&#x2F;transient 表示瞬间，短暂的，表示该属性不会被序列化</li>
<li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次<br>添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍。</li>
<li>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，<br>则直接扩容elementData为1.5倍。</li>
</ol>
<h4 id="ArrayList底层源码"><a href="#ArrayList底层源码" class="headerlink" title="ArrayList底层源码"></a><font color="#ffd253">ArrayList底层源码</font></h4> <mark class="hl-label blue">代码</mark> ：

<p>无参构造器的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListsource</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        ArrayList list = new ArrayList(9);</span></span><br><span class="line">        <span class="comment">//使用无参构造创建ArrayList</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add( i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        list.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ArrayList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81.png"></p>
 <mark class="hl-label red">注意</mark> ：

<ol>
<li>这是JDK8的源码，不同版本的JDK版本源码不同。</li>
<li>其中size参数是ArrayList数组中包含的元素(不是容量)。</li>
<li>每次都有一个minCapacity，即size+1。</li>
<li>二进制数&gt;&gt;1，相当于&#x2F;2 。</li>
</ol>
<p>有参构造器源码：</p>
<p><img src="/images/image-20220716203219198.png" alt="image-20220716203219198"></p>
 <mark class="hl-label blue">解释和对比</mark> ：

<p>有参构造器的参数是改变elementData数组的长度，第一次扩容就是根据参数的大小扩大1.5倍。</p>
<p>区别：无参构造器第一次<code>DEFAULT_CAPACITY</code>作为容量默认为10，而有参构造器根据参数。</p>
<h4 id="Vector注意事项"><a href="#Vector注意事项" class="headerlink" title="Vector注意事项"></a><font color="#ffd253">Vector注意事项</font></h4><ul>
<li>Vector的基本介绍</li>
</ul>
<ol>
<li>Vector类的定义说明<br><img src="/images/image-20220716204159197.png" alt="image-20220716204159197"></li>
<li>Vector底层也是一个对象数组，protected Object[] elementData</li>
<li>Vector是线程同步的，即线程安全、Vector类的操作方法(get、set等)带有synchronized（同步锁）</li>
<li>在开发中，需要<font color="D2568C">线程同步安全</font>&gt;时，考虑使用Vector</li>
</ol>
<h4 id="Vector源码解读"><a href="#Vector源码解读" class="headerlink" title="Vector源码解读"></a><font color="#ffd253">Vector源码解读</font></h4><ul>
<li>Vector和ArrayList的比较</li>
</ul>
<p><img src="/images/image-20220716204929859.png" alt="image-20220716204929859"></p>
 <mark class="hl-label blue">代码</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//无参构造器</span></span><br><span class="line">        <span class="comment">//Vector vector = new Vector&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//源码</span></span><br><span class="line"><span class="comment">//        public Vector() &#123;</span></span><br><span class="line"><span class="comment">//            this(10);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//源码</span></span><br><span class="line"><span class="comment">//        public Vector(int initialCapacity) &#123;</span></span><br><span class="line"><span class="comment">//            this(initialCapacity, 0);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        public Vector(int initialCapacity, int capacityIncrement) &#123;</span></span><br><span class="line"><span class="comment">//            super();</span></span><br><span class="line"><span class="comment">//            if (initialCapacity &lt; 0)</span></span><br><span class="line"><span class="comment">//                throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span></span><br><span class="line"><span class="comment">//                        initialCapacity);</span></span><br><span class="line"><span class="comment">//            this.elementData = new Object[initialCapacity];</span></span><br><span class="line"><span class="comment">//            this.capacityIncrement = capacityIncrement;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector.add(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//集合扩容源码</span></span><br><span class="line"><span class="comment">//        private void grow(int minCapacity) &#123;</span></span><br><span class="line"><span class="comment">//            // overflow-conscious code</span></span><br><span class="line"><span class="comment">//            int oldCapacity = elementData.length;</span></span><br><span class="line"><span class="comment">//            int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span></span><br><span class="line"><span class="comment">//                    capacityIncrement : oldCapacity);</span></span><br><span class="line"><span class="comment">//            if (newCapacity - minCapacity &lt; 0)</span></span><br><span class="line"><span class="comment">//                newCapacity = minCapacity;</span></span><br><span class="line"><span class="comment">//            if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span></span><br><span class="line"><span class="comment">//                newCapacity = hugeCapacity(minCapacity);</span></span><br><span class="line"><span class="comment">//            elementData = Arrays.copyOf(elementData, newCapacity);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label red">注意</mark> ：

<p>有参构造器与无参构造器的区别是：传入了一个<code>initialCapacity</code>并调用另外一个构造器，并用这个数确定<code>elementData</code>数组的大小。</p>
<p><img src="/images/image-20220717110233997.png" alt="image-20220717110233997"></p>
<p><img src="/images/image-20220717110252747.png" alt="image-20220717110252747"></p>
<p>其余都和ArrayLIst差不多，grow有些许不同。</p>
<p><img src="/images/image-20220717110423186.png" alt="image-20220717110423186"></p>
<h4 id="LinkedList底层结构"><a href="#LinkedList底层结构" class="headerlink" title="LinkedList底层结构"></a><font color="#ffd253">LinkedList底层结构</font></h4><ul>
<li>LinkedList的全面说明</li>
</ul>
<ol>
<li>LinkedList底层实现了双向链表和双端队列特点</li>
<li>可以添加任意元素(元素可以重复)，包括null</li>
<li>线程不安全，没有实现同步</li>
</ol>
<ul>
<li>LinkedList的底层操作机制</li>
</ul>
<ol>
<li>LinkedList底层维护了一个双向链表。</li>
<li>LinkedLIst中维护了两个属性first和last分别指向首节点和尾节点。</li>
<li>每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过<br>prev指向前一个，通过next指向后一个节点。最终实现双向链表。</li>
<li>所以LinkedList的元素的添加元素删除，不是通过数组完成的，相对来说效率高。</li>
</ol>
 <mark class="hl-label blue">模拟双向链表</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">mike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">marry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Marry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      tom-&gt;mike-&gt;mike</span></span><br><span class="line">        tom.next = mike;</span><br><span class="line">        mike.next = marry;</span><br><span class="line"><span class="comment">//      marry-&gt;mike-&gt;tom</span></span><br><span class="line">        marry.prev = mike;</span><br><span class="line">        mike.prev = tom;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      首尾定义</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> tom;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> marry;</span><br><span class="line"><span class="comment">//      遍历(从头到尾)</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(first);</span><br><span class="line">                first = first.next; <span class="comment">//指向下一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                first = tom;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      遍历(从尾到头)</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="literal">null</span>) &#123;</span><br><span class="line">                last = marry;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(last);</span><br><span class="line">            last = last.prev;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      链表优越的地方，添加和删除元素</span></span><br><span class="line"><span class="comment">//      在mike和marry中间加元素</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">sss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;SSS&quot;</span>);</span><br><span class="line">        mike.next = sss;</span><br><span class="line">        sss.next = marry;</span><br><span class="line"></span><br><span class="line">        marry.prev = sss;</span><br><span class="line">        sss.prev = mike;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(first);</span><br><span class="line">                first = first.next; <span class="comment">//指向下一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                first = tom;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Node类,被实例化的Node对象可以当作一个双向链表的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object item; <span class="comment">//真正存放数据的地方</span></span><br><span class="line">    <span class="keyword">public</span> Node next; <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> Node prev; <span class="comment">//指向前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;item=&quot;</span> + item +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList源码"><a href="#LinkedList源码" class="headerlink" title="LinkedList源码"></a><font color="#ffd253">LinkedList源码</font></h4><ul>
<li>LinkedList的增删改查案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        linkedList.add(<span class="number">1</span>);</span><br><span class="line">        linkedList.add(<span class="number">2</span>);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//默认删除的是第一个结点</span></span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        linkedList.set(<span class="number">1</span>,<span class="number">999</span>);<span class="comment">//注意索引也是从0开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器底层源码</li>
</ul>
<p><img src="/images/image-20220718153426938.png" alt="image-20220718153426938"></p>
<p><img src="/images/image-20220718153415913.png" alt="image-20220718153415913"></p>
 <mark class="hl-label red">注意</mark> ：

<p>构造器创建后有四个参数：size,first,last,modCount。无参默认都为0；而他另一个有参构造器源码如下，调用无参构造器，和<code>addAll();</code>方法。</p>
<p><img src="/images/image-20220718154122054.png" alt="image-20220718154122054"></p>
 <mark class="hl-label red">注意</mark> ：

<p>其中<code>&lt;? extends E&gt;</code>指的是E这个类和其子类。</p>
<ul>
<li>LinkedList <code>add();</code>方法源码</li>
</ul>
<p><img src="/images/image-20220718154323649.png" alt="image-20220718154323649"></p>
<p><img src="/images/image-20220718154432152.png" alt="image-20220718154432152"></p>
 <mark class="hl-label blue">解释</mark> ：

<p>集合中存放的是一个个Node类(结点)。</p>
<p><code>last</code>指的是LinkedList的最后一个Node，所以这里<code>add</code>方法默认是添加元素到末尾。</p>
<p><code>last = newNode</code> 这就保证了传入的元素都会先变成集合的last</p>
<p>如果集合中没有元素，则进入if第一个判断，将<code>first</code>也给原本<code>last</code>元素；</p>
<p>如果集合中原本有元素，那么<code>last</code>指向的Node肯定是集合中最后一个，然后进入if的第二个判断，将原本集合的”last” 也就是<code>l</code>的next指向新传入的newNode(也是现在的<code>last</code>)。</p>
<p>Node类是一个结点，上图中的三个参数分别为<code>prev</code> <code> item</code> <code>next</code>.就是指向前一个Node、内容和指向后一个Node。具体如下图所示</p>
<p><img src="/images/image-20220718154747317.png" alt="image-20220718154747317"></p>
<ul>
<li>LinkedList remove();方法</li>
</ul>
<p><img src="/images/image-20220718172947080.png" alt="image-20220718172947080"></p>
<p><img src="/images/image-20220718173152218.png" alt="image-20220718173152218"></p>
<p><img src="/images/image-20220718224517790.png" alt="image-20220718224517790"></p>
 <mark class="hl-label blue">解释</mark> ：

<p>原理就是将结点的<code>next</code>和 <code>prev</code>改变。上面注释中 help.gc是Java处理机制，会把第一个元素认为是一个垃圾。</p>
<p>也可以删除指定位置的元素，索引也是从0开始，使用了类似对分查找的方法，但是最终还是走的是<code>unlink()</code>方法。</p>
<ul>
<li>遍历方式</li>
</ul>
<p>​	因为LinkedList是实现了List接口的，所以可以使用<code>iterator</code>迭代器，增强for和普通for循环。详见<code>List</code>遍历方式。</p>
<h3 id="List集合选择"><a href="#List集合选择" class="headerlink" title="List集合选择"></a><font color="#5cb85c">List集合选择</font></h3><ul>
<li>ArrayList和LinkedList的比较</li>
</ul>
<p><img src="/images/image-20220814153217844.png" alt="image-20220814153217844"></p>
<p>如何选择ArrayList和LinkedList：</p>
<ol>
<li>如果我们改查的操作多，选择ArrayList</li>
<li>如果我们增删的操作多，选择LinkedList</li>
<li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList</li>
<li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList.</li>
<li>注意插入方式的不同尾插和头插两者效率不同，头插入是LinkedList双向链表快。具体看<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903790156447752?tdsourcetag=s_pctim_aiomsg">https://juejin.cn/post/6844903790156447752?tdsourcetag=s_pctim_aiomsg</a><br><img src="/images/image-20220911232259220.png" alt="image-20220911232259220"></li>
</ol>
<h2 id="Set接口方法"><a href="#Set接口方法" class="headerlink" title="Set接口方法"></a><font color="#6dc1f7">Set接口方法</font></h2><ul>
<li>Set接口基本介绍</li>
</ul>
<ol>
<li>无序（添加和取出的顺序不一致），没有索引</li>
<li>不允许重复元素，所以最多包含一个null</li>
<li>JDK API中set接口的实现类有：</li>
</ol>
<p><img src="/images/image-20220814162725887.png" alt="image-20220814162725887"></p>
<ul>
<li>Set接口的常用方法</li>
</ul>
<p>和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样</p>
<ul>
<li>Set接口的遍历方式</li>
</ul>
<p>同Collection的遍历方式一样，因为Set接口是Collecton接口的子接口。</p>
<ol>
<li>可以使用迭代器</li>
<li>增强for</li>
<li><font color="C02C38">不能使用索引</font>的方式获取</li>
</ol>
<ul>
<li>Set接口的常用方法举例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetMethod_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//以Set 接口的实现子类 HashSet 来讲解Set接口的方法</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;我要买键盘&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;suit80多帅哦&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;我要买键盘&quot;</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set&quot;</span>+ set);</span><br><span class="line">        <span class="comment">//可以得出结论，添加的顺序和取出的顺序并不一样，但是取出的顺序是一致，就只是和添加的顺序不同，不允许重复的元素</span></span><br><span class="line">        <span class="comment">//可以添加null，只能有一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//方式1：使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========迭代器遍历=========&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2：增强for (底层就是迭代器)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========增强for========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传统for循环set接口没有提供get方法，即不能通过索引来获取</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除remove</span></span><br><span class="line">        set.remove(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet全面说明"><a href="#HashSet全面说明" class="headerlink" title="HashSet全面说明"></a><font color="#5cb85c">HashSet全面说明</font></h3><ol>
<li>HashSet实现了Set接口</li>
<li>HashSet实际上是HashMap，看下源码。<br><img src="/images/image-20220814205608084.png" alt="image-20220814205608084"></li>
<li>可以存放null值，但是只能有一个null</li>
<li>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果</li>
<li>不能有重复元素&#x2F;对象，在前面Set接口使用已经讲过。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//HashSet构造器走的是HashMap</span></span><br><span class="line"><span class="comment">//        /**</span></span><br><span class="line"><span class="comment">//         * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">//         * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">//         */</span></span><br><span class="line"><span class="comment">//    public HashSet() &#123;</span></span><br><span class="line"><span class="comment">//            map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">Set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//多态写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">案例01</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet01_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//add()方法后，会返回一个boolean值 添加成功就返回true，否则返回false</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;john&quot;</span>));<span class="comment">//T</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;john&quot;</span>));<span class="comment">//T</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;john&quot;</span>));<span class="comment">//F</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;mary&quot;</span>));<span class="comment">//T</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;mary&quot;</span>));<span class="comment">//F</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="literal">null</span>));<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以通过remove指定删除某个对象</span></span><br><span class="line">        hashSet.remove(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;HashSet&quot;</span> + hashSet);</span><br><span class="line">        hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">// 这个hashSet为空哦</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Dog_</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Dog_</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        <span class="comment">//这是两个不同对象，所以两个Dog都是可以的</span></span><br><span class="line">        <span class="comment">//new相当于初始化，一个哦</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//经典面试题目，</span></span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;sb&quot;</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;sb&quot;</span>));<span class="comment">//这里加入不了</span></span><br><span class="line">        <span class="comment">//需要看源码</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog_</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog_</span> <span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog_&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">注意</mark> ：

<p>上述结论涉及到add()方法底层原理，但是抛开问题，new是会新创建一个对象的，对象的概念要理解。</p>
<ul>
<li>HashSet底层机制说明</li>
</ul>
<p>分析HashSet底层是HashMap，HashMap底层是(数组+链表+红黑树)</p>
<p><img src="/images/image-20220814212018115.png" alt="image-20220814212018115"></p>
 <mark class="hl-label blue">模拟链表</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetStructure</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、创建一个数组,数组的类型是Node[]</span></span><br><span class="line">        <span class="comment">//2、有些人，直接把Node[] 数组称为表</span></span><br><span class="line">        Node[] table = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、创建结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;John&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        table[<span class="number">2</span>] = john;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Jack&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        john.next = jack; <span class="comment">//将jack 结点挂载到John后</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">rose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Rose&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        jack.next = rose; <span class="comment">//将rose结点挂在到jack后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;table&quot;</span> + table);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;<span class="comment">//结点，存储数据，可以指向下一个node，从而形成链表</span></span><br><span class="line">    Object item;  <span class="comment">//存放数据</span></span><br><span class="line">    Node next;    <span class="comment">//指向下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">结果</mark> 

<p><img src="/images/hashmap.png" alt="hashmap"></p>
<h3 id="HashSet扩容机制"><a href="#HashSet扩容机制" class="headerlink" title="HashSet扩容机制"></a><font color="#5cb85c">HashSet扩容机制</font></h3><ul>
<li>分析HashSet的添加元素底层是如何实现(hash()+equals())</li>
</ul>
 <mark class="hl-label blue">结论</mark> ：

<p><img src="/images/image-20220815145848519.png" alt="image-20220815145848519"></p>
<h3 id="HashSet源码解读"><a href="#HashSet源码解读" class="headerlink" title="HashSet源码解读"></a><font color="#5cb85c">HashSet源码解读</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;php&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        构造器源码</span></span><br><span class="line"><span class="comment">        * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">        * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public HashSet() &#123;</span></span><br><span class="line"><span class="comment">            map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //执行add方法</span></span><br><span class="line"><span class="comment">        public boolean add(E e) &#123;</span></span><br><span class="line"><span class="comment">        return map.put(e, PRESENT)==null;//private static final Object PRESENT = new Object();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //执行put方法，</span></span><br><span class="line"><span class="comment">        该方法会执行 hash(key) 得到key对应的hash值 是通过return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);是native方法。</span></span><br><span class="line"><span class="comment">        public V put(K key, V value) &#123;//key=&quot;java&quot; value = PRESENT 是静态的、共享的</span></span><br><span class="line"><span class="comment">        return putVal(hash(key), key, value, false, true);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //核心代码 putVal</span></span><br><span class="line"><span class="comment">        final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="comment">                   boolean evict) &#123;</span></span><br><span class="line"><span class="comment">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//定义辅助变量</span></span><br><span class="line"><span class="comment">        //table就是 hashmap的一个数组，类型是Node[],Node数组。</span></span><br><span class="line"><span class="comment">        if ((tab = table) == null || (n = tab.length) == 0)</span></span><br><span class="line"><span class="comment">        //如果当前table是null，或者大小 = 0，就是第一次扩容，到16个空间</span></span><br><span class="line"><span class="comment">            n = (tab = resize()).length;</span></span><br><span class="line"><span class="comment">        //根据key得到hash值，去计算该key应该存放到table表的哪个索引位置</span></span><br><span class="line"><span class="comment">        //并且把这个位置的对象，赋给变量p (索引)</span></span><br><span class="line"><span class="comment">        //再判断这个p是否为null</span></span><br><span class="line"><span class="comment">        //如果p为null,表示还没有存放元素，就创建一个Node(Key= 自己传入的&quot;Java&quot;,value = 内部变量 PRESENT)</span></span><br><span class="line"><span class="comment">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">            tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">        else &#123;</span></span><br><span class="line"><span class="comment">            Node&lt;K,V&gt; e; K k;</span></span><br><span class="line"><span class="comment">            if (p.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                e = p;</span></span><br><span class="line"><span class="comment">            else if (p instanceof TreeNode)</span></span><br><span class="line"><span class="comment">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="comment">            else &#123;</span></span><br><span class="line"><span class="comment">                for (int binCount = 0; ; ++binCount) &#123;</span></span><br><span class="line"><span class="comment">                    if ((e = p.next) == null) &#123;</span></span><br><span class="line"><span class="comment">                        p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span></span><br><span class="line"><span class="comment">                            treeifyBin(tab, hash);</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    if (e.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    p = e;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="comment">                V oldValue = e.value;</span></span><br><span class="line"><span class="comment">                if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="comment">                    e.value = value;</span></span><br><span class="line"><span class="comment">                afterNodeAccess(e);</span></span><br><span class="line"><span class="comment">                return oldValue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ++modCount;</span></span><br><span class="line"><span class="comment">        if (++size &gt; threshold)</span></span><br><span class="line"><span class="comment">            resize();</span></span><br><span class="line"><span class="comment">        afterNodeInsertion(evict);</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">小解析</mark> ：

<p>上面讲了如何将第一个元素添加到HashSet这个集合中去，他本质是Node[]数组的集合，首先如果集合大小为null的话，调用<code>tab = resize()</code>方法，第一次会扩容成16的大小。然后用n记录table的长度，用p记录集合索引位置是否为null，空就可以加入（p的需要一系列算法计算）。</p>
 <mark class="hl-label blue">注意</mark> ：

<p>hash值和hashcode()不一样。需要<code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code>右移16位得到hash值。右移防止哈希冲突。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a><font color="#6dc1f7">线程</font></h2><h3 id="线程相关概念"><a href="#线程相关概念" class="headerlink" title="线程相关概念"></a><font color="#5cb85c">线程相关概念</font></h3><ul>
<li><p><font color="12AA8C">程序(program)</font></p>
<p>是为完成特定任务、用某种语言编写的一组指令的集合。简单的说：就是我们写的代码。</p>
</li>
<li><p><font color="12AA8C">进程</font></p>
<ol>
<li>进程是指运行中的程序，比如我们使用QQ，启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间。</li>
<li>进程是程序的一次执行过程，或是正在运行的一个程序，是动态过程：有它自身的产生、存在和消亡的过程。</li>
</ol>
</li>
<li><p><font color="12AA8C">线程</font></p>
<ol>
<li><p>线程由进程创建的，是进程的一个实体。</p>
</li>
<li><p>一个进程可以拥有多个线程，如下图。</p>
<p><img src="/images/image-20220701121223052.png" alt="image-20220701121223052"></p>
<p>有多个同时下载内容。坦克大战[后面会把多线程加入到坦克大战中，学以致用]</p>
</li>
</ol>
</li>
<li><p><font color="12AA8C">其他相关概念</font></p>
<ol>
<li>单线程：同一个时刻，只允许执行一个线程。</li>
<li>多线程：同一个时刻，可以执行多个线程，比如：一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件。</li>
<li>并发：同一个时刻，多个任务交替执行，造成一种”貌似同时“的错觉，简单的说，单核cpu实现的多任务就是并发。</li>
<li>并行：同一个时刻，多个任务同时执行，多核cpu可以实现并行。</li>
</ol>
</li>
</ul>
<mark class="hl-label purple">案例</mark> ：

<p>Java查看计算机有一个CPU(核)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="comment">//可用处理器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">CPUNums</span> <span class="operator">=</span> runtime.availableProcessors();</span><br><span class="line">        System.out.println(CPUNums);<span class="comment">//16</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a><font color="#5cb85c">线程的基本使用</font></h3><p>在Java中线程来使用有两种方法：</p>
<ol>
<li>继承Thread类，重写run方法。</li>
<li>实现Runnable接口，重写run方法。</li>
</ol>
<p><img src="/images/image-20220701170613035.png" alt="image-20220701170613035"></p>
<mark class="hl-label purple">案例1</mark> : <font color="D2568C">继承Thread类。</font>

<ol>
<li>该线程每隔一秒钟，在控制台输出”喵喵，我是小猫咪”</li>
<li>并在输出80次后，结束该线程。</li>
<li>增加main线程内容。</li>
<li>用jconsole监控线程执行情况注意：需用管理员身份打开idea。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threaduse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建Cat对象，可以当作线程使用</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        cat.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());<span class="comment">//主线程名字为main。</span></span><br><span class="line">        <span class="comment">//说明，当main线程启动一个子线程 Thread-0，主线程main不会阻塞，会继续执行。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程输出&quot;</span>+i);</span><br><span class="line">            <span class="comment">//主线程休眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//单位ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//重写run()方法，实现自己的业务逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//输出&quot;喵喵&quot; 和当前线程名字(currentThread)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;喵喵,我是小猫咪&quot;</span>+ (++times)+ Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//休眠1秒种。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">//单位ms</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">80</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//当8次退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="D2568C">线程示意图：</font></p>
<p><img src="/images/image-20220702132905125.png" alt="image-20220702132905125"></p>
<mark class="hl-label red">小结</mark> ：

<p>主线程结束，进程不一定结束，如有其他子线程在执行。</p>
<ol>
<li>当一个类继承Thread类，就可以当作线程使用</li>
<li>我们会重写run方法，写上自己的业务代码</li>
<li>run Thread 类，实现了Runnable 接口的run方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread里面的run();</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么是Start"><a href="#为什么是Start" class="headerlink" title="为什么是Start();"></a><font color="#5cb85c">为什么是Start();</font></h3><p>如上所示，如果调用<code>run();</code>方法，会和普通方法调用一样。不会开额外的线程，会等他执行完也就是阻塞。而<code>start();</code>方法是调用底层native方法<code>start0();</code>。start0()是本地方法，是JVM调用，底层是c&#x2F;c++实现。真正实现多线程的效果，是start0(),而不是run。<code>private native void start0();</code></p>
<p><img src="/images/image-20220702154036038.png" alt="image-20220702154036038"></p>
<mark class="hl-label purple">案例2</mark> : <font color="D2568C">实现Runnable接口</font>

<p>说明：</p>
<ol>
<li>Java是单继承的，在某个情况下一个类可能已经继承了某个父类，这时在用继承Thread类方法来创建线程显然不可能了。</li>
<li>Java设计者们提供了另外一个方式创建线程，就是通过实现Runnable接口来创建线程。</li>
</ol>
<p>该案例可以每个一秒钟，在控制台输出”hi！”，当输出10次后，自动退出。请使用实现Runnable接口的方式实现。这里是<font color="FF9900">静态代理。</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    继承Runnable接口实现多线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threaduse2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dog);<span class="comment">//Thread提供的构造器</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadProxy</span> <span class="variable">threadProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadProxy</span>(dog);</span><br><span class="line">        threadProxy.start();<span class="comment">//本质调用Runnable类重写过后的run方法,并没有启用多线程start0();</span></span><br><span class="line">        <span class="comment">//其实不用代理也一样的,ThreadProxy 就是将thread类源码极简的模拟了一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi&quot;</span>+(++times)+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">//单位ms.</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程代理,模拟了极简的线程代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadProxy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//ThreadProxy可以当作Thread类的代理(都是继承Runnable)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//属性, 类型是Runnable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();  <span class="comment">//Runnable里面的run();方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadProxy</span> <span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ThreadProxy继承了Runnable,可以当作类似的Thread的代理.这里模拟最简的Thread.</span></span><br><span class="line">    <span class="comment">//下面这些,可以说是为了同继承Thread接口启用多线程方法相同,所做出的举动</span></span><br><span class="line">    <span class="comment">//如Dog dog = new dog(); dog.start;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        start0(); <span class="comment">//这个方法是真正实现多线程的(模拟)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span> &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> :

<p>静态代理只是用自己写的一个类模拟Thread类，上面展示的是极简的。并没有真正调用<font color="EEA2A4">native 方法 </font><code>start0();</code> 。所以还是<font color="EEA2A4">main线程</font>。代理：最后结果还是自己做。第一个没有用代理，直接用Thread的会<font color="EEA2A4">新开一个线程</font>。</p>
<mark class="hl-label purple">案例3</mark> :<font color="D2568C">多线程执行</font>

<p>创建两个线程，一个线程每隔一秒输出”hello,world”,输出10次后，退出，一个线程每个一秒输出”hi”，输出5次后退出。</p>
<mark class="hl-label red">注意</mark> : 都是通过<font color="C06F98">实现Runnable接口。</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多线程执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threaduse3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();</span><br><span class="line">        <span class="type">teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">teacher</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(student);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(teacher);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">extends</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>+(++times)+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span> <span class="keyword">extends</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi&quot;</span> + (++times)+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">小结</mark> :

<p>实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	共享资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">T3</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T3</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t3);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t3);</span><br></pre></td></tr></table></figure>

<p>如采用继承方式，则需要new两个对象，资源浪费。</p>
<h3 id="多线程售票系统"><a href="#多线程售票系统" class="headerlink" title="多线程售票系统"></a><font color="#5cb85c">多线程售票系统</font></h3><p>模拟三个售票窗口，分别使用继承Thread和实现Runnable方式。</p>
<mark class="hl-label orange">方式1</mark> : <font color="C06F98">继承Thread。</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 售票系统 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//继承Thread方法</span></span><br><span class="line">        <span class="type">windows1</span> <span class="variable">windows1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows1</span>();</span><br><span class="line">        <span class="type">windows1</span> <span class="variable">windows11</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows1</span>();</span><br><span class="line">        <span class="type">windows1</span> <span class="variable">windows12</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows1</span>();</span><br><span class="line">        windows1.start();</span><br><span class="line">        windows11.start();</span><br><span class="line">        windows12.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">windows1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;窗口1已售完&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;卖出一张票&quot;</span>+<span class="string">&quot;剩余&quot;</span>+(--tickets)+Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能会出现超卖现象，因为三个线程同时工作，如果最后只剩两张票的时候，第一个线程判断符合<font color="C06F98">不小于0</font>的条件，但是期间存在休眠。当还未减去票数的时候，另外两个线程会把表数当作2处理。那么就会出现多卖的情况。</p>
<mark class="hl-label orange">方式2</mark> : <font color="C06F98">实现Runnable接口。</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 售票系统 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实现Runnable接口</span></span><br><span class="line">		<span class="type">windows2</span> <span class="variable">windows2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows2</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows2);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">windows2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;窗口2已售完&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;卖出一张票&quot;</span>+<span class="string">&quot;剩余&quot;</span>+(--tickets)+Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是实现Runnable接口的方法，本质上和继承Thread类一样，所以也可能会出现多卖的情况。和<code>sleep</code>时长有关。</p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a><font color="#5cb85c">线程终止</font></h3><mark class="hl-label orange">基本说明</mark> : 

<ol>
<li>当线程完成任务后，会自动退出。</li>
<li>还可以通过使用变量<font color="EE4866">控制run方法</font>退出的方法停止线程，即通知方法。</li>
</ol>
<mark class="hl-label red">案例</mark> : 启动一个线程t,要求在main线程中去停止线程t。<font color="EE4866">通知方法</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 线程终止 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">t</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">t</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        t.setLoop(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">t</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//设置一个控制变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;你妈隔壁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//想当于main程序控制线程的一个接口.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a><font color="#5cb85c">线程中断</font></h3><ul>
<li>常用方法第一组</li>
</ul>
<ol>
<li>setName : 设置线程名称，使之与参数name相同。</li>
<li>getName：返回该线程的名称。</li>
<li>start ：使该线程开始执行；Java虚拟机底层调用该线程的start0方法。</li>
<li>run : 调用该线程对象run方法。</li>
<li>setPriority : 更改线程的优先级。</li>
<li>getPriority：获取线程的优先级。</li>
<li>sleep：在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)。</li>
<li>interrupt：中断线程。</li>
</ol>
<mark class="hl-label red">注意</mark> :

<ol>
<li>start底层会创建新的线程，调用run，run就是一个简单的方法调用，不会启动新的线程</li>
<li>线程优先级的范围。</li>
<li>interrupt，中断线程，但并没有真正的结束线程。所以一般用于中断正在休眠线程</li>
<li>sleep：线程的<font color="EC8AA4">静态方法</font>，是当前线程休眠。</li>
</ol>
<mark class="hl-label red">方法案例</mark> : 各种ThreadMethod的使用方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">T1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>();</span><br><span class="line">    t.start();</span><br><span class="line">    t.setName(<span class="string">&quot;李文涛&quot;</span>);</span><br><span class="line">    t.setPriority(Thread.MIN_PRIORITY); <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="comment">//主线程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;吊毛&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;你在干什么&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;休眠中&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//当该线程执行到一个interrupt方法时，就会catch一个异常，可以加入自己的业务代码</span></span><br><span class="line">                <span class="comment">//interruptedException 是捕获到一个中断异常。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;休眠被打断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常用方法第二组</li>
</ul>
<ol>
<li><font color="C45A65">yield(静态方法)</font>：线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也<font color="C45A65">不一定礼让成功</font>。</li>
<li>join: 线程的插队。插队的线程一旦成功，则肯定先执行完插入的线程<font color="C45A65">所有的任务</font>。</li>
</ol>
<p><img src="/images/image-20220706123621448.png" alt="image-20220706123621448"></p>
<mark class="hl-label orange">案例</mark> :

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethod02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T4</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T4</span>();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;吃&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                t4.join(); <span class="comment">//让t4的线程先执行完，后继续执行main线程</span></span><br><span class="line">                Thread.yield(); <span class="comment">//静态方法使用类名.方法调用。这个方法礼让不一定成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T4</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;吃包子&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//1秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>对象.join();</code>方法的时候。对象是’’大哥’’。会先执行完，这个对象的线程内容后，继续执行本线程的内容。</p>
<mark class="hl-label purple">练习</mark> :

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    线程方法的练习</span></span><br><span class="line"><span class="comment">    主线程每隔一秒钟，输出hi，共10次</span></span><br><span class="line"><span class="comment">    当主线程执行到第五次的时候，启功子线程（要求是实现接口Runnable的），每个一秒钟输出hello共10次</span></span><br><span class="line"><span class="comment">    然后继续执行主线程。完成后退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethodExercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        T5 t5 = new T5();</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(t5);</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">T5</span>());  <span class="comment">//Thread 构造器传入Runnable对象</span></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;hi&quot;</span>+ i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">                t5.start(); <span class="comment">//启动子线程</span></span><br><span class="line">                t5.join();  <span class="comment">//子线程“插队”</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T5</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;hello&quot;</span>+ i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> : 

<p>实现Runnable接口时候，多线程启动的原理。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a><font color="#5cb85c">守护线程</font></h3><ul>
<li>用户线程和守护线程</li>
</ul>
<ol>
<li>用户线程：也叫工作线程，当线程的任务执行完或通知方式结束。</li>
<li>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束</li>
<li>常见的守护线程：垃圾回收机制。</li>
</ol>
<mark class="hl-label red">应用案例</mark> : 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethod03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">MyDaemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyDaemonThread</span>());</span><br><span class="line">        MyDaemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        MyDaemonThread.start();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;wuhu&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDaemonThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你麻痹&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;whu&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>守护线程： 理解为他是守护别的线程的，当别的线程全部结束后，也就不需要它的守护了，他也就自动结束了。可以用于监控其他线程，获取其他线程的信息。</p>
<h3 id="线程七大状态"><a href="#线程七大状态" class="headerlink" title="线程七大状态"></a><font color="#5cb85c">线程七大状态</font></h3><p><img src="/images/image-20220706170124615.png" alt="image-20220706170124615"></p>
<p><img src="/images/image-20220706170054622.png" alt="image-20220706170054622"></p>
<mark class="hl-label red">注意</mark> : 

<p>官方文档是6个状态，Runnable可以细分为两个状态，都是内核控制，图中yeild方法虽然将它从Runnable状态变成Ready状态，但是线程调度还是由内核控制，所以礼让不一定成功。图上有个单词打错了，Teminated，应该是Terminated。 </p>
<mark class="hl-label red">案例</mark> : 

<p>获取线程状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">T</span>());</span><br><span class="line">        System.out.println(t.getName()+<span class="string">&quot;状态&quot;</span>+t.getState()); <span class="comment">//获取线程当前的状态</span></span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(t.getName()+<span class="string">&quot;状态&quot;</span>+t.getState());</span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.State.TERMINATED != t.getState()) &#123; <span class="comment">//意思是当前线程状态不是等于终止(TERMINATED)状态</span></span><br><span class="line">            System.out.println(t.getName()+ <span class="string">&quot;状态&quot;</span>+ t.getState());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.getName()+<span class="string">&quot;状态&quot;</span>+t.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;wuhu&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">部分结果</mark> : 

<p><img src="/images/image-20220706174300267.png" alt="image-20220706174300267"></p>
<p>只能获取部分状态，有些是底层内核的，不易获取。</p>
<h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a><font color="#5cb85c">线程同步机制</font></h3><ol>
<li>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。</li>
<li>也可以这里理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该地址内存进行操作。</li>
</ol>
<ul>
<li>同步具体方法</li>
</ul>
<ol>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123; <span class="comment">//得到对象的锁，才能操作同步代码</span></span><br><span class="line">    <span class="comment">//需要被同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>synchronized还可以放在方法声明中，表示整个方法-为同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span> <span class="params">(String name)</span>&#123;  <span class="comment">//此时m方法已经是同步方法</span></span><br><span class="line">	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如何理解<br>就好像某个小伙伴上厕所前先把门关上(上锁)，完事后再出来(解锁)，那么其他小伙伴就可在使用厕所了。</p>
</li>
<li><p>使用synchronized 解决前面售票问题。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现接口方法，使用synchronized实现线程同步</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">windows3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已售完&quot;</span>);</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;卖出一张票&quot;</span>+<span class="string">&quot;剩余&quot;</span>+(--tickets)+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//同步方法，在同一个时刻只能有一个线程来执行run方法。</span></span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            sell();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">小结</mark> : 这是使用在方法声明中加入synchronized。

<blockquote>
<ol>
<li>public synchronized void sell() {} 就是一个同步方法</li>
<li>这时锁在this对象</li>
<li>也可以在代码块上写synchronize， 同步代码块，互斥锁还是在this对象</li>
</ol>
</blockquote>
<ul>
<li>同步原理分析。</li>
</ul>
<p><img src="/images/image-20220707213146945.png" alt="image-20220707213146945"></p>
<p>锁是在<font color="EEA2A4">对象</font>上的，然后t1，t2，t3三个线程去抢夺这个锁。然后完成相应方法。再将锁还回去，下次抢的时候还是三个人一起抢，不是<font color="EEA2A4">公平锁</font>。这个锁可以配合前面<font color="#5cb85c">线程七大状态</font>图理解，就是<font color="C02C38">Blocked状态</font>，翻译过来就是<font color="EEA2A4">锁</font>。</p>
<p><img src="/images/image-20220709205225117.png" alt="image-20220709205225117"></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><font color="#5cb85c">互斥锁</font></h3><ol>
<li>在Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。</li>
<li>每个对象都对应于一个可称为”互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</li>
<li>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问</li>
<li>同步的局限性：导致程序的执行效率要降低</li>
<li>同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象) （加在当前对象）</li>
<li>同步方法(静态的)的锁为当前类本身。(加在当前类)</li>
</ol>
<mark class="hl-label blue">代码块形式</mark> : 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">windows4</span> <span class="variable">windows4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows4</span>();</span><br><span class="line"><span class="comment">//        windows4 windows41 = new windows4();</span></span><br><span class="line"><span class="comment">//       windows4 windows42 = new windows4();</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows4);</span><br><span class="line">    	<span class="type">Thread</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows4);</span><br><span class="line">   	    <span class="type">Thread</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows4);</span><br><span class="line"><span class="comment">//        Thread s2 = new Thread(windows42);</span></span><br><span class="line"><span class="comment">//        Thread s3 = new Thread(windows41);</span></span><br><span class="line">        s1.start();</span><br><span class="line">        s2.start();</span><br><span class="line">        s3.start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="comment">/*this*/</span>object) &#123;  <span class="comment">//代码块形式</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已售完&quot;</span>);</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;卖出一张票&quot;</span> + <span class="string">&quot;剩余&quot;</span> + (--tickets) + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">小结</mark> : 

<p>synchronized(对象)。这里object 和this作用一样，都是锁当前对象。在main测试中(看上文)，共用一个对象<code>windows4 windows4 = new windows4();</code>,如果用多个对象<code>windows4 windows41 = new windows4();</code>锁就会失效。将<code>synchronized(对象)</code>里面对象换用<code>windows4.class</code>对这个类进行锁。</p>
<mark class="hl-label red">注意</mark> : 

<blockquote>
<p><code>sleep();</code>最好放在<font color="C02C38">锁外面</font>，这样可以给别的线程机会。不然可能由于底层CPU调度导致只有一个线程运行。也符合逻辑，休眠的时候不应该占用锁。</p>
<p>同步代码块中不能有死循环，会导致一个线程进去后就一直运作，占用锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (money &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                money -= <span class="number">1000</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;剩余&quot;</span> + money);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">静态方法</mark> : 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法为静态的时候 锁为当前本身类。</span></span><br><span class="line"><span class="comment">//public synchronized static void m1() &#123;&#125; 锁是加在windows4.class</span></span><br><span class="line"><span class="comment">//如果静态方法中，实现一个代码块，需用windows.class 获取类，在加类上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//静态方法上加锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (windows4.class) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">小结</mark> : 

<p>如果使用代码块形式，<code>synchronized(对象)</code>里面的对象，相当于它的作用范围。加在方法前面的声明则要求较少。</p>
<mark class="hl-label red">注意事项</mark> : 

<blockquote>
<ol>
<li><p>同步方法如果没有使用static修饰：默认锁对象为this</p>
</li>
<li><p>如果方法使用static修饰，默认锁对象：当前类.class，static肯定要被多次调用，用类.class可以锁多个对象。</p>
</li>
<li><p>实现的落地步骤：</p>
<p>需要先分析上锁的代码</p>
<p>选择同步代码块或同步方法</p>
<p>要求多个线程的锁对象为同一个即可!</p>
</li>
</ol>
<p>	</p>
</blockquote>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a><font color="#5cb85c">线程死锁</font></h3><ul>
<li>基本介绍</li>
</ul>
<p>​	多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生。</p>
<mark class="hl-label blue">案例</mark> : 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 死锁 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">sisuo</span>(<span class="literal">true</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">sisuo</span>(<span class="literal">false</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sisuo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">//保证多线程，共享一个对象，这里使用static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> loop;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">sisuo</span> <span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (loop) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入1&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入3&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入4&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">存疑</mark> :

<p><code>Object object = new Object();</code>的原理。</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a><font color="#5cb85c">释放锁</font></h3><ul>
<li>下面操作会释放锁。</li>
</ul>
<ol>
<li>当前线程的同步方法、同步代码执行结束<br>案例：上厕所、完事出来</li>
<li>当前线程在同步代码块、同步方法中遇到break、return<br>案例：没有正常的完事，经理叫他修改bug，不得已出来</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束<br>案例：没有正常完成的完事，发现忘带纸，不得已出来</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁<br>案例：没有正常完事，觉得需要酝酿下，所以出来等会再进去。</li>
</ol>
<ul>
<li>下面操作不会释放锁</li>
</ul>
<ol>
<li>线程执行同步代码块或同步方法时，程序调用<code>Thread.sleep()</code>、<code>Thread.yield()</code>方法暂停当前线程的执行，不会释放锁<br>案例：上厕所，太困了，在坑位上眯了一会。</li>
<li>线程执行同步代码块时，其他线程调用了该线程的<code>suspend()</code>方法将该线程挂起，该线程不会释放锁。<br>提示：应尽量避免使用<code>suspend()</code>和<code>resume()</code>来控制线程，方法不再推荐使用</li>
</ol>
<h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a><font color="#6dc1f7">I&#x2F;O流</font></h2><p><img src="/images/image-20220722115624344.png" alt="image-20220722115624344"></p>
<h3 id="文件基础知识"><a href="#文件基础知识" class="headerlink" title="文件基础知识"></a><font color="#5cb85c">文件基础知识</font></h3><ul>
<li>什么是文件</li>
</ul>
<p>​		文件，是<font color="#0F59A4">保存数据的地方</font>，比如word文档，txt文件·····</p>
<ul>
<li>文件流</li>
</ul>
<p>​		文件在程序中是以流的形式来操作的</p>
<p>​		流：数组在数据源(文件)和程序(内存)之间经历的路径</p>
<p>​		输入流：数据从数据源(文件)到程序(内存)的路径</p>
<p>​		输入流：数据从程序(内存)到数据源(文件)的路径</p>
<p><img src="/images/image-20220722120916773.png" alt="image-20220722120916773"></p>
<h3 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a><font color="#5cb85c">常用的文件操作</font></h3><ul>
<li>创建文件对象相关构造器和方法</li>
</ul>
<p>​	new File(String pathname) &#x2F;&#x2F;根据路径构建一个File对象</p>
<p>​	new File(File parent , String child) &#x2F;&#x2F;根据父目录文件 + 子路径构建</p>
<p>​	new File(String parent, String child) &#x2F;&#x2F;根据父目录+子路径构建 </p>
<p>​	createNewFile 创建新文件</p>
<mark class="hl-label red">类图</mark> :

<p><img src="/images/image-20220722123911907.png" alt="image-20220722123911907"></p>
<mark class="hl-label purple">代码</mark> :

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jth.javaee.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示文件创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCreate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Create1();</span><br><span class="line">        Create2();</span><br><span class="line">        create3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一：new File(String pathname) //根据路径构建一个File对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Create1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/text01.txt&quot;</span>; <span class="comment">//文件路径  /也可以用两个\\转义</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile(); <span class="comment">//调用方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二 ：new File(File parent , String child) //根据父目录文件 + 子路径构建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Create2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parent</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentfile, <span class="string">&quot;text02.txt&quot;</span>);<span class="comment">//在jvm内存里面有对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile(); <span class="comment">//这个才是实现文件创建的方法/步骤 //在磁盘里面执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式三： new File(String parent, String child) //根据父目录+子路径构建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>, <span class="string">&quot;text03.txt&quot;</span>).createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取文件相关信息</li>
</ul>
<p>​	一些常用方法：</p>
<p>​	getName 获取文件名</p>
<p>​    getAbsolutePath 获取绝对路径</p>
<p>​	getParent  获取文件父目录</p>
<p>​	length 获取文件大小(字节计算)</p>
<p>​	exists 判断是否存在</p>
<p>​	isFile 判断是否是一个文件</p>
<p>​	isDirectory 判断是否是一个目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fileinformation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        getinformation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getinformation</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/text03.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="comment">//file.createNewFile();</span></span><br><span class="line">        System.out.println(file.getName());<span class="comment">//获取文件名</span></span><br><span class="line">        System.out.println(file.getAbsolutePath());<span class="comment">//绝对路径</span></span><br><span class="line">        System.out.println(file.canRead());<span class="comment">//true</span></span><br><span class="line">        System.out.println(file.exists());<span class="comment">//true</span></span><br><span class="line">        System.out.println(file.isFile());<span class="comment">//true</span></span><br><span class="line">        System.out.println(file.getParent());<span class="comment">//D:\</span></span><br><span class="line">        System.out.println(file.length());<span class="comment">//35 编码不同，字节长度不同，这个长度是计算字节长度</span></span><br><span class="line">        System.out.println(file.isDirectory());<span class="comment">//是否是目录 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> :

<p>这里不用没有创建文件<code>createFile</code>就可以调用下面方法，进一步说明，产生文件是由file的createFile方法实现，这里没有创建是以前创建好了，就是上次创建的text03.txt如果这个路径中没有这个文件，那么就有<code>exists()</code>这个方法存在的意义了，返回false。比如将路径改成<code>D:/text04.txt</code>。</p>
<p>还需注意的是编码方式不同，<code>length</code>返回的长度也不同，这里txt文件使用的UTF-8。一个英文字母、数字或英文标点一个字节，一个汉字或汉字标点占三个字节。</p>
<ul>
<li>目录操作</li>
</ul>
<p>​	mkdir创建一级目录，mkdirs创建多级目录、delete删除空目录或文件。</p>
<mark class="hl-label blue">代码</mark> :

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示目录创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MakeDirectory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        m1();</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/text01.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.delete()) &#123;<span class="comment">//delete方法删除 ，并且会返回一个boolean值</span></span><br><span class="line">                System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建目录，目录其实就是相当于文件夹多个嵌套</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">directorypath</span> <span class="operator">=</span> <span class="string">&quot;D:/directory&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(directorypath);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目录存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.mkdirs()) &#123;<span class="comment">//这个是创建多级目录的方法不能使用mkdir()方法创建多级目录</span></span><br><span class="line">                System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO流原理和分类"><a href="#IO流原理和分类" class="headerlink" title="IO流原理和分类"></a><font color="#5cb85c">IO流原理和分类</font></h3><ul>
<li>Java IO流原理</li>
</ul>
<ol>
<li>I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术是非常实用的技术，用于处理数据传输。<br>如读&#x2F;写文件，网络通讯等。</li>
<li>Java程序中，对于数据的输入&#x2F;输出操作以”流(stream)”的方式进行。</li>
<li>Java.io包下提供了各种”流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据。</li>
<li>输入input：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中。</li>
<li>输出output：将程序(内存)数据输出到磁盘、光盘等存储设备中。</li>
</ol>
<p><img src="/images/image-20220726144159722.png" alt="image-20220726144159722"></p>
<ul>
<li>流的分类</li>
</ul>
<p>​		按操作数据单位不同分为：字节流(8 bit) 二进制文件，字符流(按字符，编码不同大小不同)文本文件</p>
<p>​		按数据流的流向不同分为：输入流，输出流</p>
<p>​		按流的角色的不同分为：节点流，处理流&#x2F;包装流</p>
<p><img src="/images/image-20220726144544013.png" alt="image-20220726144544013"></p>
<ol>
<li>Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的。</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</li>
</ol>
<p><img src="/images/image-20220726145227421.png" alt="image-20220726145227421"></p>
<p><img src="/images/image-20220726145649356.png" alt="image-20220726145649356"></p>
<h3 id="IO流体系图-常用的类"><a href="#IO流体系图-常用的类" class="headerlink" title="IO流体系图-常用的类"></a><font color="#5cb85c">IO流体系图-常用的类</font></h3><ul>
<li>InputStream:字节输入流</li>
</ul>
<p>​		InputStream抽象类是所有类字节输入流的超类</p>
<p>​		InputStream常用的子类</p>
<ol>
<li>FileInputStream: 文件输入流</li>
<li>BufferedInputStream: 缓冲字节输入流</li>
<li>ObjectInputStream: 对象字节输入流</li>
</ol>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a><font color="#ffd253">FileInputStream</font></h4><p><img src="/images/image-20220726153210658.png" alt="image-20220726153210658"></p>
<p><img src="/images/image-20220726153119741.png" alt="image-20220726153119741"></p>
<mark class="hl-label blue">应用案例</mark> :

<p>要求：请使用FileInputStream 读取 hello.txt 文件，并将文件内容显示到控制台。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    要求：请使用FileInputStream 读取 hello.txt 文件，并将文件内容显示到控制台。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        readFile01();</span><br><span class="line">        readFile02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用read();</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:/hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//扩大作用域</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建FileInputStream对象，用于读取文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="comment">//从该输入流读取一个字节的数据，如果没有输入可用，此方法将阻止</span></span><br><span class="line">            <span class="comment">//如果返回-1，表示读取完毕</span></span><br><span class="line">            <span class="keyword">while</span> ((readData = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)readData);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;打开成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭文件流，释放资源</span></span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用read(byte[] b)方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile02</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:/hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];<span class="comment">//一次可以一次读取8个字节</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//扩大作用域</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建FileInputStream对象，用于读取文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="comment">//将字符读入数组。此方法将阻塞，直到某些输入可用、发生 I/O 错误或到达流的末尾。</span></span><br><span class="line">            <span class="comment">//如果返回-1，表示读取完毕</span></span><br><span class="line">            <span class="comment">//如果读取正常，返回实际读取的字节数</span></span><br><span class="line">            <span class="keyword">while</span> ((readlen = fileInputStream.read(buf))!= -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span> , readlen));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;打开成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭文件流，释放资源</span></span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> :

<p>方式一：<code>read()</code>方法返回读取到的字节值。</p>
<p>方式二：<code>read(byte[] b)</code>方法返回读取到的char数组长度</p>
<p>文件<code>read</code>完后需要<code>close</code>释放资源。</p>
<mark class="hl-label blue">Debug</mark> :

<p>hello.txt文件只有hello内容。所以第一次readlen长度为5。</p>
<p><img src="/images/image-20220726190829285.png" alt="image-20220726190829285"></p>
<p><img src="/images/image-20220726191142742.png" alt="image-20220726191142742"></p>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a><font color="#ffd253">FileOutputStream</font></h4><p><img src="/images/image-20220726192511879.png" alt="image-20220726192511879"></p>
<p><img src="/images/image-20220726192547131.png" alt="image-20220726192547131"></p>
<mark class="hl-label blue">应用实例</mark> :

<p>要求：请使用FileOutputStream 在 a.txt文件中写入 “hello,world”如果不存在则它自己会创建文件。(注意：前提是目录必须正确)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileWrite01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">FileWrite01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/a.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到fileOutputStream对象</span></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filepath);</span><br><span class="line">            fileOutputStream.write(<span class="string">&#x27;H&#x27;</span>);<span class="comment">//写入单个字节</span></span><br><span class="line">            fileOutputStream.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;);<span class="comment">//写入多个字符</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">            fileOutputStream.write(b.getBytes(StandardCharsets.UTF_8));<span class="comment">//可以把字符串 -&gt; 字节数组</span></span><br><span class="line">            fileOutputStream.write(b.getBytes(StandardCharsets.UTF_8), <span class="number">0</span>, b.length());<span class="comment">//write(byte[] b, int off, int len) 将len字节从位于偏移量 off的指定字节数组写入此文件输出流</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">解释</mark> :

<p>上面展示了三种方法，其中<code>b.getBytes()</code>是String中的一种方法，括号中可以填写编码方法。上面使用UTF-8.</p>
<p>上面这种创建方式，多次运行是覆盖方式，当写入内容时，会覆盖原来的内容。</p>
<p>当构造器<code>FileOutputStream()</code>添加一个参数<code>append</code>为true，则写入内容为追加方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filepath, <span class="literal">true</span>);<span class="comment">//写入为追加方式</span></span><br></pre></td></tr></table></figure>

<h3 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a><font color="#5cb85c">文件的拷贝</font></h3><mark class="hl-label blue">案例</mark> :

<p>要求:编程完成图片&#x2F;音乐的拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fuzi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//图片地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/java图片/Colleciton.png&quot;</span>;</span><br><span class="line">    <span class="comment">//要复制到的地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">goalpath</span> <span class="operator">=</span> <span class="string">&quot;D:/Collection.png&quot;</span>; <span class="comment">//这里是目标路径，文件名可以改，write动作只需路径目录，没有文件它自己可以创建也符合复制的操作</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span> []b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filepath);</span><br><span class="line">        outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(goalpath);</span><br><span class="line">        <span class="keyword">while</span> ((readlen = inputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            outputStream.write(b, <span class="number">0</span>, readlen);  <span class="comment">//一定要用这个方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> :

<p><code>write</code>方法一定要用<code>b,0,readlen</code>因为如果文件大小不是数组大小的倍速，由于原理是不会清空数组再装填，所有会有一些数据重复。所以使用这个方法就能避免重复。</p>
<h3 id="文件字符流说明"><a href="#文件字符流说明" class="headerlink" title="文件字符流说明"></a><font color="#5cb85c">文件字符流说明</font></h3><ul>
<li>FileReader和FileWriter介绍</li>
</ul>
<p>​	FileReader和FileWriter是字符流，即按照字符来操作io</p>
<p><img src="/images/image-20220727153219146.png" alt="image-20220727153219146"></p>
<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a><font color="#ffd253">FileReader</font></h4><ul>
<li>FileReader相关方法：</li>
</ul>
<ol>
<li>new FileReader(File&#x2F;String)</li>
<li>read:每次读取单个字符，返回该字符，如果到文件末尾返回-1；</li>
<li>read(char[]): 批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li>
</ol>
<p>​	相关API：</p>
<ol>
<li>new String(char[]):将char[]转换成String；</li>
<li>new String(char[], off, len):将char[]的指定部分转换成String。</li>
</ol>
<p><img src="/images/image-20220727154800323.png" alt="image-20220727154800323"></p>
<mark class="hl-label blue">案例</mark> :

<p>使用FileReader从story.txt读取内容，并显示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filereader_1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">txtpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/story.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(txtpath);</span><br><span class="line">        <span class="comment">//读取单个字节</span></span><br><span class="line">        <span class="keyword">while</span> ((readData = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)readData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照单个字符</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(fileReader.read(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(fileReader.read(buf, 0, buf.length));</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filereader_2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">txtpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/story.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(txtpath);</span><br><span class="line">        <span class="comment">//按照单个字符</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filereader_3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">txtpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/story.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(txtpath);</span><br><span class="line">        <span class="comment">//按照单个字符</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">小结</mark> :

<p>总体用法和以前的<code>FileinputStream</code>差不多，一个是字节输入，这个是字符输入。</p>
<p>注意一下String相关API的调用。</p>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a><font color="#ffd253">FileWriter</font></h4><ul>
<li>FileWriter常用方法</li>
</ul>
<p><img src="/images/image-20220727153917844.png" alt="image-20220727153917844"></p>
<ol>
<li>new FileWriter(File&#x2F;String): 覆盖模式。相当于流的指针在首端</li>
<li>new FileWriter(File&#x2F;String,true): 追加模式，相当于流的指针在末端</li>
<li>write(int):写入单个字符</li>
<li>write(char[]):写入指定数组</li>
<li>write(char[], off,len): 写入指定数组的指定部分</li>
<li>write(string): 写入整个字符串</li>
<li>write(string , off ,len )写入字符串的指定部分</li>
</ol>
<p>相关API：String类： toCharArray:将String转换成char[]</p>
<mark class="hl-label red">注意</mark> :

<p>FileWriter使用后，必须使用关闭close或者刷新flush，否则文件无法写入</p>
<p><img src="/images/image-20220727154524642.png" alt="image-20220727154524642"></p>
<mark class="hl-label blue">案例</mark> :

<p>使用FileWriter将”风雨之后，定见彩虹”，写入到note.txt文件中，注意细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">FileWriter_1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">txtpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/note.txt&quot;</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;在&#x27;</span>,<span class="string">&#x27;干&#x27;</span>,<span class="string">&#x27;什&#x27;</span>,<span class="string">&#x27;么&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">buf1</span> <span class="operator">=</span> <span class="string">&quot;吊毛&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(txtpath); <span class="comment">//默认是覆盖模式</span></span><br><span class="line">        <span class="comment">//fileWriter = new FileWriter(txtpath, true) true参数表示的是追加模式</span></span><br><span class="line">        <span class="comment">//使用单字符写</span></span><br><span class="line">        fileWriter.write(<span class="string">&#x27;你&#x27;</span>);</span><br><span class="line">        fileWriter.write(buf);</span><br><span class="line">        fileWriter.write(buf, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//注意第二个参数是位置索引，第三个参数是长度len</span></span><br><span class="line">        fileWriter.write(buf1);</span><br><span class="line">        fileWriter.write(buf1, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//和上面的char数组一样的参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">小结</mark> :

<p>和<code>FileOutputStream</code>差不多。注意API的参数。</p>
<mark class="hl-label blue">源码</mark> :

<p><code>close()</code>里面有真正干活的函数。</p>
<p><code>close()</code>&#x3D;<code>flush()</code>+关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeBytes</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bb.flip();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lim</span> <span class="operator">=</span> bb.limit();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> bb.position();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rem &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch.write(bb) != rem)</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">false</span> : rem;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        out.write(bb.array(), bb.arrayOffset() + pos, rem);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bb.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a><font color="#5cb85c">节点流和处理流</font></h3><ul>
<li>基本介绍</li>
</ul>
<ol>
<li>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter[源码]<br><img src="/images/image-20220727194413357.png"></li>
<li>处理流(也叫包装流)是”连接”在已存在的流(节点流或处理流)之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter[源码]<br><img src="/images/image-20220727194745435.png" alt="image-20220727194745435"></li>
</ol>
<ul>
<li>节点流和处理流一览图</li>
</ul>
<p><img src="/images/image-20220727195037031.png" alt="image-20220727195037031"></p>
<mark class="hl-label blue">案例</mark> :

<p><img src="/images/image-20220727210049269.png" alt="image-20220727210049269"></p>
<p><img src="/images/image-20220727210405684.png" alt="image-20220727210405684"></p>
<p><img src="/images/image-20220727210552073.png" alt="image-20220727210552073"></p>
<p><img src="/images/image-20220727210801093.png" alt="image-20220727210801093"></p>
<mark class="hl-label blue">小结</mark> :

<p>节点流是点对点、灵活性不足，出现处理流更为灵活。</p>
<ul>
<li>节点流和处理流的区别和练习</li>
</ul>
<ol>
<li>节点流是底层流&#x2F;低级流，直接跟数据源相接。</li>
<li>处理流(包装流)包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。[源码理解]</li>
<li>处理流(也叫包装流)对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连[模拟修饰器设计模式]</li>
</ol>
<ul>
<li>处理流的功能主要体现在以下两方面：</li>
</ul>
<ol>
<li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率。</li>
<li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大量的数据，使用更加灵活方便。</li>
</ol>
<h4 id="处理流设计模式"><a href="#处理流设计模式" class="headerlink" title="处理流设计模式"></a><font color="#ffd253">处理流设计模式</font></h4><mark class="hl-label orange">模拟</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    做成处理流/包装流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferReader_</span> <span class="keyword">extends</span> <span class="title class_">Reader_</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Reader_ reader_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferReader_</span> <span class="params">(Reader_ reader_)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reader_ = reader_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装一层</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span> <span class="params">()</span> &#123;</span><br><span class="line">        reader_.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让方法更加灵活，多次读取文件,或者加缓冲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFiles</span> <span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            reader_.readFile();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展readString,批量处理字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readStrings</span> <span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            reader_.readString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    可以认为是节点流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader_</span> <span class="keyword">extends</span> <span class="title class_">Reader_</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader_</span> &#123; <span class="comment">//抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;caonim&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readString</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringReader_</span> <span class="keyword">extends</span> <span class="title class_">Reader_</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取字符串&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BufferReader_</span> <span class="variable">bufferReader_</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferReader_</span>(<span class="keyword">new</span> <span class="title class_">FileReader_</span>());<span class="comment">//灵魂是这个传入的参数已经向上转型。</span></span><br><span class="line">        bufferReader_.readFiles(<span class="number">3</span>);<span class="comment">//这里输出三次文件读取，因为向上转型的原因，这里会调用FileReader_()里面的方法</span></span><br><span class="line">        bufferReader_.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">解析</mark> ：

<p>最关键的是<code>BufferReader_</code>里面传入了<code>Reader_</code>在test类中，构造器传入一个<code>new FileReader_()</code>。因为他是Reader_的子类。这里相当于<font color="Ed5A65">向上转型</font>所以可以传入。所以下面调用的是<code>FileReader_()</code>的方法。</p>
<p>向上转型：有父类引用<code>reader_</code>指向子类的对象<code>FileReader_</code>。</p>
<mark class="hl-label orange">拓展</mark> ：

<p>也可以将<code>Reader_</code>类中的方法改为一个<font color="ed5a64">抽象方法</font>，由子类重写，然后在初始化的时候用动态绑定机制，实现不同方法的调用。</p>
<h3 id="Buffered"><a href="#Buffered" class="headerlink" title="Buffered"></a><font color="#5cb85c">Buffered</font></h3><ul>
<li>处理流-BufferedReader和BufferedWriter</li>
</ul>
<p>​	BufferedReader和BufferedWriter属于字符流，是按照字符来读取数据的<br>​	关闭时，只需要关闭外层流即可[<font color="ed5a64">后面看源码</font>]。底层会自动关闭节点流</p>
<h4 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a><font color="#ffd253">BufferedReader</font></h4><mark class="hl-label orange">应用案例</mark> ：

<p>使用BufferedReader 读取文本文件，并显示在控制台。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示bufferedreader使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bufferedreader_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Bufferedreader.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//创建Bufferedreader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 按行读取 当返回null时候，表示文件读取完毕</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不要忘记关闭流</span></span><br><span class="line">        bufferedReader.close(); <span class="comment">//只需要关闭BufferReader，因为底层就会自动关闭节点流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">源码</mark> ：Bufferedreader

<p><img src="/images/image-20220729215813441.png" alt="image-20220729215813441"></p>
<p><img src="/images/image-20220729221402153.png" alt="image-20220729221402153"></p>
<p>可以看出来<code>Bufferedreader.close</code>调用的还是传入<code>read</code>类里面的对应<code>close</code>方法。</p>
<h4 id="Bufferedwriter"><a href="#Bufferedwriter" class="headerlink" title="Bufferedwriter"></a><font color="#ffd253">Bufferedwriter</font></h4><mark class="hl-label orange">案例</mark> ：

<p>使用Bufferedwriter 写入文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示Bufferedwriter使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bufferedwriter_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Bufferedwriter.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(path));<span class="comment">//覆盖模式</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(path, <span class="literal">true</span>));<span class="comment">//追加模式</span></span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;你是傻屄吗&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();<span class="comment">//插入一个和系统相关的换行</span></span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;原来你是sss&quot;</span>);</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">案例</mark> ：

<p> 使用Buffered  Copy文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    用Buffered实现拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCopy_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Bufferedwriter.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">derFilePath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/BufferedCopy.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFilePath));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(derFilePath));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="comment">//readline 读取一行内容，但是不会读取换行符</span></span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            bufferedWriter.write(line);</span><br><span class="line">            bufferedWriter.newLine();<span class="comment">//插入换行符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>Bufferedwriter和Bufferedread是对字符的操作，不要对二进制文件进行操作[音频、视频、PDF、doc]等等。</p>
<h3 id="Buffered字节处理流"><a href="#Buffered字节处理流" class="headerlink" title="Buffered字节处理流"></a><font color="#5cb85c">Buffered字节处理流</font></h3><ul>
<li>处理流—BufferedInputStream和BufferedOutputStream</li>
</ul>
<p>​	介绍BufferedInputStream</p>
<p><img src="/images/image-20220729231400127.png" alt="image-20220729231400127"></p>
<p>​	BufferedInputStream是字节流，在创建的BufferedInputStream时,会创建一个内部缓冲区数组。</p>
<p><img src="/images/image-20220729231501603.png" alt="image-20220729231501603"></p>
<p><img src="/images/image-20220729235530934.png" alt="image-20220729235530934"></p>
<p>​	介绍BufferedOnpuStream</p>
<p><img src="/images/image-20220729235915522.png" alt="image-20220729235915522"></p>
<p>BufferedOnputStream是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统</p>
<p><img src="/images/image-20220730000043857.png" alt="image-20220730000043857"></p>
<p><img src="/images/image-20220730000256338.png" alt="image-20220730000256338"></p>
<mark class="hl-label orange">小结</mark> ：

<p>与BufferedWriter 和BufferedReader不同是，修饰器是从父类继承下来的。如上面类图所示。</p>
<p>注意<code>FilterInputStream</code>类和<code>FileInputStream</code>类的区别</p>
<p><img src="/images/image-20220730171214048.png" alt="image-20220730171214048"></p>
<mark class="hl-label purple">案例</mark> ：

<p>要求：编程完成图片&#x2F;音乐的拷贝（要求使用BufferedInput…流）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCopy02_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//源头文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">scrpath</span> <span class="operator">=</span> <span class="string">&quot;D:/java图片/Collection.png&quot;</span>;</span><br><span class="line">        <span class="comment">//目标文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Collection.png&quot;</span>;</span><br><span class="line">        <span class="comment">//新建读 的包装流</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(scrpath));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dpath));</span><br><span class="line">        <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//read方法返回读取到的长度，读完了就返回-1</span></span><br><span class="line">        <span class="keyword">while</span> ((readlen = bufferedInputStream.read(b)) != -<span class="number">1</span> ) &#123;</span><br><span class="line">            bufferedOutputStream.write(b, <span class="number">0</span>, readlen);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法使用和BufferedWriter&#x2F;Reader差不多。</p>
<mark class="hl-label purple">思考</mark> ：

<p>可以使用BufferedOutStream和BufferedInputStream完成操作文本文件吗</p>
<p><font color="EE3F4D">当然可以</font>，字符由字节组成，字节是这里最小的单位了。反过来用BufferedWriter就不能操作字节文件了。</p>
<h3 id="对象流-序列化"><a href="#对象流-序列化" class="headerlink" title="对象流(序列化)"></a><font color="#5cb85c">对象流(序列化)</font></h3><p>ObjectInputStream和ObjectoutputStream</p>
<p>看一个需求</p>
<ol>
<li>将int num &#x3D; 100 这个int 数据保存到文件中，注意不是100数字，而是int 100, 并且，能够从文件中直接恢复int 100</li>
<li>将Dog dog &#x3D; new Dog(“小黄”，3)这个对象保存到文件中，并且能够从文件中恢复</li>
<li>上面的要求，就是能够将基本数据类型或者对象进行<font color="#5cb85c">序列化和反序列化</font>操作</li>
</ol>
<p>序列化和反序列化</p>
<ol>
<li>序列化就是在保存数组时，保存<font color="EE3F4D">数据的值和数据类型</font></li>
<li>反序列化就是在恢复数据时，恢复数据的值和数据类型</li>
<li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类<br>必须实现如下两个接口之一：<br><font color="EE3F4D">Serializable</font> &#x2F;&#x2F;这是一个标记接口, 没有任何方法<br><font color="#5cb85c">Externalizable</font> &#x2F;&#x2F;该方法有方法需要实现，因此我们一般实现上面这个接口</li>
</ol>
<p><img src="/images/image-20220731180225488.png" alt="image-20220731180225488"></p>
<p>基本介绍</p>
<p><img src="/images/image-20220731181219341.png" alt="image-20220731181219341"></p>
<ol>
<li>功能：提供了对基本类型或者对象类型的序列化和反序列化的方法</li>
<li>ObjectOutputStream提供序列化功能</li>
<li>ObjectInputStream提供了反序列化功能</li>
</ol>
<h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a><font color="#ffd253">ObjectOutputStream</font></h4><p><img src="/images/image-20220731181512198.png" alt="image-20220731181512198"></p>
<mark class="hl-label purple">案例</mark> ：

<p>使用ObjectOutputStream序列化基本数据类型和一个Dog对象(name, age),并保存到data.dat文件中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示：对象流ObjectOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Object01.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line">        <span class="comment">//序列化数据到：D:/JavaIO练习/Object01.dat</span></span><br><span class="line">        oos.writeInt(<span class="number">100</span>);<span class="comment">//int -&gt; integer 自动装箱 （这里实现了Serializable）因为Integer类继承了Number而Number实现了接口Serializable</span></span><br><span class="line">        oos.writeBoolean(<span class="literal">true</span>);<span class="comment">//boolean -&gt; Boolean  也是实现了序列化</span></span><br><span class="line">        oos.writeByte(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// char -&gt; Charactar</span></span><br><span class="line">        oos.writeDouble(<span class="number">9.8</span>);<span class="comment">// double -&gt;Double</span></span><br><span class="line">        oos.writeUTF(<span class="string">&quot;飒飒撒&quot;</span>);<span class="comment">//String</span></span><br><span class="line">        <span class="comment">//保存一个dog对象,dog类没有实现接口Serializable，没有序列化</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;lwt&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">//序列化的版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">注意</mark> ：

<p>上面的基本类型都是实现了接口Serializable的，所以不用序列化，他自动装箱后就已经可以序列化了。</p>
<p><code>.dat</code>文件：</p>
<p>.dat并不是一种标准文件。许多文件都使用这个扩展名，但文件含义不同。而许多数据分析软件也用这个扩展名保存数据。所以这要看具体的软件情况来定。DAT文件，可以按照扩展名来看就是DATA的意思，即数据文件，这类文件并没有进行绝对化的定义，例如VCD光盘中的dat文件就可以用一般的视频播放器打开，而QQ的dat文件中则存储了用户信息，是不能使用常规方式打开的，只有QQ程序可以访问。还有一些其他程序都有自己对dat文件的定义，要通过产生它的程序来打开与之相关联的dat文件。</p>
<h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a><font color="#ffd253">ObjectInputStream</font></h4><p><img src="/images/image-20220731201542482.png" alt="image-20220731201542482"></p>
<mark class="hl-label purple">案例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jth.javaee.IO.InputStream_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示对象流输入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//指定反序列化的位置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">scrpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Object01.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(scrpath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="comment">//1、读取顺序（反序列化）的顺序需要和保存的数据顺序（序列化）保持一直</span></span><br><span class="line">        <span class="comment">//2、否则会出现异常</span></span><br><span class="line">        System.out.println(ois.readInt());</span><br><span class="line">        System.out.println(ois.readBoolean());</span><br><span class="line">        System.out.println(ois.readChar());</span><br><span class="line">        System.out.println(ois.readDouble());</span><br><span class="line">        System.out.println(ois.readUTF());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行类型&quot;</span>+o.getClass());</span><br><span class="line">        <span class="comment">//System.out.println(ois.readObject()); //底层Object -&gt; Dog</span></span><br><span class="line">		<span class="comment">//读取两次会报错</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">注意</mark> ：

<p>文件只能读取一次，这里读取了两次，会报错EOFexception</p>
<ol>
<li>如果我们希望调用Dog里面的方法，需要向下转型</li>
<li>需要我们将Dog类的定义，拷贝到可以引用的位置，比如public class。</li>
</ol>
<h3 id="对象处理流的注意事项"><a href="#对象处理流的注意事项" class="headerlink" title="对象处理流的注意事项"></a><font color="#5cb85c">对象处理流的注意事项</font></h3><ol>
<li>读写顺序要求一致。</li>
<li>要求实现序列化或反序列化对象，需要实现Serializable.</li>
<li>序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性<br>private static final long serialVersionUID &#x3D; 1L;<br>当类进行序列化时，他不会因为类中添加属性等操作，而认为是一个全新的类。他会认为只是原先的升级版或修改版。</li>
<li>序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员<br>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</li>
<li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li>
<li>序列化具备可继承性，也就是如果某类已经实现了序列化，则它所有的子类也已经默认实现了序列化</li>
</ol>
<h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a><font color="#5cb85c">标准输入输出流</font></h3><ul>
<li>标准输入输出流</li>
</ul>
<p>​													类型									默认设备</p>
<p>System.in 标准输入                   InputStream   				  键盘</p>
<p>System.out 标准输出  			  PrintSteam						显示器</p>
<mark class="hl-label purple">案例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputAndOutput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//System in 的public final static InputStream in = null;</span></span><br><span class="line">        <span class="comment">//可得System.in 编译类型是 InputStream</span></span><br><span class="line">        <span class="comment">//System.in 运行类型 BufferedInputStream</span></span><br><span class="line">        <span class="comment">//表示标准输入是键盘</span></span><br><span class="line">        System.out.println(System.in.getClass());<span class="comment">//class java.io.BufferedInputStream</span></span><br><span class="line">        <span class="comment">//public final static PrintStream out = null;</span></span><br><span class="line">        <span class="comment">//System.out 的编译类型是PrintStream</span></span><br><span class="line">        <span class="comment">//运行类型是PrintStream</span></span><br><span class="line">        <span class="comment">//表示：标准输出 显示器</span></span><br><span class="line">        System.out.println(System.out.getClass());<span class="comment">//class java.io.PrintStream</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//键盘输入这个构造器传入的就是标准输入System.in</span></span><br></pre></td></tr></table></figure>

<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a><font color="#5cb85c">转换流</font></h3><mark class="hl-label purple">案例引出</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codequestion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取D盘下a.txt文件，这个文件是ANSI国标码编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/a.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//创建字符输入流</span></span><br><span class="line">        <span class="comment">//这个读取默认的按照UTF-8的编码读取，所以会出现乱码</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220801215148388.png" alt="image-20220801215148388"></p>
<mark class="hl-label purple">解析</mark> ：

<p>所以需要一个转换格式的确定，保证不会乱码。</p>
<ul>
<li>转换流-InputStreamReader 和OutputStreamWriter</li>
</ul>
<p>介绍</p>
<ol>
<li>InputStreamReader：Reader的子类，可以将InputStream(字节流)包装(转换)成Reader(字符流)</li>
<li>OutputStreamWriter:Writer的子类，实现将OutputStream(字节流)包装成Writer(字符流)</li>
<li>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以将字节流转换成字符流</li>
<li>可以在使用时指定编码格式(比如UTF-8，GBK2312，ISO8859-1等)</li>
</ol>
<h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a><font color="#ffd253">InputStreamReader</font></h4><mark class="hl-label purple">类图</mark> ：

<p><img src="/images/image-20220801220441933.png" alt="image-20220801220441933"></p>
<mark class="hl-label blue">案例</mark> ：

<p>编程将字节流FileIntputStream 包装(转换)成字符流InputStreamReader,对文件进行读取(按照 gbk格式),进而包装成BufferedReader。</p>
<p>解决中文字符乱码问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/a.txt&quot;</span>;<span class="comment">//文件路径</span></span><br><span class="line">        <span class="comment">//解读</span></span><br><span class="line">        <span class="comment">//FileInputStream转换成InputStreamReader</span></span><br><span class="line">        <span class="comment">//指定编码UTF-8</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">//把InputStreamReader 转换成 BufferedReader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//关闭外层流</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">小结</mark> ：

<p>注意各个类的关系，可以看前面对整个IO整合的图。上面实现了两次的包装。</p>
<h4 id="OutputStreamReader"><a href="#OutputStreamReader" class="headerlink" title="OutputStreamReader"></a><font color="#ffd253">OutputStreamReader</font></h4><mark class="hl-label purple">类图</mark> ：

<p><img src="/images/image-20220801221023145.png" alt="image-20220801221023145"></p>
<mark class="hl-label blue">案例</mark> ：

<p>编程将字节流FileOutputStream 包装成(转换成)字节流OutputStreamWriter,对文件进行写入(按照gbk格式，可以指定其他，比如utf-8).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/OutputStreamWriter.txt&quot;</span>;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">ous</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path), StandardCharsets.UTF_8);<span class="comment">//追加模式</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(ous);</span><br><span class="line">        <span class="type">String</span> <span class="variable">scrouce</span> <span class="operator">=</span> <span class="string">&quot;起飞辣&quot;</span>;</span><br><span class="line">        bw.write(scrouce);</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a><font color="#5cb85c">PrintStream</font></h3><p>打印流只有输出流，没有输入流。</p>
<mark class="hl-label purple">类图</mark> ：

<p><img src="/images/image-20220801224453008.png" alt="image-20220801224453008"></p>
<mark class="hl-label purple">构造方法</mark> ：

<p><img src="/images/image-20220801224509368.png" alt="image-20220801224509368"></p>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printstream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">        <span class="comment">//在默认情况下PrintStream输出数据位置是标准位置即显示器，还可以打印到文件中</span></span><br><span class="line">        out.println(<span class="string">&quot;买不买轴&quot;</span>);</span><br><span class="line">        <span class="comment">//源码</span></span><br><span class="line"><span class="comment">//        public void println(String x) &#123;</span></span><br><span class="line"><span class="comment">//            synchronized (this) &#123;</span></span><br><span class="line"><span class="comment">//                print(x);</span></span><br><span class="line"><span class="comment">//                newLine();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        public void print(String s) &#123;</span></span><br><span class="line"><span class="comment">//            if (s == null) &#123;</span></span><br><span class="line"><span class="comment">//                s = &quot;null&quot;;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            write(s);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//可以看出底层println用的就是writer</span></span><br><span class="line">        out.write(<span class="string">&quot;冲吧就100块钱&quot;</span>.getBytes());<span class="comment">//结果还是一样的</span></span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们可以修改打印流的位置/设备</span></span><br><span class="line">        <span class="comment">//这里修改到对应路径</span></span><br><span class="line">        System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;D:/JavaIO练习/printstream.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//底层源码</span></span><br><span class="line"><span class="comment">//        public static void setOut(PrintStream out) &#123;</span></span><br><span class="line"><span class="comment">//            checkIO();</span></span><br><span class="line"><span class="comment">//            setOut0(out);  //这是一个native方法</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;好棒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a><font color="#5cb85c">PrintWriter</font></h3><mark class="hl-label purple">类图</mark> ：

<p><img src="/images/image-20220801224733848.png" alt="image-20220801224733848"></p>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printwriter_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out);</span><br><span class="line">        printWriter.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        printWriter.close();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:/JavaIO练习/printwriter.txt&quot;</span>));</span><br><span class="line">        printWriter1.println(<span class="string">&quot;diaomao&quot;</span>);</span><br><span class="line">        printWriter1.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>打完数据一定要<code>close</code>和之前写都一样，底层源码close才是正正干活的地方。真真写入的地方。</p>
<p><img src="/images/image-20220801232906451.png" alt="image-20220801232906451"></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><font color="#5cb85c">Properties</font></h3><ul>
<li>看一个需求</li>
</ul>
<p>如下一个配置文件 mysql.properties</p>
<p>ip &#x3D; 192.168.0.13</p>
<p>user &#x3D; root</p>
<p>pwd &#x3D; 12345</p>
<p>请问编程读取ip , user, 和pwd的值是多少</p>
<ol>
<li>传统的方法</li>
<li>使用Properties类可以方便实现</li>
</ol>
<mark class="hl-label red">传统方法</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取mysql.properties文件</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/mysql.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            String[] split = line.split(<span class="string">&quot;=&quot;</span>);  <span class="comment">//正则表达式</span></span><br><span class="line">            System.out.println(split[<span class="number">0</span>]+<span class="string">&quot;值是&quot;</span>+split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();<span class="comment">//关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">问题引出</mark> ：

<p>如果使用这种方法，需求是取ip地址，那么就会很麻烦。还需要判断<code>split[0]</code>。</p>
<p>String.split是正则表达式。</p>
<h3 id="properties读文件"><a href="#properties读文件" class="headerlink" title="properties读文件"></a><font color="#5cb85c">properties读文件</font></h3><ul>
<li>基本介绍</li>
</ul>
<p><img src="/images/image-20220802152053929.png" alt="image-20220802152053929"></p>
<ol>
<li>专门用于读写配置文件的<font color="F07C82">集合类</font><br>配置文件的格式：<br>键&#x3D;值<br>键&#x3D;值</li>
<li>注意：键值对不需要有空格，值不需要用引号括起来，默认类型是<code>String</code>。</li>
<li>Properties常用方法</li>
</ol>
<ul>
<li>load:加载配置文件的键值对到Properties对象</li>
<li>list:将数据显示到指定设备</li>
<li>getProperty(key):根据键获取值</li>
<li>setPropety(key，value): 设置键值对到Properties对象</li>
<li>store:将Properties中的键值对存储到配置文件中，在idea中，保存信息到配置文件，如果含有中文，会存储为Unicode码。、</li>
</ul>
<mark class="hl-label blue">案例</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//使用Properties类读取文件</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//加载指定配置文件</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//显示到指定位置（控制台）</span></span><br><span class="line">        properties.list(System.out);</span><br><span class="line">        <span class="comment">//根据Key获取对应的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名是&quot;</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">解析</mark> ：

<p>因为文件类型是<code>.properties</code>。所以在调用<code>getProperty</code>方法时候会按照他的源码方式读取，如果我将getPropeties参数改成”root”，没有按照底层格式，则会返回null。</p>
<h3 id="properties修改文件"><a href="#properties修改文件" class="headerlink" title="properties修改文件"></a><font color="#5cb85c">properties修改文件</font></h3><mark class="hl-label blue">案例</mark> ：

<p>1.使用Properties类添加key-val到新文件 mysql2.properties中</p>
<p>2.使用Properties类完成对mysql.properties的读取，并修改某个key-val</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;芜湖&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;0002&quot;</span>,<span class="string">&quot;niubi&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;0003&quot;</span>,<span class="string">&quot;niubi2&quot;</span>);</span><br><span class="line">        <span class="comment">//1.使用Properties类添加key-val到新文件 mysql2.properties中</span></span><br><span class="line">        <span class="comment">//使用字节流输出，不然会乱码。因为他是Unicode编码</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql2.properties&quot;</span>),<span class="string">&quot;cao&quot;</span>);<span class="comment">//cao这个位置是comments注解注释的意思</span></span><br><span class="line">        System.out.println(<span class="string">&quot;保存成功&quot;</span>);</span><br><span class="line">        <span class="comment">//2.使用Properties类完成对mysql.properties的读取，并修改某个key-val</span></span><br><span class="line">        <span class="comment">//如果该文件没有对应的key就是创建，</span></span><br><span class="line">        <span class="comment">//如果该文件有对应的key就是修改</span></span><br><span class="line">        <span class="comment">//底层源码</span></span><br><span class="line"><span class="comment">//        public synchronized V put(K key, V value) &#123;</span></span><br><span class="line"><span class="comment">//            // Make sure the value is not null</span></span><br><span class="line"><span class="comment">//            if (value == null) &#123;</span></span><br><span class="line"><span class="comment">//                throw new NullPointerException();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            // Makes sure the key is not already in the hashtable.</span></span><br><span class="line"><span class="comment">//            Hashtable.Entry&lt;?,?&gt; tab[] = table;</span></span><br><span class="line"><span class="comment">//            int hash = key.hashCode();</span></span><br><span class="line"><span class="comment">//            int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span></span><br><span class="line"><span class="comment">//            @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="comment">//            Hashtable.Entry&lt;K,V&gt; entry = (Hashtable.Entry&lt;K,V&gt;)tab[index];</span></span><br><span class="line"><span class="comment">//            for(; entry != null ; entry = entry.next) &#123;</span></span><br><span class="line"><span class="comment">//                if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span></span><br><span class="line"><span class="comment">//                    V old = entry.value;</span></span><br><span class="line"><span class="comment">//                    entry.value = value;</span></span><br><span class="line"><span class="comment">//                    return old;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            addEntry(hash, key, value, index);</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO流作业"><a href="#IO流作业" class="headerlink" title="IO流作业"></a><font color="#5cb85c">IO流作业</font></h3><ol>
<li>编程题</li>
</ol>
<p>​		判断D盘下是否有文件夹mytemp,如果没有就创建mytemp</p>
<p>​		在D:&#x2F;mytemp目录下，创建文件hello.txt</p>
<p>​		如果hello.txt已经存在，提示该文件已经存在，就不要再重复创建了</p>
<p>​        写入hello.world</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 作业<span class="number">01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">directorypath</span> <span class="operator">=</span> <span class="string">&quot;D:/mytemp&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(directorypath);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该目录存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.mkdirs()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;目录创建成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;目录创建失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/mytemp/hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line">        <span class="keyword">if</span> (file1.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已经存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            file1.createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filepath));<span class="comment">//会自动创建文件。</span></span><br><span class="line">            bw.write(<span class="string">&quot;hello.world&quot;</span>);</span><br><span class="line">            bw.close();<span class="comment">//关闭流</span></span><br><span class="line">            System.out.println(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>真正创建文件的是<code>createFile()</code>这个方法。</p>
<p><code>BufferedWriter bw = new BufferedWriter(new FileWriter(filepath));</code>这句话如果没有文件他自动会创建好，只要路径对。所以将对象写到最里面，避免影响。</p>
<p>2、编程题</p>
<p>要求：使用BufferedReader读取一个文本文件，为每行加上行号。</p>
<p>再连同内容一并输出到屏幕上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 作业<span class="number">02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/a.txt&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(i +<span class="string">&quot; &quot;</span>+ line);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、编程题</p>
<p>要求编写一个dog.properties</p>
<p>name&#x3D;tom</p>
<p>age&#x3D;5</p>
<p>color&#x3D;red</p>
<p>编写Dog类（name,age,color)创建一个dog对象，读取dog.properties用相应的内容完成属性初始化，并输出。</p>
<p>序列化、反序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 作业<span class="number">03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;src/dog.properties&quot;</span>;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> properties.get(<span class="string">&quot;name&quot;</span>)+<span class="string">&quot;&quot;</span>;<span class="comment">//将object类型转换成String</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span>Integer.parseInt(properties.get(<span class="string">&quot;age&quot;</span>)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> properties.get(<span class="string">&quot;color&quot;</span>)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(name, age, color);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将dog类序列化到dog.dat</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path1</span> <span class="operator">=</span> <span class="string">&quot;src/dog.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path1));</span><br><span class="line">        oos.writeObject(dog);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path1));</span><br><span class="line">        <span class="comment">//System.out.println(ois.readObject());//都行</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span>(Dog) ois.readObject();</span><br><span class="line">        System.out.println(dog1);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;<span class="comment">//实现序列化</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p><code>properties.get</code>这个方法返回Object类，使用<code>getproperties</code>是返回String类型。</p>
<p>类型转换的时候，Object转成一个int类型需要先转换成String类型。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a><font color="#6dc1f7">网络编程</font></h2><h3 id="网络相关概念"><a href="#网络相关概念" class="headerlink" title="网络相关概念"></a><font color="#5cb85c">网络相关概念</font></h3><ul>
<li>网络通信</li>
</ul>
<ol>
<li>概念：两台设备之间通过网络实现数据传输</li>
<li>网络通信：将数据通过网络从一台设备传输到另一台设备</li>
<li>java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信</li>
</ol>
<p><img src="/images/image-20220805225621787.png" alt="image-20220805225621787"></p>
<ul>
<li>网络</li>
</ul>
<ol>
<li>概念：两台或多态设备通过一定物理设备连接起来构成了网络</li>
<li>根据网络的覆盖范围不同，对网络进行分类：<br>局域网：覆盖范围最小，仅仅覆盖一个教师或一个机房<br>城域网：覆盖范围较大，可以覆盖一个城市<br>广域网：覆盖范围最大，可以覆盖全国，甚至全球，万维网是广域网的代表。</li>
</ol>
<p><img src="/images/image-20220805225835947.png" alt="image-20220805225835947"></p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a><font color="#5cb85c">IP地址</font></h3><ol>
<li>概念：用于唯一标识网络中的每台计算机</li>
<li>查看ip地址：ipconfig</li>
<li>ip地址的表示形式：点分十进制 xx.xx.xx.xx</li>
<li>每一个十进制数的范围：0~255</li>
<li>ip地址的组成&#x3D;网络地址+主机地址，比如：192.168.16.69</li>
<li>IPv6是互联网工程任务组设计的用于替代IPv4的下一代IP协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址[1].</li>
<li>由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍。</li>
</ol>
<p><img src="/images/image-20220806204614876.png" alt="image-20220806204614876"></p>
<ul>
<li>ipv4地址分类</li>
</ul>
<p><img src="/images/image-20220806210841167.png" alt="image-20220806210841167"></p>
<mark class="hl-label red">注意</mark> ：

<p>服务器的地址一般是静态的，固定不变的。主机什么的可以修改。</p>
<h3 id="域名和端口"><a href="#域名和端口" class="headerlink" title="域名和端口"></a><font color="#5cb85c">域名和端口</font></h3><ul>
<li>域名</li>
</ul>
<ol>
<li><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></li>
<li>好处：为了方便</li>
<li>概念：将ip地址映射成域名 (http协议)</li>
</ol>
<ul>
<li>端口号</li>
</ul>
<ol>
<li>概念：用于标识计算机上某个<font color="EE3F4D">特定的网络程序</font></li>
<li>表示形式：以整数形式，范围0~65535</li>
<li><font color="EE3F4D">0~1024已经被占用</font>，比如ssh 22, ftp 21, smtp 25 http 80</li>
<li>常见的网络程序端口号：<br>tomcat:8080<br>mysql:3306<br>oracle:1521<br>sqlserver:1433</li>
</ol>
<p><img src="/images/image-20220807141620533.png" alt="image-20220807141620533"></p>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a><font color="#5cb85c">网络协议</font></h3><ul>
<li>网络通信协议</li>
</ul>
<p>协议（tcp&#x2F;ip）</p>
<p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）的简写。</p>
<p>中文译名为传输控制协议&#x2F;因特网互联协议，又叫网络通讯协议，这个协议是Internet最基本的协议、Internet国际互联网络的基础，简单地说，就是由网络层的IP协议和传输层的TCP协议组成的</p>
<p><img src="/images/image-20220807145042556.png" alt="image-20220807145042556"></p>
<p><img src="/images/image-20220807145226451.png" alt="image-20220807145226451"></p>
<p><img src="/images/image-20220807150940405.png" alt="image-20220807150940405"></p>
<h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a><font color="#5cb85c">TCP和UDP</font></h3><ul>
<li>TCP和UDP</li>
</ul>
<p>​	TCP协议：</p>
<ol>
<li>使用TCP协议前，必须建立TCP连接，形成传输数据通道</li>
<li>传输前，采用”三次握手”方式，是<font color="#5cb85c">可靠的</font></li>
<li>TCP协议进行通信的两个应用程序：客户端、服务端</li>
<li>在连接中可进行大数据量的传输</li>
<li>传输完毕，需释放已建立的连接，<font color="EE3F4D">效率低</font>。</li>
</ol>
<p>​	UDP协议：</p>
<ol>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据的大小限制在64K内，不适合传输大量数据</li>
<li>因无需连接，故是<font color="EE3F4D">不可靠的</font></li>
<li>发送数据结束时无需释放资源(因为不是面向连接)，速度快</li>
<li>举例：厕所通知：发短信</li>
</ol>
<mark class="hl-label red">三次握手</mark> ：

<p>第一次向server发包</p>
<p><img src="/images/image-20220807151949220.png" alt="image-20220807151949220"></p>
<p>第二次回一个</p>
<p><img src="/images/image-20220807152023584.png" alt="image-20220807152023584"></p>
<p>第三次再向server回一个包</p>
<p><img src="/images/image-20220807152053682.png" alt="image-20220807152053682"></p>
<mark class="hl-label blue">模拟</mark> ：

<p>TCP</p>
<p><img src="/images/image-20220807161942943.png" alt="image-20220807161942943"></p>
<p>UDP</p>
<p><img src="/images/image-20220807162406978.png" alt="image-20220807162406978"></p>
<h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a><font color="#5cb85c">InetAddress类</font></h3><ul>
<li>相关方法</li>
</ul>
<ol>
<li>获取本机InetAddress对象 getLocalHost</li>
<li>根据指定主机名&#x2F;域名获取ip地址对象 getByName </li>
<li>获取InetAddress对象的主机名 getHostName</li>
<li>获取InetAddress对象的地址 getHostAddress</li>
</ol>
<mark class="hl-label blue">代码</mark> ：

<p><img src="/images/image-20220807182436108.png" alt="image-20220807182436108"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">API_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">//1、这是一个类方法</span></span><br><span class="line">        <span class="comment">//获取本机的InetAddress对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(localHost);<span class="comment">//LAPTOP-D4QMQFD0/192.168.0.107</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、根据主机指定主机名称，获取InetAddress对象。</span></span><br><span class="line">        System.out.println(InetAddress.getByName(<span class="string">&quot;LAPTOP-D4QMQFD0&quot;</span>));<span class="comment">//LAPTOP-D4QMQFD0/192.168.0.107</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、根据域名返回InetAddress对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(byName);<span class="comment">//www.baidu.com/180.101.49.11</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、通过InetAddress，获取对应地址/获取主机名，如果他没有主机名字可能返回域名</span></span><br><span class="line">        System.out.println(localHost.getHostAddress());<span class="comment">//192.168.0.107</span></span><br><span class="line">        System.out.println(byName.getHostName());<span class="comment">//www.baidu.com</span></span><br><span class="line">        System.out.println(localHost.getHostName());<span class="comment">//LAPTOP-D4QMQFD0</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a><font color="#5cb85c">Socket</font></h3><ul>
<li>基本介绍</li>
</ul>
<ol>
<li>套接字（Socket）开发网络应用程序被广泛采用，以至于成为事实上的标准。</li>
<li>通信的两端都要有Socket，是两台机器间通信的端点</li>
<li>网络通信其实就是Socket间的通信。</li>
<li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输</li>
<li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li>
</ol>
<p><img src="/images/image-20220807214235614.png" alt="image-20220807214235614"></p>
<ul>
<li><p>TCP网络通信编程（可靠的）</p>
<ul>
<li>基本介绍</li>
</ul>
<ol>
<li>基于客户端–服务端的网络通信</li>
<li>底层使用的是TCP&#x2F;IP协议</li>
<li>应用场景举例：客户端发送数据，服务端接受并显示</li>
<li>基于Socket的TCP编程</li>
</ol>
</li>
</ul>
<p><img src="/images/image-20220807214915856.png" alt="image-20220807214915856"></p>
<mark class="hl-label red">注意</mark> ：

<p>客户端和服务器端通常情况下，是在不同主机的，但是下面例子都是在同一台机器演示</p>
<h4 id="TCP字节流编程"><a href="#TCP字节流编程" class="headerlink" title="TCP字节流编程"></a><font color="#ffd253">TCP字节流编程</font></h4><mark class="hl-label orange">案例1</mark> ：

<ol>
<li>编写一个服务器端，和一个客户端</li>
<li>服务器端在9999端口监听（只能监听一次）</li>
<li>客户端连接到服务器端，发送”hello，server“；然后退出</li>
<li>服务器端接收到客户端发送的信息，输出，并退出</li>
</ol>
<mark class="hl-label red">注意</mark> ：

<p>注意写的是两个程序   服务端和客户端。</p>
<mark class="hl-label blue">示意图</mark> ：

<p><img src="/images/image-20220808171406707.png" alt="image-20220808171406707"></p>
<mark class="hl-label blue">代码</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 编写一个服务器端，和一个客户端</span></span><br><span class="line"><span class="comment">//        2. 服务器端在9999端口监听（只能监听一次）</span></span><br><span class="line"><span class="comment">//        3. 客户端连接到服务器端，发送”hello，server“；然后退出</span></span><br><span class="line"><span class="comment">//        4. 服务器端接收到客户端发送的信息，输出，并退出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP01Sever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//表示在本机的9999端口监听 。 要求本机没有占用这个端口9999</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//当没有客户端接到9999端口时，程序会阻塞，等待连接</span></span><br><span class="line">        <span class="comment">//如果有客户端连接， 就会返回一个Socket对象，程序继续</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端口9999在监听，等待连接&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端 Socket=&quot;</span> + socket.getClass());</span><br><span class="line">        <span class="comment">//获得输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//IO流读取</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span> [] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ( (read = inputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, read));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP01Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//意思是连接这个主机（本机)的9999端口</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端 socket返回&quot;</span>+ socket.getClass());</span><br><span class="line">        <span class="comment">//连接上后生成socket通过方法得到输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;去死吧&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//关闭流对象和socket   必须</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220808172143368.png" alt="image-20220808172143368"></p>
<p><img src="/images/image-20220808172153676.png" alt="image-20220808172153676"></p>
<mark class="hl-label blue">细节</mark> ：

<p><code>Socket socket = serverSocket.accept();</code>可以返回多个Socket【多个客户端连接服务器的并发】，所以最后需要关闭这个，避免资源的浪费。</p>
<p><code>ServerSocket serverSocket = new ServerSocket(9999);</code></p>
<p>&#x2F;&#x2F;当没有客户端接到9999端口时，程序会阻塞，等待连接</p>
<mark class="hl-label orange">案例2</mark> ：

<ol>
<li>编写一个服务器端，和一个客户端</li>
<li>服务器端在9999端口监听</li>
<li>客户端连接到服务器端，发送”hello,sever”,并接收服务器端回发的“hello，client，再退出</li>
<li>服务器端接收到客户端发送的信息，输出，并发送”hello，client“，再退出</li>
</ol>
<mark class="hl-label blue">示意图</mark> ：

<p><img src="/images/image-20220808185555195.png" alt="image-20220808185555195"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP02Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,sever&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput();<span class="comment">//相当于一个输出结束标识符</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((read = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span> ,read));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP02Sever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((read = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, read));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,Client&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">解析</mark> ：

<p>和案例一的区别就是加一个，结束标识符号就行<code>socket.shutdownInput();socket.shutdownOutput();</code></p>
<h4 id="TCP字符流编程"><a href="#TCP字符流编程" class="headerlink" title="TCP字符流编程"></a><font color="#ffd253">TCP字符流编程</font></h4><mark class="hl-label orange">案例3</mark> ：

<p><font color="#ffd253">使用字符流</font></p>
<ol>
<li>编写一个服务端，和一个客户端</li>
<li>服务端再8888端口监听</li>
<li>客户端连接到服务端，发送”hello,server”,并接收服务端回发的“hello,client,再退出。</li>
<li>服务端接收到客户端发送的信息，输出，并发送”hello,client”,再退出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP03Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//使用转换流</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(outputStreamWriter);</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,sever&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();<span class="comment">//结束符</span></span><br><span class="line">        bufferedWriter.flush();<span class="comment">//必须要刷新，不刷新不会写入，并且会导致异常</span></span><br><span class="line">        <span class="comment">//socket.shutdownOutput();</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP03Sever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(outputStreamWriter);</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,client&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();<span class="comment">//结束符</span></span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        <span class="comment">//socket.shutdownOutput();</span></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>可以使用<code>write.newline()</code>,但是另一边读取的时候必须用<code>readline();</code></p>
<p>写入后必须使用<code>flush()</code>才能是数据写入，不然会报异常（使用socket.shutdownOutput();当作结束符的时候），在<code>bufferedWriter.close();</code>报异常。因为没有写入就close了。</p>
<p>BufferedWriter装饰器，不用使用循环读数据，里面已经给你封装好方法，切勿混淆。</p>
<h4 id="网络上传文件"><a href="#网络上传文件" class="headerlink" title="网络上传文件"></a><font color="#ffd253">网络上传文件</font></h4><mark class="hl-label orange">案例4</mark> ：

<ol>
<li>编写一个服务端，和一个客户端</li>
<li>服务端在8888端口监听</li>
<li>客户端连接到服务端，发送一张图片</li>
<li>服务端接收到客户端发送的图片，保存到src下，发送”收到图片”再退出</li>
<li>客户端接收到服务端发送的”收到图片“。再退出</li>
<li>该程序要求使用StreamUtils.java 自己封装的类</li>
</ol>
<mark class="hl-label blue">示意图</mark> ：

<p><img src="/images/image-20220808214655646.png" alt="image-20220808214655646"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP04Sever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//等待连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">//得到输入流， 读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//使用输入流转数组的方法</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = StreamUtils.streamToByteAray(inputStream);</span><br><span class="line">        outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src/Collection01.png&quot;</span>);</span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向客户端发送收到图片使用字符流</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">        bw.write(<span class="string">&quot;收到图片&quot;</span>);</span><br><span class="line">        bw.flush();<span class="comment">//把内容真正写入（刷新）</span></span><br><span class="line">        <span class="comment">//socket.shutdownOutput();//写入结束标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        bw.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        <span class="comment">//关闭其他流</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP04Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//调用方法，将图片转换成数组</span></span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/Collection.png&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = StreamUtils.streamToByteAray(inputStream);</span><br><span class="line">        <span class="comment">//传图片对应的数组内容写入到数据通道</span></span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        <span class="comment">//结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接受服务端的消息使用字节流读入</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream1</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//使用工具类中方法，将输入流转换成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> StreamUtils.streamToString(inputStream1);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        inputStream1.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamUtils</span> &#123;</span><br><span class="line">    <span class="comment">//将流转换成数组的方法，输入形参可以是图片，通过fileInputStream就可以传入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] streamToByteAray(InputStream is) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readlen = is.read(buf)) != -<span class="number">1</span>) &#123;<span class="comment">//循环读取的目的防止数组太小，不能一次性读完</span></span><br><span class="line">            bo.write(buf, <span class="number">0</span>, readlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes = bo.toByteArray();</span><br><span class="line">        bo.close();<span class="comment">//注意关闭流</span></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将inputStream转换成String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">streamToString</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line=bw.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            builder.append(line+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">注意</mark> ：

<p>这个版本的JDK不用每次都有结束符，比如就要发送一次数据。有了<code>socket.close()</code>上面不用写结束标志，不然会报错。</p>
<p>输入流输出流的读写都是，靠数组转换，输入就<code>read()</code>，因为不确定大小，并且数组在初始化后就能改变大小，所以需要循环读取。然后会保存到流中，这个很关键，就可以调用这个流类里面的方法，比如上面&#96;StreamToArrays，调用toArrays方法完成转换。</p>
<h4 id="netstat指令"><a href="#netstat指令" class="headerlink" title="netstat指令"></a><font color="#ffd253">netstat指令</font></h4><ol>
<li>netstat -an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况</li>
<li>netstat -an | more 可以分页显示</li>
<li>netstat -anb 可以显示具体是哪个软件在使用这个端口(需要管理员身份)</li>
<li>要求在dos控制台下执行(cmd)</li>
</ol>
<p><img src="/images/image-20220809133140373.png" alt="image-20220809133140373"></p>
<mark class="hl-label orange">说明</mark> ：

<ol>
<li>Listening 表示某个端口在监听</li>
<li>如果有一个外部程序(客户端)连接到该端口，就会显示一条连接消息。</li>
<li>Ctrl+C 退出程序</li>
</ol>
<h4 id="TCP连接秘密"><a href="#TCP连接秘密" class="headerlink" title="TCP连接秘密"></a><font color="#ffd253">TCP连接秘密</font></h4><ol>
<li><p>当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是TCP&#x2F;IP来分配的,是不确定的，是随机的</p>
</li>
<li><p>示意图<br><img src="/images/image-20220809155233928.png" alt="image-20220809155233928"></p>
</li>
<li><p>程序验证+netstat</p>
<p><img src="/images/image-20220809160109224.png" alt="image-20220809160109224"><br><img src="/images/image-20220809160131485.png" alt="image-20220809160131485"></p>
</li>
</ol>
<mark class="hl-label orange">说明</mark> ：

<p>客户端的socket端口是随机的，重启就会改变端口号(60285)；</p>
<p>为什么能看到两个8888，因为服务器和客户端在同一台电脑上。</p>
<h3 id="UDP编程-了解"><a href="#UDP编程-了解" class="headerlink" title="UDP编程(了解)"></a><font color="#5cb85c">UDP编程(了解)</font></h3><ul>
<li>基本介绍</li>
</ul>
<ol>
<li>类DatagramSocket和DatagramPacket[数据报&#x2F;数据包]实现了基于UDP协议网络程序。</li>
<li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送发哦目的地，也不能确定什么时候可以抵达</li>
<li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接</li>
</ol>
<ul>
<li>基本流程</li>
</ul>
<ol>
<li>核心的两个类&#x2F;对象 DatagramSocket与DatagramPacket</li>
<li>建立发送端，接收端（没有服务端和客户端的概念）</li>
<li>建立数据包&#x2F;报 DatagramPacket对象</li>
<li>调用DatagramSocket的发送，接收方法</li>
<li>关闭DatagramSocket</li>
</ol>
<p><img src="/images/image-20220809162203784.png" alt="image-20220809162203784"></p>
<p><img src="/images/image-20220809162226379.png" alt="image-20220809162226379"></p>
<mark class="hl-label blue">案例</mark> ：

<ol>
<li>编写一个接收端A和一个发送端B</li>
<li>接收端A在9999端口等待接收数据（receive）</li>
<li>发送端B向接收端A发送数据”hello，明天吃火锅“</li>
<li>接收端A接收到发送端B发送的数据，回复”好的明天吃火锅”</li>
<li>发送端接收回复的数据，再退出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketUDP_B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建DatagramSocket 对象，准备在9998接收数据</span></span><br><span class="line">        <span class="comment">//同一台机器，所以端口要不一样</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="comment">//2、将需要发送的数据，装包到DatagramPacket对象中，</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;明天吃火锅,caonima&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//3、发送数据</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">        <span class="comment">//拆包</span></span><br><span class="line">        socket.receive(packet1);</span><br><span class="line">        <span class="type">byte</span>[] data = packet1.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet1.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length));</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketUDP_A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个DatagramSocket对象，准备在9999接收数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、构建一个DatagramPacket对象，准备接收数据</span></span><br><span class="line">        <span class="comment">//前面说过UDP协议，最大支持64K的数据包</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">        <span class="comment">//调用接收方法，将通过网络传输的DatagramPacket对象</span></span><br><span class="line">        <span class="comment">//填充到packet对象</span></span><br><span class="line">        <span class="comment">//提示：当有数据包发送到端口9999时候，此方法就会接收到数据</span></span><br><span class="line">        <span class="comment">//如果没有数据包发送到本机的9999端口，就会阻塞等待。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数据端A等待数据。。。。&quot;</span>);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把packet进行拆包</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength();<span class="comment">//实际接收到的数据长度</span></span><br><span class="line">        <span class="type">byte</span>[] data = packet.getData();<span class="comment">//实际接收到的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A端回消息</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="string">&quot;好的，明天见&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes1, bytes1.length, InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">9998</span>);</span><br><span class="line">        socket.send(packet1);</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;A端退出。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">区别</mark> ：

<p>和TCP的区别是，UDP把数据打包成一个包，就无需考虑截止信号等，流的关闭等。<code>receive（）</code>就相当于TCP的<code>accpet</code>。但是UDP是不可靠的。</p>
<h3 id="网络编程作业"><a href="#网络编程作业" class="headerlink" title="网络编程作业"></a><font color="#5cb85c">网络编程作业</font></h3><p>作业1：</p>
<ol>
<li>使用字符流的方式，编写一个客户端程序和服务端程序</li>
<li>客户端发送”name”,服务端接收到后，返回”我是nova”，nova是你自己的名字</li>
<li>客户端发送”hoby”,服务端接收到后，返回”编写Java程序”</li>
<li>不是这两个问题，回复”你说啥呢”。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 服务器<span class="number">01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//转换流</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">//装饰器</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发来&quot;</span>+s);</span><br><span class="line">        socket.shutdownInput();<span class="comment">//标记结束</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">            bw.write(<span class="string">&quot;我是nova&quot;</span>);</span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;hoby&quot;</span>)) &#123;</span><br><span class="line">            outputStream =socket.getOutputStream();</span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">            bw.write(<span class="string">&quot;写Java程序&quot;</span>);</span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputStream =socket.getOutputStream();</span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">            bw.write(<span class="string">&quot;你在说啥&quot;</span>);</span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        br.close();<span class="comment">//关闭流</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 客户端<span class="number">01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>),<span class="number">9999</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//使用转换流</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">//装饰器</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你的问题&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">massage</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        bw.write(massage);</span><br><span class="line">        bw.flush();<span class="comment">//刷新 写入</span></span><br><span class="line"></span><br><span class="line">        socket.shutdownOutput();<span class="comment">//标识符</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span>  br.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        bw.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>关闭流的时候要在程序末尾关闭，不然会报错。</p>
<p>作业02：</p>
<ol>
<li>编写一个接收端A，和一个发送端B，使用UDP协议完成</li>
<li>接收端在8888端口等待接收数据(receive)</li>
<li>发送端向接收端发送数据”四大名著是哪些”</li>
<li>接收端接收到发送端发送的问题后，返回”四大名著《红楼梦》。。”否则返回你麻痹</li>
<li>接收端和发送端程序退出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 接收端A &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个DatagramSocket对象，准备在9999接收数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、构建一个DatagramPacket对象，准备接收数据</span></span><br><span class="line">        <span class="comment">//前面说过UDP协议，最大支持64K的数据包</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">        <span class="comment">//调用接收方法，将通过网络传输的DatagramPacket对象</span></span><br><span class="line">        <span class="comment">//填充到packet对象</span></span><br><span class="line">        <span class="comment">//提示：当有数据包发送到端口9999时候，此方法就会接收到数据</span></span><br><span class="line">        <span class="comment">//如果没有数据包发送到本机的9999端口，就会阻塞等待。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数据端A等待数据。。。。&quot;</span>);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把packet进行拆包</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength();<span class="comment">//实际接收到的数据长度</span></span><br><span class="line">        <span class="type">byte</span>[] data = packet.getData();<span class="comment">//实际接收到的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;四大名著是哪些&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//A端回消息</span></span><br><span class="line">            answer = <span class="string">&quot;你这都不知道,红楼梦,三国演义,水浒传,西游记&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//A端回消息</span></span><br><span class="line">            answer = <span class="string">&quot;what&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes1 = answer.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet1</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes1, bytes1.length, InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">9998</span>);</span><br><span class="line">        socket.send(packet1);</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;A端退出。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 发送端B &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建DatagramSocket 对象，准备在9998接收数据</span></span><br><span class="line">        <span class="comment">//同一台机器，所以端口要不一样</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="comment">//2、将需要发送的数据，装包到DatagramPacket对象中，</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入你的问题&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">problem</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">byte</span>[] bytes = problem.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//3、发送数据</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);<span class="comment">//bug所在</span></span><br><span class="line">        <span class="comment">//拆包</span></span><br><span class="line">        socket.receive(packet1);</span><br><span class="line">        <span class="type">byte</span>[] data = packet1.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet1.getLength();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>这个输出还是有问题，根据你输入的字符长度显示一样的长度，就导致数据显示不全，不知道问题出哪里了。很难受。</p>
<p>破案了上面的问题就是，数组长度出错了</p>
<p><code>DatagramPacket packet1 = new DatagramPacket(bytes, bytes.length);</code></p>
<p>应该用<code>bvtes1</code>的</p>
<p>作业3：</p>
<ol>
<li>编写客户端程序和服务端程序</li>
<li>客户端可以输入一个音乐文件名，比如高山流水，服务端收到音乐后，可以给可以给客户端返回这个音乐文件，如果服务器没有这个文件，返回默认一个音乐即可，</li>
<li>客户端收到文件后，保存到src</li>
<li>提示：该程序可以使用StreamUtils.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 服务端<span class="number">02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//用于传输音乐文件</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//音乐文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">musicPath</span> <span class="operator">=</span> <span class="string">&quot;D:\\CloudMusic\\Ampyx - Ember.mp3&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">musicPath1</span> <span class="operator">=</span> <span class="string">&quot;D:\\CloudMusic\\Anastasia Kushnir - Yesterday.mp3&quot;</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(musicPath);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(musicPath1);</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        socket.shutdownInput();<span class="comment">//结束标志语句</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;高山流水&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//调用工具类方法将音乐流变成数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = StreamUtils.streamToByteAray(fileInputStream);</span><br><span class="line">            outputStream.write(bytes);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = StreamUtils.streamToByteAray(fileInputStream1);</span><br><span class="line">            outputStream.write(bytes);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        br.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        fileInputStream1.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 客户端<span class="number">02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//装饰器</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src/music.mp3&quot;</span>);</span><br><span class="line">        <span class="comment">//消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你想要的歌曲&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">massage</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        bw.write(massage);</span><br><span class="line">        bw.flush();</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始接收音乐文件文件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((readlen = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(bytes, <span class="number">0</span>, readlen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭各种流</span></span><br><span class="line">        bw.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a><font color="#6dc1f7">反射</font></h2><ul>
<li>问题引出</li>
</ul>
<ol>
<li>根据配置文件 re.properties 指定信息，创建Cat对象并调用方法hi<br>classfullpath&#x3D;com.jth.question.Cat<br>method&#x3D;hi</li>
<li>这样的需求在学习框架时特别多，即通过外部文件配置，在不修改源码情况下，来控制程序，也符合设计模式的ocp原则（开闭原则）</li>
<li>代码尝试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    反射问题引入</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionQuestion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//根据配置文件 re.properties 指定信息，创建Cat对象并调用方法hi</span></span><br><span class="line">    <span class="comment">//传统方式</span></span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    cat.hi();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试使用配置文件</span></span><br><span class="line">    <span class="comment">//1、使用Properties类，可以读写配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/re.properties&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>)+<span class="string">&quot;&quot;</span>;<span class="comment">//转换成字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(classfullpath);</span><br><span class="line">    System.out.println(method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建对象，传统的方法行不通,需要用到反射机制</span></span><br><span class="line">    <span class="comment">//new classfullpath();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jth.question;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;说hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classfullpath=com.jth.question.Cat</span><br><span class="line">method=hi</span><br></pre></td></tr></table></figure>

<ul>
<li>使用反射解决(非常牛逼)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、使用反射机制解决</span></span><br><span class="line"><span class="comment">//加载类</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(classfullpath);</span><br><span class="line"><span class="comment">//通过aClass得到你加载的类 com.jth.Cat的对象实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">System.out.println(o.getClass()); <span class="comment">//Cat类</span></span><br><span class="line"><span class="comment">//3、通过aClass得到你加载的类Cat里面的方法,通过配置文件名字</span></span><br><span class="line"><span class="comment">//即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> aClass.getMethod(method);</span><br><span class="line"><span class="comment">//4、通过method1调用方法，即通过方法对象来实现调用方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">method1.invoke(o);<span class="comment">//传统方法，是对象调用方法，这里反射是方法.invoke(对象)。</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label red">优点</mark> ：

<p>假如Cat类中有两个方法：hi() 和cry</p>
<p>使用传统方法调用cry时候只能修改源码添加代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统方式</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">cat.hi();</span><br><span class="line">cat.cry();</span><br></pre></td></tr></table></figure>

<p>而使用反射机制只需要改配置文件properties即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classfullpath=com.jth.question.Cat</span><br><span class="line">method=cry</span><br></pre></td></tr></table></figure>

<h3 id="反射原理图"><a href="#反射原理图" class="headerlink" title="反射原理图"></a><font color="#5cb85c">反射原理图</font></h3><ul>
<li>Java Reflection</li>
</ul>
<ol>
<li>反射机制允许程序在执行期借助于ReflectionAPI取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</li>
<li>加载完类之后，在堆中就产生一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为：反射。</li>
</ol>
<ul>
<li>Java反射机制原理示意图</li>
</ul>
<p><img src="/images/image-20220822234037124.png" alt="image-20220822234037124"></p>
<p>类加载器是通过<code>loadClass()</code>方法完成类的对象加载。</p>
<mark class="hl-label red">解释</mark> ：

<p>类加载阶段，会映射成<font color="#5cb85c">对象</font>，由于有多个对象和构造器等（一些泛型啊异常都没写）。就会映射成数组用于存放多个。</p>
<h3 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a><font color="#5cb85c">反射相关类</font></h3><ul>
<li>反射可以完成什么事</li>
</ul>
<ol>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时得到任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>生成动态代理</li>
</ol>
<p><img src="/images/image-20220822235555797.png" alt="image-20220822235555797"></p>
<p>这些类在java.lang.reflect 包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1、使用Properties类，可以读写配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>)+<span class="string">&quot;&quot;</span>;<span class="comment">//转换成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(classfullpath);</span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、使用反射机制解决</span></span><br><span class="line">        <span class="comment">//加载类</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//通过aClass得到你加载的类 com.jth.Cat的对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        System.out.println(o.getClass()); <span class="comment">//Cat类</span></span><br><span class="line">        <span class="comment">//3、通过aClass得到你加载的类Cat里面的方法,通过配置文件名字</span></span><br><span class="line">        <span class="comment">//即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> aClass.getMethod(method);</span><br><span class="line">        <span class="comment">//4、通过method1调用方法，即通过方法对象来实现调用方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">        method1.invoke(o);<span class="comment">//传统方法，是对象调用方法，这里反射是方法.invoke(对象)。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示反射Field 代表类的成员变量</span></span><br><span class="line">        <span class="comment">//得到name字段</span></span><br><span class="line">        <span class="comment">//getField不能得到私有的属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(name.get(o));  <span class="comment">//传统方法：对象.成员变量。反射就是成员变量.get(对象)。反过来的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Constructor类方法  代表类的构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = aClass.getConstructors();<span class="comment">//无参构造器，()中可以指定构造器参数类型</span></span><br><span class="line">        System.out.println(Arrays.toString(constructors));</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt;[] constructors1 = aClass.getConstructors(String.class);//这里传入的String.class就是Sting的类(class)对象 //由于JDK不一样这里不能单独调用某个构造函数，他直接给你全部显示出来了。</span></span><br><span class="line">        <span class="comment">//破案了，其实是我这里使用了getConstuctorsAPI是获得全部的构造器，当然里面就不能填参数</span></span><br><span class="line">        <span class="comment">//应使用</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors1 = aClass.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(constructors1));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">解释</mark> ：

<p>String.class可以返回一个代表String类的类对象（官方叫类类型，Class Type，因为Java里面万物皆对象，所以类其实也是一个对象）。类对象，官方给他取名<code>Class</code>所以就叫类对象。反射就是将这个类也变成对象，怎么用慢慢学。</p>
<p>反射调用也是反过来的，比如调用方法，<code>method.invoke(o);</code> ，方法调用对象。</p>
<h3 id="反射调用优化"><a href="#反射调用优化" class="headerlink" title="反射调用优化"></a><font color="#5cb85c">反射调用优化</font></h3><ul>
<li>反射优点和缺点</li>
</ul>
<ol>
<li>优点：可以动态的创建和使用对象(也是框架底层核心)，使用灵活，没有反射机制，框架技术就失去底层支撑。</li>
<li>缺点：使用反射基本是解释执行，对执行速度有影响。</li>
<li>应用实例：Reflection02.java</li>
</ol>
<ul>
<li>反射调用优化-关闭访问检查</li>
</ul>
<ol>
<li>Method和Field、Constructor对象都有setAccessible()方法</li>
<li>setAccessible作用是启动和禁用访问安全检查的开关</li>
<li>参数值为true表示反射的对象在使用时取消访问检查，提高反射效率。参数值为false则表示反射的对象执行访问检查</li>
</ol>
<p><img src="/images/image-20220823224554309.png" alt="image-20220823224554309"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflction02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        m1();<span class="comment">//5ms</span></span><br><span class="line">        m2();<span class="comment">//1196ms</span></span><br><span class="line">        m3();<span class="comment">//1074ms</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方法调用hi()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            cat.hi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;传统方法调用hi耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射机制调用hi()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.jth.question.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            method.invoke(o);<span class="comment">//Java万物皆对象，将方法变成对象，调用invoke方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方法调用hi耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.jth.question.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">false</span>); <span class="comment">//此方法在反射调用方法时候，取消访问检查</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            method.invoke(o);<span class="comment">//Java万物皆对象，将方法变成对象，调用invoke方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;优化反射方法调用hi耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Class类分析"><a href="#Class类分析" class="headerlink" title="Class类分析"></a><font color="#5cb85c">Class类分析</font></h3><ol>
<li>Class也是类，因此也继承Object类</li>
<li>Class类对象不是new出来的，而是系统创建的</li>
<li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成</li>
<li>通过Class可以完整地得到一个类的完整结构，通过一系列API</li>
<li>Class对象是存放在堆的</li>
<li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据(包括方法代码，变量名，方法名，访问权限等等)</li>
</ol>
<mark class="hl-label red">类图</mark> ：

<p><img src="/images/image-20220823231934277.png" alt="image-20220823231934277"></p>
<mark class="hl-label red">系统创建演示</mark> ：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//Class类图</span></span><br><span class="line">        <span class="comment">//1、Class也是类，因此继承Object类</span></span><br><span class="line">        <span class="comment">//Class</span></span><br><span class="line">        <span class="comment">//2、Class类对象不是new出来的，而是系统创建的</span></span><br><span class="line">        <span class="comment">//传统new对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;// name :com.jth.question.Cat</span></span><br><span class="line"><span class="comment">            return loadClass(name, false);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//反射方式</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.jth.question.Cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是反射方式还是传统的new方式，都会进入loadClass由系统完成创建。</p>
<p>第三点某个类的Class对象只会加载一次，即<code>new Cat()</code>下面反射创建对象的时候系统就不会再创建一次<code>loadClass()</code>。在堆内存里面只会存在一份。具体看原理图。</p>
<ul>
<li>Class类的常用方法</li>
</ul>
<p><img src="/images/image-20220825153546061.png" alt="image-20220825153546061"></p>
<mark class="hl-label red">原理图更新</mark> ：

<p><img src="/images/image-20220825155417333.png" alt="image-20220825155417333"></p>
<h3 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a><font color="#5cb85c">Class类常用方法</font></h3><p>见上表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.jth.Car&quot;</span>; <span class="comment">//类的全路径</span></span><br><span class="line">        <span class="comment">//获取到Car类对应的Class类</span></span><br><span class="line">        <span class="comment">//&lt;?&gt;表示不确定的Java类型</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(classAllPath);</span><br><span class="line">        System.out.println(aClass); <span class="comment">//显示aclass对象，是哪个类的Class对象，class com.jth.Car</span></span><br><span class="line">        System.out.println(aClass.getClass());<span class="comment">//输出运行类型 class java.lang.Class</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        System.out.println(car.getClass());<span class="comment">//运行类型class com.jth.Car</span></span><br><span class="line">        <span class="comment">//得到包名</span></span><br><span class="line">        System.out.println(aClass.getPackage().getName());<span class="comment">//com.jth getName用不用都可以，</span></span><br><span class="line">        <span class="comment">//得到全类名</span></span><br><span class="line">        System.out.println(aClass.getName());<span class="comment">//com.jth.Car</span></span><br><span class="line">        <span class="comment">//生成对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> (Car)o;</span><br><span class="line">        System.out.println(car1);<span class="comment">//调用toString</span></span><br><span class="line">        <span class="comment">//通过反射获取属性</span></span><br><span class="line">        <span class="comment">//name</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;name&quot;</span>);<span class="comment">//Field这里理解为字段</span></span><br><span class="line">        System.out.println(name.get(car1)); <span class="comment">//宝马</span></span><br><span class="line">        <span class="comment">//通过反射给属性设值</span></span><br><span class="line">        name.set(car1, <span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">        System.out.println(name.get(car1)); <span class="comment">//输出奔驰</span></span><br><span class="line">        <span class="comment">//获取所有字段(属性)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========所有字段的属性===========&quot;</span>);</span><br><span class="line">        Field[] fields = aClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.getName());<span class="comment">//属性字段的各个名称</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取Class对象六种方式"><a href="#获取Class对象六种方式" class="headerlink" title="获取Class对象六种方式"></a><font color="#5cb85c">获取Class对象六种方式</font></h3><ol>
<li>前提：已知一个类的全类名，且该类在路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException,实例：Class cls1 &#x3D; Class.forName(“java.lang.Cat”);<br>应用场景：多用于配置文件，读取类全路径，加载类。<br>全类名：包名和类名都知道。</li>
<li>前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高实例：Class cls2 &#x3D; Cat.class;<br>应用场景：多用于参数传递，比如通过反射得到对应构造器对象。</li>
<li>前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象，实例：Class class &#x3D; 对象.getClass();&#x2F;&#x2F;运行类型<br>应用场景：通过创建好的对象，获取Class对象。<br>这里也应证多态的运行类型看等号右边，<code>new</code>这部分</li>
<li>其他方式<br>ClassLoader cl &#x3D; 对象.getClass().getClassLoader();<br>Class class4 &#x3D; cl.loadClass(“类的全类名”);</li>
<li>基本数据(int, char, boolean, float, double, byte, long, short)按如下方式得到Class类对象<br>Class cls &#x3D; 基本数据类型.class</li>
<li>基本数据类型对应的包装类，可以通过.type得到Class类对象<br>Class cls &#x3D; 包装类.TYPE</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClass_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1、通过全类名获取Class对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.jth.Car&quot;</span>;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(classAllPath);</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、通过类名.class 获取Class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass3 = Car.class;</span><br><span class="line">        System.out.println(aClass3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、对象.getClass(),应用场景，有对象实例的时候</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Car</span>&gt; aClass1 = car.getClass();</span><br><span class="line">        System.out.println(aClass1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、通过类加载器(有四种)来获取到类的Class对象</span></span><br><span class="line">        <span class="comment">//先得到类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//通过类加载器得到Class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass2 = classLoader.loadClass(classAllPath);</span><br><span class="line">        System.out.println(aClass2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面的Class对象都是同一个对象，因为一个类只能有一个Class对象</span></span><br><span class="line">        System.out.println(aClass2.hashCode());</span><br><span class="line">        System.out.println(aClass.hashCode());</span><br><span class="line">        System.out.println(aClass1.hashCode());</span><br><span class="line">        System.out.println(aClass3.hashCode());<span class="comment">//得出结论hash值都是一样的</span></span><br><span class="line">        <span class="comment">//基本数据的类对象</span></span><br><span class="line">        Class&lt;Integer&gt; integerClass = <span class="type">int</span>.class;</span><br><span class="line">        System.out.println(integerClass);<span class="comment">//int   都有自动拆箱和装箱过程</span></span><br><span class="line">        Class&lt;Character&gt; characterClass = <span class="type">char</span>.class;</span><br><span class="line">        System.out.println(characterClass);<span class="comment">//char</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//基本数据类型的类对象</span></span><br><span class="line">        Class&lt;Integer&gt; integerClass1 = Integer.TYPE;</span><br><span class="line">        System.out.println(integerClass1); <span class="comment">//还是int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出hashcode</span></span><br><span class="line">        System.out.println(integerClass.hashCode());<span class="comment">//两者的hashcode一样</span></span><br><span class="line">        System.out.println(integerClass1.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所以说Integer 和int 在底层数据结构会 自动拆箱和装箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<mark class="hl-label red">原理图更新</mark> ：</p>
<p><img src="/images/image-20220825232936966.png" alt="image-20220825232936966"></p>
<h3 id="哪些类型有Class对象"><a href="#哪些类型有Class对象" class="headerlink" title="哪些类型有Class对象"></a><font color="#5cb85c">哪些类型有Class对象</font></h3><ul>
<li>如下类型有Class对象</li>
</ul>
<ol>
<li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>数组</li>
<li>enum：枚举</li>
<li>annotation：注解</li>
<li>基本数据类型</li>
<li>void</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllTypeClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;String&gt; Class1 = String.class; <span class="comment">//外部类</span></span><br><span class="line">        Class&lt;Serializable&gt; Class2 = Serializable.class; <span class="comment">//接口</span></span><br><span class="line">        Class&lt;Integer[]&gt; Class3 = Integer[].class; <span class="comment">//数组</span></span><br><span class="line">        Class&lt;<span class="type">float</span>[][]&gt; Class4 = <span class="type">float</span>[][].class; <span class="comment">//二维数组</span></span><br><span class="line">        Class&lt;Deprecated&gt; Class5 = Deprecated.class; <span class="comment">//注解</span></span><br><span class="line">        Class&lt;Thread.State&gt; Class6 = Thread.State.class; <span class="comment">//枚举</span></span><br><span class="line">        Class&lt;Long&gt; Class7 = <span class="type">long</span>.class; <span class="comment">//长整形，基本数据类型</span></span><br><span class="line">        Class&lt;Void&gt; Class8 = <span class="keyword">void</span>.class; <span class="comment">//void类型</span></span><br><span class="line">        Class&lt;Class&gt; Class9 = Class.class; <span class="comment">//Class类</span></span><br><span class="line">        System.out.println(Class1);</span><br><span class="line">        System.out.println(Class2);</span><br><span class="line">        System.out.println(Class3);</span><br><span class="line">        System.out.println(Class4);</span><br><span class="line">        System.out.println(Class5);</span><br><span class="line">        System.out.println(Class6);</span><br><span class="line">        System.out.println(Class7);</span><br><span class="line">        System.out.println(Class8);</span><br><span class="line">        System.out.println(Class9);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态和静态加载"><a href="#动态和静态加载" class="headerlink" title="动态和静态加载"></a><font color="#5cb85c">动态和静态加载</font></h3><ul>
<li>基本说明</li>
</ul>
<p>反射机制是Java实现动态语言的关键，也就是通过反射实现类动态加载。</p>
<ol>
<li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强。</li>
<li>动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性</li>
</ol>
<mark class="hl-label red">静态加载</mark> ：

<p>用文本编译器编写这样一段代码。</p>
<p>import java.util.*;<br>public class ClassLoad_ {<br>    public static void main(String[] args) {<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        System.out.println(“请输入Key”);<br>        String key &#x3D; scanner.next();<br>        switch(key) {<br>            case “1” :<br>                Dog dog &#x3D; new Dog();&#x2F;&#x2F;静态加载<br>                dog.cry();<br>                break;<br>            case “2” :<br>                System.out.println(“ok”);<br>                break;<br>            default :<br>                System.out.println(“do nothing”);<br>                break;<br>        }<br>    }<br>}</p>
<p>运行时候</p>
<p><img src="/images/image-20220827191810228.png" alt="image-20220827191810228"></p>
<p>可以看出，我们不一定会使用dog这个类，如果我们输入1以外的数字，但是这里会报错，说明是静态加载的。依赖性太强。</p>
<mark class="hl-label red">动态加载</mark> ：

<p>将代码改成（使用反射）：</p>
<p>import java.util.<em>;<br>import java.lang.reflect.</em>;<br>public class ClassLoad_ {<br>    public static void main(String[] args) throws Exception {<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        System.out.println(“请输入Key”);<br>        String key &#x3D; scanner.next();<br>        switch(key) {<br>            case “1” :<br>                &#x2F;&#x2F;Dog dog &#x3D; new Dog();<br>                &#x2F;&#x2F;dog.cry();<br>                break;<br>            case “2” :<br>                Class cls &#x3D; Class.forName(“Person”); &#x2F;&#x2F;使用反射加载Person类<br>                Object o &#x3D; cls.newInstance();<br>                Method m &#x3D; cls.getMethod(“hi”);<br>                m.invoke(o);<br>                System.out.println(“ok”);<br>                break;<br>            default :<br>                System.out.println(“do nothing”);<br>                break;<br>        }<br>    }<br>}</p>
<p>编译能够成功：</p>
<p><img src="/images/image-20220827194423016.png" alt="image-20220827194423016"></p>
<p><img src="/images/image-20220827194444835.png" alt="image-20220827194444835"></p>
<p>说明，反射机制是动态加载的，没有加载到时候并不会报错。加载到时候才加载。</p>
<ul>
<li>类加载时机</li>
</ul>
<ol>
<li>当创建对象时(new) &#x2F;&#x2F;静态加载</li>
<li>当子类被加载时 &#x2F;&#x2F;静态加载</li>
<li>调用类中的静态成员时 &#x2F;&#x2F;静态加载</li>
<li>通过反射 &#x2F;&#x2F;动态加载</li>
</ol>
<h3 id="类加载流程图"><a href="#类加载流程图" class="headerlink" title="类加载流程图"></a><font color="#5cb85c">类加载流程图</font></h3><p><img src="/images/image-20220827211524987.png" alt="image-20220827211524987"></p>
<p><img src="/images/image-20220827212227033.png" alt="image-20220827212227033"></p>
<mark class="hl-label red">分析</mark> ：

<p>加载和连接阶段由JVM机决定，初始化可以由代码控制，比如静态代码块等。</p>
<ul>
<li>加载阶段</li>
</ul>
<p>JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件，也可能是jar包，甚至网络)转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p>
<ul>
<li>连接阶段-验证</li>
</ul>
<ol>
<li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li>
<li>包括：文件格式验证（是否以魔数oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</li>
<li>可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。</li>
</ol>
<p>魔数验证：</p>
<p><img src="/images/image-20220829145650965.png" alt="image-20220829145650965"></p>
<ul>
<li>连接阶段-准备</li>
</ul>
<ol>
<li>JVM会在该阶段对静态变量，分配内存并初始化(对应数据类型的默认初始值如0、0L、null、false等)。这些变量所使用的内存都将在方法区中进行分配</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//属性-成员变量-字段</span></span><br><span class="line">    <span class="comment">//老韩分析类加载的链接阶段-准备， 属性是如何处理的</span></span><br><span class="line">    <span class="comment">//1、n1是实例属性，不是静态变量，因此在准备阶段，是不会分配内存的</span></span><br><span class="line">    <span class="comment">//2、n2是静态变量，分配内存n2是默认初始化0，而不是20</span></span><br><span class="line">    <span class="comment">//3、n3是static final是常量，他和静态变量不一样，因为他一旦赋值就不会变了n3 = 30</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>连接阶段-解析</li>
</ul>
<ol>
<li>虚拟机(JVM)将常量池内的符号引用替换为直接引用（内存地址引用）的过程</li>
</ol>
<p><img src="/images/image-20220829153210439.png" alt="image-20220829153210439"></p>
<ul>
<li>Initialization(初始化)</li>
</ul>
<ol>
<li>到初始化阶段，才真正开始执行类中定义的Java程序代码，此阶段是执行clinit()方法的过程。</li>
<li>clinit()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有<font color="#5cb85c">静态变量</font>的赋值动作和静态代码块中的语句，并进行合并。</li>
<li>虚拟机会保证一个类的clinit()方法在多线程环境中被<font color="C02C38">正确地加锁，同步</font>。如果多个 线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待，直到活动线程执行clinit()方法完毕</li>
</ol>
<h3 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a><font color="#5cb85c">通过反射获取类的结构信息</font></h3><p><img src="/images/image-20220829231642343.png" alt="image-20220829231642343"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Test.api_01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一组方法API</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1、获取Class对象</span></span><br><span class="line">        Class&lt;?&gt; person = Class.forName(<span class="string">&quot;com.jth.ReflectionUtils.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//得到全类名api</span></span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">        <span class="comment">//获取简单类名</span></span><br><span class="line">        System.out.println(person.getSimpleName());</span><br><span class="line">        <span class="comment">//得到所有public修饰的属性，也包括父类</span></span><br><span class="line">        Field[] fields = person.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类(没有父类)的所有属性</span></span><br><span class="line">        Field[] declaredFields = person.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            System.out.println(field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类及父类的public方法</span></span><br><span class="line">        Method[] methods = person.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类的所有方法</span></span><br><span class="line">        Method[] declaredMethods = person.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(declaredMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类所有public修饰器</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = person.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = person.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类&quot;</span> + declaredConstructor);<span class="comment">//上面使用getName就是只是输出名字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取包package ,返回包</span></span><br><span class="line">        System.out.println(<span class="string">&quot;包&quot;</span> + person.getPackage());</span><br><span class="line">        <span class="comment">//以Class形式返回父类信息</span></span><br><span class="line">        Class&lt;?&gt; superclass = person.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;父类&quot;</span> + superclass);</span><br><span class="line">        <span class="comment">//以Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = person.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接口信息&quot;</span> + anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        Annotation[] annotations = person.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有注解&quot;</span> + annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wuHu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String niuBi;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">w</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">wuHu</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">wuHu</span><span class="params">(String niuBi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.niuBi = niuBi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">wuHu</span> <span class="keyword">implements</span> <span class="title class_">A_</span>, B_&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sel;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A_</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B_</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220829233212094.png" alt="image-20220829233212094"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Field[] declaredFields1 = person.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : declaredFields1) &#123;</span><br><span class="line">    System.out.println(field.getName());<span class="comment">//成员变量名字</span></span><br><span class="line">    System.out.println(field.getModifiers()); <span class="comment">//该属性的修饰符用int表示,</span></span><br><span class="line">    <span class="comment">// 规则上图有。如果某一个成员变量有两个修饰符则返回的int值由这两个修饰符对应的int相加</span></span><br><span class="line">    System.out.println(field.getType()); <span class="comment">//该属性的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Methods对应的方法，用法和上面差不多<br>在getMethods下使用。</li>
</ul>
<p><img src="/images/image-20220829234006270.png" alt="image-20220829234006270"></p>
<ul>
<li>第四组构造器</li>
</ul>
<p><img src="/images/image-20220829234727466.png" alt="image-20220829234727466"></p>
<h3 id="反射暴破创建实例"><a href="#反射暴破创建实例" class="headerlink" title="反射暴破创建实例"></a><font color="#5cb85c">反射暴破创建实例</font></h3><ol>
<li>方式一：调用类中的public修饰的无参构造器</li>
<li>方式二：调用类中的指定构造器</li>
<li>Class类相关方法</li>
</ol>
<p>​	newInstance：调用类中的无参构造器，获取对应类的对象</p>
<p>​	getConstructor(Class…clazz):根据参数列表，获取对应的构造器对象</p>
<p>​	getDecalaredConstructor(Class…clazz):根据参数列表，获取对应的所有构造对象</p>
<ol start="4">
<li>Constructor类相关方法</li>
</ol>
<p>​	setAccessible:爆破</p>
<p>​	newInstance(Object…obj):调用构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1、先获取User类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; UserClass = Class.forName(<span class="string">&quot;com.jth.ReflectCreateInstance.User&quot;</span>);</span><br><span class="line">        <span class="comment">//2、通过public的无参构造器创建实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> UserClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="comment">//3、通过public的有参构造器创建对象</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = UserClass.getConstructor(<span class="type">int</span>.class, String.class); <span class="comment">//获取public构造器</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> constructor.newInstance(<span class="number">88</span>,<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        <span class="comment">//4、通过非public的有参构造器创建对象</span></span><br><span class="line">        Constructor&lt;?&gt; constructor1 = UserClass.getDeclaredConstructor(<span class="type">int</span>.class);<span class="comment">//获得所有类型的构造器</span></span><br><span class="line">        <span class="comment">//这也是反射的优点，正常情况new对象不能通过private的构造器。</span></span><br><span class="line">        constructor1.setAccessible(<span class="literal">true</span>);<span class="comment">//爆破，使用反射可以访问私有的private的构造器，反射面前都是纸老虎，破坏封装性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">90</span>);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;学习啊你在干什么&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射暴破操作属性"><a href="#反射暴破操作属性" class="headerlink" title="反射暴破操作属性"></a><font color="#5cb85c">反射暴破操作属性</font></h3><ul>
<li>访问属性</li>
</ul>
<ol>
<li>根据属性名获取Field对象<br>Field f &#x3D; clazz对象.getDeclaredField(属性名)；</li>
<li>暴破 ：f.setAccessible(true); &#x2F;&#x2F;f 是Field</li>
<li>访问<br>f.set(o,值)；<br>syso(f.get(o));</li>
<li>如果是静态属性，则set和get中的参数o，可以写成null。因为静态属性是和类相关，和对象无关</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1、创建Class对象</span></span><br><span class="line">        Class&lt;?&gt; Car = Class.forName(<span class="string">&quot;com.jth.Car&quot;</span>);</span><br><span class="line">        <span class="comment">//2、创建一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Car.getConstructor().newInstance(); <span class="comment">//直接newInstance()在jdk8以上已经被弃用</span></span><br><span class="line">        System.out.println(o.getClass()); <span class="comment">//class对象，也是运行类型 .. com.jth.Car</span></span><br><span class="line">        <span class="comment">//3、使用反射得到age属性对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> Car.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(o, <span class="number">999</span>); <span class="comment">//这就相当于将o这个对象的age属性设置成999</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(age.get(o)); <span class="comment">//通过属性得到对象的对应属性  结果是 999</span></span><br><span class="line">        <span class="comment">//4、使用反射操作name属性对象 (private的)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> Car.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//私有的属性操作会报错</span></span><br><span class="line">        <span class="comment">//需要使用暴破</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(o, <span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        System.out.println(name.get(o));</span><br><span class="line">        <span class="comment">//5、操作静态属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">color</span> <span class="operator">=</span> Car.getField(<span class="string">&quot;color&quot;</span>);</span><br><span class="line">        color.set(<span class="literal">null</span>, <span class="string">&quot;ss&quot;</span>);<span class="comment">//因为他是静态的，属于类的和对象无关，这里就无需填对象了</span></span><br><span class="line">        System.out.println(color.get(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">小结</mark> ：

<p>反射就是Class对象，就是类的一个反射（映射），在JVM机底层是一个个数组，使用Class相关API，可以操作很多东西。可以和对象相互指定，类包含对象。</p>
<h3 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a><font color="#5cb85c">通过反射访问类中的成员</font></h3><ul>
<li>访问方法</li>
</ul>
<ol>
<li>根据方法名和参数列表获取Method方法对象：Method m &#x3D; clazz.getDeclaredMethod(方法名， XX.class); &#x2F;&#x2F;得到</li>
<li>获取对象：Object o &#x3D; clazz.newInstance();</li>
<li>暴破：m.setAccessible(true);</li>
<li>访问：Object returnValue &#x3D; m.invoke(o, 实参列表);</li>
<li>注意：如果是静态方法，则invoke的参数o, 可以写成null!</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1、得到Car类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; Car = Class.forName(<span class="string">&quot;com.jth.Car&quot;</span>);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Car.newInstance();</span><br><span class="line">        <span class="comment">//调用方法public m1</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> Car.getDeclaredMethod(<span class="string">&quot;m1&quot;</span>, String.class);</span><br><span class="line">        m1.invoke(o, <span class="string">&quot;hah&quot;</span>); <span class="comment">//这里可以理解为这个m1方法指向对象o,因为由很多个对象。很好理解。</span></span><br><span class="line">        <span class="comment">//调用private static m2方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> Car.getDeclaredMethod(<span class="string">&quot;m2&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        m2.setAccessible(<span class="literal">true</span>); <span class="comment">//暴破private</span></span><br><span class="line">        m2.invoke(o, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//这里o也可以不写，因为他是static的 静态的。属于类的不用指向某个对象。</span></span><br><span class="line">        m2.invoke(<span class="literal">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//在反射中，如果有返回值，统一返回Object</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">Value</span> <span class="operator">=</span> m2.invoke(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Value.getClass());<span class="comment">//运行类型是 Integer 是和方法定义的返回类型值是一样的</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">大结</mark> ：

<p>这里的<code>invoke</code>方法很能证明，Class对象就是类的一个映射，invoke方法参数需要指向某个对象才行。不然不知道是那个对象调用了这个方法。就如：<code>newInstance</code>多搞几个实例就很体现。</p>
<h3 id="反射练习"><a href="#反射练习" class="headerlink" title="反射练习"></a><font color="#5cb85c">反射练习</font></h3><ul>
<li>练习1：通过反射修改私有成员变量</li>
</ul>
<ol>
<li>定义PrivateTest类，有私有name属性，并且属性值hellokitty</li>
<li>提供getName的公有方法</li>
<li>创建PrivateTest的类，利用Class类得到私有的name属性，修改私有的name属性值，并调用getName()的方法打印name属性值</li>
</ol>
<p><img src="/images/image-20220830202853605.png" alt="image-20220830202853605"></p>
<ul>
<li>练习2利用反射和File完成以下功能</li>
</ul>
<ol>
<li>利用Class类的forName方法得到File类的Class对象</li>
<li>在控制台打印File类的所有构造器</li>
<li>通过newInstance的方法创建File对象，并创建E:&#x2F;myNew.txt文件</li>
</ol>
</String></String></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://github.com/xiaojingangxiaoxiang/xiaojingangxiaoxiang.github.io">金腾欢</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/xiaojingangxiaoxiang/xiaojingangxiaoxiang.github.io/2022/05/12/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/">https://github.com/xiaojingangxiaoxiang/xiaojingangxiaoxiang.github.io/2022/05/12/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/xiaojingangxiaoxiang/xiaojingangxiaoxiang.github.io" target="_blank">Lollipop</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/images/wechat.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/27/%E6%97%A5%E8%AE%B0/"><img class="prev-cover" src="/img/preview2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">日记--随想录</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/01/MyFirst-ChromeExtention/"><img class="next-cover" src="/images/chromeExtention.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyFirst-ChromeExtention</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/24/Java%E4%B8%BA%E6%95%B0%E4%B8%8D%E5%A4%9A%E7%9A%84%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/" title="Java为数不多的重载运算符"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-24</div><div class="title">Java为数不多的重载运算符</div></div></a></div><div><a href="/2022/11/15/Java%E5%8F%98%E9%87%8F%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96/" title="Java变量何时需要初始化"><img class="cover" src="/img/f513b8fc1293ce694c62fc1d6e2d0979386e1394.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">Java变量何时需要初始化</div></div></a></div><div><a href="/2023/03/03/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/" title="Spring如何解决循环依赖问题"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-03</div><div class="title">Spring如何解决循环依赖问题</div></div></a></div><div><a href="/2022/08/11/%E5%85%B3%E4%BA%8E%E5%AD%90%E5%A4%AB%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/" title="关于子父类初始化问题"><img class="cover" src="/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-11</div><div class="title">关于子父类初始化问题</div></div></a></div><div><a href="/2022/07/30/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%AD%89%E5%8F%8A%E5%AD%90%E7%88%B6%E7%B1%BB%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" title="代码执行顺序--静态代码块、构造方法等及子父类相关问题"><img class="cover" src="/img/29.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-30</div><div class="title">代码执行顺序--静态代码块、构造方法等及子父类相关问题</div></div></a></div><div><a href="/2022/06/07/%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/" title="坦克大战"><img class="cover" src="/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-07</div><div class="title">坦克大战</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-JRE-JVM"><span class="toc-number">1.1.</span> <span class="toc-text">JDK JRE JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text">自动类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">强制类型转化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">String和其他类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%88%90String"><span class="toc-number">1.4.1.</span> <span class="toc-text">其他类型转换成String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">String 转换成其他类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81"><span class="toc-number">1.5.</span> <span class="toc-text">原码 反码 补码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E4%BD%99"><span class="toc-number">1.6.</span> <span class="toc-text">求余%</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#While%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.7.</span> <span class="toc-text">While循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BA"><span class="toc-number">1.8.1.</span> <span class="toc-text">动态创建静态创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">动态创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BA"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">静态创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.2.</span> <span class="toc-text">数组数据传递机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.9.</span> <span class="toc-text">数组算法：双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.10.</span> <span class="toc-text">一些数组排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.10.1.</span> <span class="toc-text">冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">Java函数方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.11.1.</span> <span class="toc-text">方法的调用机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3"><span class="toc-number">1.11.2.</span> <span class="toc-text">递归思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%8E%E8%81%94%E7%B3%BB"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">递归与循环的区别于联系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8-%E9%87%8D%E8%BD%BD%E7%B1%BB%E4%BC%BC%E5%8D%87%E7%BA%A7"><span class="toc-number">1.12.</span> <span class="toc-text">可变参数的使用(重载类似升级)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.13.</span> <span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%87%BA"><span class="toc-number">1.13.1.</span> <span class="toc-text">问题引出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%A5%E9%97%A8"><span class="toc-number">1.13.2.</span> <span class="toc-text">this入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.13.3.</span> <span class="toc-text">this本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%B0%8F%E7%BB%93"><span class="toc-number">1.13.4.</span> <span class="toc-text">this小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">1.13.5.</span> <span class="toc-text">this使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.14.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">1.14.1.</span> <span class="toc-text">继承原理示意图:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.15.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.15.1.</span> <span class="toc-text">向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.15.2.</span> <span class="toc-text">向下转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">1.15.3.</span> <span class="toc-text">动态绑定机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-%E7%B1%BB"><span class="toc-number">1.16.</span> <span class="toc-text">Object 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.16.1.</span> <span class="toc-text">&#x3D;&#x3D;比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95"><span class="toc-number">1.16.2.</span> <span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode%E6%96%B9%E6%B3%95"><span class="toc-number">1.16.3.</span> <span class="toc-text">hashcode方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-number">1.16.4.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-%E5%B7%B2%E5%BC%83%E7%94%A8"><span class="toc-number">1.16.5.</span> <span class="toc-text">finalize(已弃用)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.17.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%821"><span class="toc-number">1.17.1.</span> <span class="toc-text">抽象类使用细节1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%822"><span class="toc-number">1.17.2.</span> <span class="toc-text">抽象类的使用细节2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%AF%BE%E5%A0%82%E7%BB%83%E4%B9%A0"><span class="toc-number">1.17.3.</span> <span class="toc-text">抽象类课堂练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.17.4.</span> <span class="toc-text">抽象模板模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.18.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">1.18.1.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E5%A0%82%E7%BB%83%E4%B9%A0"><span class="toc-number">1.18.2.</span> <span class="toc-text">课堂练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3VS%E7%BB%A7%E6%89%BF"><span class="toc-number">1.18.3.</span> <span class="toc-text">接口VS继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-Exception"><span class="toc-number">1.19.</span> <span class="toc-text">异常-Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.19.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.19.2.</span> <span class="toc-text">异常体系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.20.</span> <span class="toc-text">事件处理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E5%A4%A7Wrapper-%E5%8C%85%E8%A3%85-%E7%B1%BB"><span class="toc-number">1.21.</span> <span class="toc-text">八大Wrapper(包装)类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.21.1.</span> <span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">1.21.2.</span> <span class="toc-text">装箱和拆箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.22.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.22.1.</span> <span class="toc-text">集合介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.22.2.</span> <span class="toc-text">集合体系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E6%96%B9%E6%B3%95"><span class="toc-number">1.22.3.</span> <span class="toc-text">Collection方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86"><span class="toc-number">1.22.4.</span> <span class="toc-text">迭代器遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.22.5.</span> <span class="toc-text">List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%81%8D%E5%8E%86"><span class="toc-number">1.22.5.1.</span> <span class="toc-text">List遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.22.5.2.</span> <span class="toc-text">ArrayList的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.22.5.3.</span> <span class="toc-text">ArrayList扩容机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81"><span class="toc-number">1.22.5.4.</span> <span class="toc-text">ArrayList底层源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.22.5.5.</span> <span class="toc-text">Vector注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">1.22.5.6.</span> <span class="toc-text">Vector源码解读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.22.5.7.</span> <span class="toc-text">LinkedList底层结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList%E6%BA%90%E7%A0%81"><span class="toc-number">1.22.5.8.</span> <span class="toc-text">LinkedList源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E9%80%89%E6%8B%A9"><span class="toc-number">1.22.6.</span> <span class="toc-text">List集合选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">1.23.</span> <span class="toc-text">Set接口方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E5%85%A8%E9%9D%A2%E8%AF%B4%E6%98%8E"><span class="toc-number">1.23.1.</span> <span class="toc-text">HashSet全面说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.23.2.</span> <span class="toc-text">HashSet扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">1.23.3.</span> <span class="toc-text">HashSet源码解读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.24.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.24.1.</span> <span class="toc-text">线程相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.24.2.</span> <span class="toc-text">线程的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFStart"><span class="toc-number">1.24.3.</span> <span class="toc-text">为什么是Start();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%94%AE%E7%A5%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.24.4.</span> <span class="toc-text">多线程售票系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">1.24.5.</span> <span class="toc-text">线程终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-number">1.24.6.</span> <span class="toc-text">线程中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.24.7.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%83%E5%A4%A7%E7%8A%B6%E6%80%81"><span class="toc-number">1.24.8.</span> <span class="toc-text">线程七大状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.24.9.</span> <span class="toc-text">线程同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.24.10.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">1.24.11.</span> <span class="toc-text">线程死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.24.12.</span> <span class="toc-text">释放锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O%E6%B5%81"><span class="toc-number">1.25.</span> <span class="toc-text">I&#x2F;O流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.25.1.</span> <span class="toc-text">文件基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.25.2.</span> <span class="toc-text">常用的文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">1.25.3.</span> <span class="toc-text">IO流原理和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E4%BD%93%E7%B3%BB%E5%9B%BE-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">1.25.4.</span> <span class="toc-text">IO流体系图-常用的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInputStream"><span class="toc-number">1.25.4.1.</span> <span class="toc-text">FileInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileOutputStream"><span class="toc-number">1.25.4.2.</span> <span class="toc-text">FileOutputStream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.25.5.</span> <span class="toc-text">文件的拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.25.6.</span> <span class="toc-text">文件字符流说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileReader"><span class="toc-number">1.25.6.1.</span> <span class="toc-text">FileReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileWriter"><span class="toc-number">1.25.6.2.</span> <span class="toc-text">FileWriter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">1.25.7.</span> <span class="toc-text">节点流和处理流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.25.7.1.</span> <span class="toc-text">处理流设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffered"><span class="toc-number">1.25.8.</span> <span class="toc-text">Buffered</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedReader"><span class="toc-number">1.25.8.1.</span> <span class="toc-text">BufferedReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bufferedwriter"><span class="toc-number">1.25.8.2.</span> <span class="toc-text">Bufferedwriter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffered%E5%AD%97%E8%8A%82%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">1.25.9.</span> <span class="toc-text">Buffered字节处理流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.25.10.</span> <span class="toc-text">对象流(序列化)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectOutputStream"><span class="toc-number">1.25.10.1.</span> <span class="toc-text">ObjectOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectInputStream"><span class="toc-number">1.25.10.2.</span> <span class="toc-text">ObjectInputStream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E6%B5%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.25.11.</span> <span class="toc-text">对象处理流的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.25.12.</span> <span class="toc-text">标准输入输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">1.25.13.</span> <span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStreamReader"><span class="toc-number">1.25.13.1.</span> <span class="toc-text">InputStreamReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutputStreamReader"><span class="toc-number">1.25.13.2.</span> <span class="toc-text">OutputStreamReader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrintStream"><span class="toc-number">1.25.14.</span> <span class="toc-text">PrintStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrintWriter"><span class="toc-number">1.25.15.</span> <span class="toc-text">PrintWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties"><span class="toc-number">1.25.16.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#properties%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.25.17.</span> <span class="toc-text">properties读文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#properties%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6"><span class="toc-number">1.25.18.</span> <span class="toc-text">properties修改文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.25.19.</span> <span class="toc-text">IO流作业</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.26.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.26.1.</span> <span class="toc-text">网络相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">1.26.2.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.26.3.</span> <span class="toc-text">域名和端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.26.4.</span> <span class="toc-text">网络协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%92%8CUDP"><span class="toc-number">1.26.5.</span> <span class="toc-text">TCP和UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InetAddress%E7%B1%BB"><span class="toc-number">1.26.6.</span> <span class="toc-text">InetAddress类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket"><span class="toc-number">1.26.7.</span> <span class="toc-text">Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%AD%97%E8%8A%82%E6%B5%81%E7%BC%96%E7%A8%8B"><span class="toc-number">1.26.7.1.</span> <span class="toc-text">TCP字节流编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%AD%97%E7%AC%A6%E6%B5%81%E7%BC%96%E7%A8%8B"><span class="toc-number">1.26.7.2.</span> <span class="toc-text">TCP字符流编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6"><span class="toc-number">1.26.7.3.</span> <span class="toc-text">网络上传文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netstat%E6%8C%87%E4%BB%A4"><span class="toc-number">1.26.7.4.</span> <span class="toc-text">netstat指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%A7%98%E5%AF%86"><span class="toc-number">1.26.7.5.</span> <span class="toc-text">TCP连接秘密</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%BC%96%E7%A8%8B-%E4%BA%86%E8%A7%A3"><span class="toc-number">1.26.8.</span> <span class="toc-text">UDP编程(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.26.9.</span> <span class="toc-text">网络编程作业</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.27.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">1.27.1.</span> <span class="toc-text">反射原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">1.27.2.</span> <span class="toc-text">反射相关类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-number">1.27.3.</span> <span class="toc-text">反射调用优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E7%B1%BB%E5%88%86%E6%9E%90"><span class="toc-number">1.27.4.</span> <span class="toc-text">Class类分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.27.5.</span> <span class="toc-text">Class类常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.27.6.</span> <span class="toc-text">获取Class对象六种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E6%9C%89Class%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.27.7.</span> <span class="toc-text">哪些类型有Class对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.27.8.</span> <span class="toc-text">动态和静态加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.27.9.</span> <span class="toc-text">类加载流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="toc-number">1.27.10.</span> <span class="toc-text">通过反射获取类的结构信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9A%B4%E7%A0%B4%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.27.11.</span> <span class="toc-text">反射暴破创建实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9A%B4%E7%A0%B4%E6%93%8D%E4%BD%9C%E5%B1%9E%E6%80%A7"><span class="toc-number">1.27.12.</span> <span class="toc-text">反射暴破操作属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">1.27.13.</span> <span class="toc-text">通过反射访问类中的成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%BB%83%E4%B9%A0"><span class="toc-number">1.27.14.</span> <span class="toc-text">反射练习</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 金腾欢</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">出发 永远是最有意义的事</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'RfBgbSPW5aO9c73Oft6Tcdvs-9Nh9j0Va',
      appKey: 'oijtmJslB82SgAEA5twOHVzN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/pluginsSrc/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="7495899328" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><canvas class="fireworks" mobile="true"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="/pluginsSrc/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="/pluginsSrc/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/aplayer/dist/APlayer.min.js"></script><script src="/pluginsSrc/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="/pluginsSrc/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>