<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaWeb</title>
    <url>/2022/09/01/JavaWeb/</url>
    <content><![CDATA[<h2 id="CS和BS的异同点"><a href="#CS和BS的异同点" class="headerlink" title="CS和BS的异同点"></a>CS和BS的异同点</h2><p><img src="/images/image-20220901200621183.png" alt="image-20220901200621183"></p>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p><img src="/images/image-20220904174047101.png" alt="image-20220904174047101"></p>
<p>localhost:8080是默认网址。</p>
<p>通过网址可以访问不同主机的tomcat。</p>
<p>通过context root 访问不同项目。</p>
<h2 id="Idea配置Tomcat"><a href="#Idea配置Tomcat" class="headerlink" title="Idea配置Tomcat"></a>Idea配置Tomcat</h2><p><img src="/images/image-20220904200149550.png" alt="image-20220904200149550"></p>
<p>不同版本idea配置不同，具体可百度。</p>
<p>教程：<a href="https://www.bilibili.com/video/BV1AS4y177xJ?p=20&amp;vd_source=965a4445e7b07ab5faef9dc78ccf37a7">https://www.bilibili.com/video/BV1AS4y177xJ?p=20&amp;vd_source=965a4445e7b07ab5faef9dc78ccf37a7</a></p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2>]]></content>
  </entry>
  <entry>
    <title>Javascript笔记随笔</title>
    <url>/2022/04/20/Javascript%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java为数不多的重载运算符</title>
    <url>/2023/02/24/Java%E4%B8%BA%E6%95%B0%E4%B8%8D%E5%A4%9A%E7%9A%84%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>重载运算符就是改变原来运算符的意义。</p>
<h3 id="Java为数不多的重载运算符"><a href="#Java为数不多的重载运算符" class="headerlink" title="Java为数不多的重载运算符"></a>Java为数不多的重载运算符</h3><p>“+”和”+&#x3D;”是Java专门为String类重载的运算符。可能是由于String字符串用的多，并且直接用字符串拼接的十分影响性能。Java就专门为这个String重载运算符。</p>
<p>字符串通过+和+&#x3D;字符串拼接，其实内部是创建了一个StringBuilder类（线程不安全的），调用内部的<code>append()</code>方法。最后用<code>toString()</code></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>想要多次拼接的时候，Java并不会智能的只创建一个StringBuilder类，而是每一次使用+号拼接。都会在内部创建一个StringBuiler对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20230301233809525.png" alt="image-20230301233809525"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在多次使用字符串拼接的时候需要手动创建StringBuilder类。只需一次拼接的，不用手动创建StringBuilder类。在高并发下使用StringBuffer类。</p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java变量何时需要初始化</title>
    <url>/2022/11/15/Java%E5%8F%98%E9%87%8F%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="不用显式初始化的变量"><a href="#不用显式初始化的变量" class="headerlink" title="不用显式初始化的变量"></a>不用显式初始化的变量</h1><h2 id="JVM自动分配默认值"><a href="#JVM自动分配默认值" class="headerlink" title="JVM自动分配默认值"></a>JVM自动分配默认值</h2><p>对于类的成员变量，不管有没有对他进行显式初始化，JVM会给他默认值</p>
<p><img src="/images/image-20221115230809617.png" alt="image-20221115230809617"></p>
<h2 id="不用于计算"><a href="#不用于计算" class="headerlink" title="不用于计算"></a>不用于计算</h2><p>常在交换两个索引的位置啊，一些只用于接收或者暂存的变量，无需初始化。</p>
<p>比如下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> temp; <span class="comment">//这里无需给temp初始化，他只是接收a+b的结果,即使他是局部变量。</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	temp = a + b;</span><br><span class="line">	System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="需要显式初始化的变量"><a href="#需要显式初始化的变量" class="headerlink" title="需要显式初始化的变量"></a>需要显式初始化的变量</h1><p>1.局部变量</p>
<p>2.用于计算需要用到值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a; <span class="comment">//这里的a和b既是局部变量也需要用于计算。那么就需要手动的显式初始化。</span></span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	System.out.println(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要用到这个变量的值的时候，并且JVM没有给你初始化的时候。这时就需要手动的显式初始化。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>变量</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java重载和重写的一些小细节</title>
    <url>/2023/02/24/Java%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>Java作为纯面向对象的语言，继承是再熟悉不过了。不过还是有一些细节在平时不回去注意，用到的场景也比较少。也是随着框架技术的成熟，解耦越来越强。许多底层代码都很少再去注意。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>Java修饰符如下图所示:</p>
<p><img src="/images/xiushifu.png" alt="在这里插入图片描述"></p>
<p>Java子类重写父类的方法，修饰符范围扩大范围，即降低限制。可以这样理解，子类是对父类的拓展和增强。所以修饰扩大能更好使得父类的方法变强。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>子类的重写只能抛出范围更小的异常，还是子类方法是对父类的增强， 应该异常要不父类小。</p>
<h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><p>返回类型应该更强精确和范围小(返回的类型是原来的子类或者更小类型等)。</p>
<h3 id="发生阶段"><a href="#发生阶段" class="headerlink" title="发生阶段"></a>发生阶段</h3><p>运行期，为什么是运行期。如果没有@Override注释。你即使在子类写了不符合规则的继承方法，也不会报错。而@Override这个注释就是帮你检查和提高可读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">f1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">f1</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过举例来记忆。比如:Object的Clone方法，访问修饰符是Protected，需要子类重写，并将访问修饰符改成public，才能正常使用。</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>重载必须是在同一个类中，方法名必须相同，参数列表必须更改，可以是可变数组类型。相较于重写，异常、访问修饰符、返回类型都没有做严格要求可修改和不修改都可。<font color="red">发生阶段</font>:编译期。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="/images/image-20230301002202227.png" alt="image-20230301002202227"></p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>Java复习</tag>
        <tag>细节</tag>
      </tags>
  </entry>
  <entry>
    <title>MyFirst-ChromeExtention</title>
    <url>/2022/05/01/MyFirst-ChromeExtention/</url>
    <content><![CDATA[<hr>
<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p>该chrome主要有两方面功能和两种展现方式: <font color="#f89996"><strong>popup</strong> </font>和<font color="#f89996"><strong>option</strong></font>。<br>成功安装时，会跳转到B站<strong>A-SOUL_Official</strong>个人空间  </p>
<h2 id="popop"><a href="#popop" class="headerlink" title="popop"></a>popop</h2><p>将插件置顶后<font color="#f89996"><strong>左键</strong></font>单击调用出popup窗口，可以看见有一个按钮和输入框: 点击按钮后会根据当前按钮<br>的颜色来改变当前浏览器的<font color="#f89996"><strong>背景颜色</strong></font>。 输入框是记录键盘输入的文字，并在上面<font color="#f89996"><strong>红色小条</strong></font>中显示。<br>注意: 关闭popup页面后输入的文字不会被保存。</p>
<h2 id="option"><a href="#option" class="headerlink" title="option"></a>option</h2><p>右键置顶的插件，并选中<font color="#f89996"><strong>选项</strong></font>跳转到选项页面，其中有五个按钮供选择，来更改popup页面中的按钮颜色。  </p>
<h2 id="图片更改"><a href="#图片更改" class="headerlink" title="图片更改"></a>图片更改</h2><p>在根目录中找到<code>popup.html</code>文件，找到<code>img</code>更改<font color="#f89996"><strong>popup</strong></font>窗口对应的图片<br>相应的找到<code>option.html</code>文件，更改<font color="#f89996"><strong>option</strong></font>窗口对应的图片</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Chrome Extention</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据库</title>
    <url>/2022/09/04/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="数据库的作用"><a href="#数据库的作用" class="headerlink" title="数据库的作用"></a>数据库的作用</h1><ul>
<li>问题</li>
</ul>
<p><img src="/images/image-20220904202508844.png" alt="image-20220904202508844"></p>
<ul>
<li>解决之道</li>
</ul>
<p>为了解决上述问题，使用更加利于管理数据的东西-数据库，它能更有效的管理数据。</p>
<p>例子：</p>
<p>如果说图书馆是保存书籍的，那么数据库就是保存数据的。</p>
<p><img src="/images/image-20220904203216903.png" alt="image-20220904203216903"></p>
<h1 id="命令行连接到Mysql"><a href="#命令行连接到Mysql" class="headerlink" title="命令行连接到Mysql"></a>命令行连接到Mysql</h1><p><img src="/images/image-20220906210857655.png" alt="image-20220906210857655"></p>
<p>可以看出mysql是一个服务，服务就需要用一个端口。在配置文件中my.ini有具体端口配置。</p>
<p><img src="/images/image-20220906211334693.png" alt="image-20220906211334693"></p>
<p><img src="/images/image-20220906212119479.png" alt="image-20220906212119479"></p>
<p>演示：</p>
<p><img src="/images/image-20220906213002187.png" alt="image-20220906213002187"></p>
<p>这个localhost：在有网络的情况，会自动解析localhost为127.0.0.1，而断网的情况下，localhost只是一个字符串，不代表一个ip地址。mysql配置文件的存储在hosts文件中，其位置在：</p>
<p>Windows：c:\windows\system32\drives\etc\hosts<br>linux：&#x2F;etc&#x2F;hosts</p>
<p>配置文件内容如下：可看到localhost的主机ip设置为127.0.0.1。</p>
<p><img src="/images/image-20220906213208407.png" alt="image-20220906213208407"></p>
<h1 id="MySQL三层结构"><a href="#MySQL三层结构" class="headerlink" title="MySQL三层结构"></a>MySQL三层结构</h1><p><img src="/images/image-20220906221631259.png" alt="image-20220906221631259"></p>
<p>图解：</p>
<p><img src="/images/image-20220906221558766.png" alt="image-20220906221558766"></p>
<p><img src="/images/image-20220906221819644.png" alt="image-20220906221819644"></p>
<p><img src="/images/image-20220906221945130.png" alt="image-20220906221945130"></p>
<h1 id="Java操作Mysql"><a href="#Java操作Mysql" class="headerlink" title="Java操作Mysql"></a>Java操作Mysql</h1><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><img src="/images/image-20220907145716337.png" alt="image-20220907145716337"></p>
<p><img src="/images/image-20220907153717597.png" alt="image-20220907153717597"></p>
<p>解释：默认的校对规则是不区分大小写的，在上面选择jth02数据库的时候，会检测出两个对象，utf8_bin是区分大小写的。</p>
<h2 id="查看、删除数据库"><a href="#查看、删除数据库" class="headerlink" title="查看、删除数据库"></a>查看、删除数据库</h2><p><img src="/images/image-20220907153903823.png" alt="image-20220907153903823"></p>
<p><img src="/images/image-20220907210545187.png" alt="image-20220907210545187"></p>
<h2 id="备份恢复数据库"><a href="#备份恢复数据库" class="headerlink" title="备份恢复数据库"></a>备份恢复数据库</h2><p><img src="/images/image-20220907200804340.png" alt="image-20220907200804340"></p>
<p><img src="/images/image-20220907210611029.png" alt="image-20220907210611029"></p>
<h2 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h2><p><img src="/images/image-20220907202845387.png" alt="image-20220907202845387"></p>
<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p><img src="/images/image-20220907205205515.png" alt="image-20220907205205515"></p>
<h1 id="列类型有哪些（常用数据类型）"><a href="#列类型有哪些（常用数据类型）" class="headerlink" title="列类型有哪些（常用数据类型）"></a>列类型有哪些（常用数据类型）</h1><p>结合老韩笔记</p>
<p>常用数据类型：</p>
<p><img src="/images/image-20220908114059966.png" alt="image-20220908114059966"></p>
<p><img src="/images/image-20220908114144745.png" alt="image-20220908114144745"></p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Reids项目学习小结</title>
    <url>/2023/02/24/Reids%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring IOC 学习小结</title>
    <url>/2022/10/18/Spring-IOC-%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h1><p>概念：IOC(Inversion Of Control)即控制反转，把创建对象和对象之间的调用交给Spring完成。</p>
<p>目的：降低代码之间的耦合度。</p>
<p>底层原理:</p>
<p>​	1、反射</p>
<p>​	2、工厂设计模式</p>
<p>​	3、xml解析</p>
<h1 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h1><p>依赖注入DI(Dependency Injection) </p>
<p>两种方式：</p>
<p>​	1、set方式注入</p>
<p><img src="/images/image-20221018114251812.png" alt="image-20221018114251812"></p>
<p>​	2、构造器注入</p>
<p><img src="/images/image-20221018114316500.png" alt="image-20221018114316500"></p>
<p>如果注入的属性是另外一个对象时候，使用ref外连接其在xml创建的bean对象。</p>
<p><img src="/images/image-20221018114126633.png" alt="image-20221018114126633"></p>
<p>也可内部bean就是嵌套，在里面的bean对象</p>
<p>或者使用类.对象，这个需要让这个属性有get方法。</p>
<p><img src="/images/image-20221018114531222.png" alt="image-20221018114531222"></p>
<p>集合注入:在配置文件中设置对应的标签即可</p>
<p><img src="/images/image-20221018114622500.png" alt="image-20221018114622500"></p>
<h2 id="Spring容器和被管理的bean："><a href="#Spring容器和被管理的bean：" class="headerlink" title="Spring容器和被管理的bean："></a>Spring容器和被管理的bean：</h2><p>Spring核心接口BeanFactory和ApplicationContext，其中ApplicationContext是BeanFactory的子接口。他们都可以代表Spring容器。</p>
<p><img src="/images/image-20221018115026386.png" alt="image-20221018115026386"></p>
<p>一般开发者使用ApplicationContext，BeanFactory是Spring内部使用的。</p>
<p>BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</p>
<p>上面层结构图看到有两个实现子类，FileSystem.*使用的是绝对路径</p>
<p>ClassPathXmlApp*则使用的是全类名，基于src目录下的。</p>
<p>被管理的bean</p>
<p>也有两种，一种普通bean，另外一种工厂bean（FactoryBean）</p>
<h2 id="留疑"><a href="#留疑" class="headerlink" title="留疑"></a>留疑</h2><h3 id="ApplicationContext的事件机制"><a href="#ApplicationContext的事件机制" class="headerlink" title="ApplicationContext的事件机制"></a>ApplicationContext的事件机制</h3><p>ApplicationContext事件机制是基于观察者设计模式实现的。通过ApplicationEvent类和ApplicationListener接口.</p>
<ul>
<li>ApplicationEvent：容器事件，必须由ApplicationContext发布；</li>
<li>ApplicationListener：监听器，可有容器内的任何监听器Bean担任。</li>
</ul>
<h3 id="容器中bean的作用域："><a href="#容器中bean的作用域：" class="headerlink" title="容器中bean的作用域："></a>容器中bean的作用域：</h3><p>singleton：单例模式，在整个Spring IOC，使用singleton定义的bean将只有一个实例；<br>具体可看Spring5笔记<br><img src="/images/image-20221018232913322.png" alt="image-20221018232913322"></p>
<p><img src="/images/image-20221018232927649.png" alt="image-20221018232927649"></p>
<p>设置的是配置文件中bean标签的scope属性。</p>
<p>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新实例；</p>
<p>request：对于每次HTTP请求中，使用request定义的bean都将产生一个新实例，只有在web应用程序使用Spring时，该作用域才有效；</p>
<p>session：同理<br>global session：同理</p>
<p><strong>注意：request和session作用域只在web应用中才生效，并且必须在web应用中增加额外的配置才会生效，为了让request，session两个作用域生效，必须将HTTP请求对象绑定到为该请求提供服务的线程上，这使得具有request和session作用域的Bean实例能够在后面的调用链中被访问。</strong></p>
<p>Web的域对象，讲究一个作用范围和生命周期。<font color="red">这些暂时没有配置过</font>。</p>
<p>当支持Servlet2.4及以上规范的web容器时，我们可以在web应用的web.<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020">xml</a>增加如下Listener配置，该Listener负责为request作用域生效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<p>如果仅使用了支持Servlet2.4以前规范的web容器，则该容器不支持Listener规范，故无法使用这种配置，可以使用Filter配置方式，我们可以在web应用的web.xml增加如下Filter配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;</span><br><span class="line">     &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;  </span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<p>JavaEE规范中的 filter 和listener。</p>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>1、通过构造器创建bean实例(无参数构造器)</p>
<p>2、为bean的属性设置值和对其他bean引用(调用set方法)</p>
<p>3、bean初始化(自己设定方法，然后通过配置文件指定)</p>
<p>4、获取对象()注意获取对象和对象生成的区别，就是之前单例模式和多个bean对象的区别</p>
<p>5、销毁方法也是由配置文件指定</p>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>使用注解注入 需要开启组件扫描</p>
<p>具体看笔记吧</p>
<h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><p>创建一个类，然后用上注解@Configuration,将这个类当作配置类</p>
<p>也需要开启组件扫描@ComponentScan</p>
]]></content>
      <categories>
        <category>课程小结</category>
        <category>控制反转</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC视图源码</title>
    <url>/2022/11/14/SpringMVC%E8%A7%86%E5%9B%BE%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p><img src="/images/SpringMVC%E8%A7%86%E5%9B%BE%E6%BA%90%E7%A0%81.png" alt="SpringMVC视图源码"></p>
<h2 id="补充，当视图名称没有前缀的时候，会被配置文件中配置的视图解析器解析。这里配置的是Thymeleaf。所以就被ThymeleafView解析。"><a href="#补充，当视图名称没有前缀的时候，会被配置文件中配置的视图解析器解析。这里配置的是Thymeleaf。所以就被ThymeleafView解析。" class="headerlink" title="补充，当视图名称没有前缀的时候，会被配置文件中配置的视图解析器解析。这里配置的是Thymeleaf。所以就被ThymeleafView解析。"></a>补充，当视图名称没有前缀的时候，会被配置文件中配置的视图解析器解析。这里配置的是Thymeleaf。所以就被ThymeleafView解析。</h2>]]></content>
      <categories>
        <category>整理</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC向域对象共享数据的5种方法</title>
    <url>/2022/12/10/SpringMVC%E5%90%91%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%845%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>参考文章：<a href="https://blog.csdn.net/m0_49499183/article/details/119776961">https://blog.csdn.net/m0_49499183/article/details/119776961</a></p>
<h1 id="使用原生的Servlet向Request域对象共享数据"><a href="#使用原生的Servlet向Request域对象共享数据" class="headerlink" title="使用原生的Servlet向Request域对象共享数据"></a>使用原生的Servlet向Request域对象共享数据</h1><p>在SpringMVC的控制器方法写如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopeController</span> &#123;</span><br><span class="line">    <span class="comment">//使用servletAPI向Request域对象共享数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestByServletAPI&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRequestByServletAPI</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;hello,servletAPI&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; <span class="comment">//这里返回的就是视图名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Controller 方法就是将这个类标识为控制器，里面的方法就是控制器的方法。 @RequestMapping就是映射，将value属性的值作为将要被映射的地址，如果浏览器访问了该地址就会执行该被注释的方法，如果那个地址没有具体业务代码，只需要页面跳转可以使用SpringMVC的一个配置来解决。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span>/&gt;</span> <span class="comment">&lt;!-- SpringMVC映射注解。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一般会配合注解驱动一起使用--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    开启注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果没有开启注解驱动，则会导致@RequestMapping就是方法上面的注解失效。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>从上面代码可得，在SpringMVC中使用原生的HttpServletRequest需要在形参列表上输入对应类型，这个是SpringMVC<font color="red">默认参数类型</font>，共有这些类型:</p>
<p>1、HttpServletRequest 对象</p>
<p>2、HttpServletResponse 对象</p>
<p>3、HttpSession 对象</p>
<p>4、Model&#x2F;ModelMap 对象</p>
<p>在形参中申明好后，就可以在Web中一样的方式使用HttpServletRequest.</p>
<h1 id="使用ModelAndView向Request域中共享数据"><a href="#使用ModelAndView向Request域中共享数据" class="headerlink" title="使用ModelAndView向Request域中共享数据"></a>使用ModelAndView向Request域中共享数据</h1><p>这个只需new一个ModelAndView对象即可向Request域中共享数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testModelAndView</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//ModeAndView两个功能，Model往请求域中共享数据，View是视图功能</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//处理模型数据，即向请求域Request共享数据</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;hello,ModelAndView&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用Model对象"><a href="#使用Model对象" class="headerlink" title="使用Model对象"></a>使用Model对象</h1><p>这个是SpringMVC的默认参数类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModel</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    <span class="comment">//这个居然只要传入形参就可以了？</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;hello, model&quot;</span>);</span><br><span class="line">    System.out.println(model.getClass().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用Map向request域对象共享数据"><a href="#使用Map向request域对象共享数据" class="headerlink" title="使用Map向request域对象共享数据"></a>使用Map向request域对象共享数据</h1><p>没错这个就是JavaSE里面的Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过map集合向Request域对象输入</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    <span class="comment">//这个也是只需要形参就可以了</span></span><br><span class="line">    map.put(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;hello, map&quot;</span>);</span><br><span class="line">    System.out.println(map.getClass().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用ModelMap向request域对象共享数据"><a href="#使用ModelMap向request域对象共享数据" class="headerlink" title="使用ModelMap向request域对象共享数据"></a>使用ModelMap向request域对象共享数据</h1><p>为什么这里使用addAttribute就可以向request域对象，为什么不会共享到Response对象，因为默认是Request域对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用modelMap向request域对象共享数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModelMap</span><span class="params">(ModelMap modelMap)</span> &#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testRequestScope&quot;</span>, <span class="string">&quot;hello, ModelMap&quot;</span>);</span><br><span class="line">    System.out.println(modelMap.getClass().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用Session向Request域对象中共享数据"><a href="#使用Session向Request域对象中共享数据" class="headerlink" title="使用Session向Request域对象中共享数据"></a>使用Session向Request域对象中共享数据</h1><p>这里默认也是向Request域共享数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//往session中共享数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;hello, session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用Session向ServletContext域中共享数据"><a href="#使用Session向ServletContext域中共享数据" class="headerlink" title="使用Session向ServletContext域中共享数据"></a>使用Session向ServletContext域中共享数据</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//往ServletContext(Application)域中输入数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testApplication</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    servletContext.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>,<span class="string">&quot;hello, Application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程小结</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务整理</title>
    <url>/2022/11/08/Spring%E4%BA%8B%E5%8A%A1%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>参考文章  <a href="https://blog.csdn.net/donggua3694857/article/details/69858827">https://blog.csdn.net/donggua3694857/article/details/69858827</a></p>
<h1 id="事务基本原理"><a href="#事务基本原理" class="headerlink" title="事务基本原理"></a>事务基本原理</h1><p>Spring事务的本质其实就是数据库对事务的支持，使用JDBC的事务管理机制,就是利用java.sql.Connection对象完成对事务的提交，那在没有Spring帮我们管理事务之前，我们要怎么做。<br>事务是一系列的动作，一旦其中有一个动作出现错误，必须全部回滚，系统将事务中对数据库的所有已完成的操作全部撤消，滚回到事务开始的状态，避免出现由于数据不一致而导致的接下来一系列的错误。事务的出现是为了确保数据的完整性和一致性，在目前企业级应用开发中，事务管理是必不可少的。</p>
<p>典型案例：银行转账,A账户转钱给B账户100块钱，A账户少100，B账户多100。这两个动作合在一起是一个事务，不可分割。要么都成功要么都不成功。</p>
<p>众所周知，事务有四大特性（ACID）</p>
<p>1.原子性（Atomicity）事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</p>
<p>2.一致性（Consistency）事务在完成时，必须是所有的数据都保持一致状态。</p>
<p>3.隔离性（Isolation）并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性。</p>
<p>4.持久性（Durability）一旦事务完成，数据库的改变必须是持久化的。</p>
<h1 id="并发MySQL读问题"><a href="#并发MySQL读问题" class="headerlink" title="并发MySQL读问题"></a>并发MySQL读问题</h1><p>在企业级应用中，多用户访问数据库是常见的场景，这就是所谓的事务的并发。事务并发所可能存在的问题：<br>1.脏读：一个事务读到另一个事务未提交的更新数据。<br>2.不可重复读：一个事务两次读同一行数据，可是这两次读到的数据不一样。<br>3.幻读：一个事务执行两次查询，但第二次查询比第一次查询多出了一些数据行。<br>4.丢失更新：撤消一个事务时，把其它事务已提交的更新的数据覆盖了。</p>
<p>Spring框架对事务传播行为的7种</p>
<p><img src="/images/image-20221108230605743.png" alt="image-20221108230605743"></p>
<p>各方式对读问题的解决</p>
<p><img src="/images/image-20221108230720533.png" alt="image-20221108230720533"></p>
<p>具体Spring事务配置方式直接看Spring5笔记有很详细的步骤。</p>
]]></content>
      <categories>
        <category>课程小结</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2022/05/12/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<p>[TOC]</p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a><font color="#6dc1f7">JDK JRE JVM</font></h2><blockquote>
<p><strong>JDK</strong>  Java 的开发工具</p>
<p><strong>JRE</strong> JAVA 的运行环境</p>
<p><strong>JVM</strong> Java虚拟机</p>
</blockquote>
<h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a><font color="#6dc1f7">自动类型转换</font></h2><p>自动类型转换精度小的类型可以自动转换成精度大的数据</p>
<p><em>Boolean型</em> 不参与运算</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E5%A4%A7%E5%B0%8F.png" alt="自动类型转换"></p>
<mark class="hl-label red">注意</mark>  

<p><em>1、</em>如果Java中出现一个小数它默认是 double类型的将一个小数结果赋值给float 类型时就会报错将一个精度大的赋值给精度小的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">d</span> <span class="operator">=</span> n + <span class="number">1.1</span>;   <span class="comment">//报错</span></span><br><span class="line"><span class="type">float</span> <span class="variable">d1</span> <span class="operator">=</span> n + <span class="number">1.1</span>;  </span><br></pre></td></tr></table></figure>

<p><em>2、</em> byte类型直接给整数数据的时候，先判段是否在-128-127这个范围内。符合即可</p>
<p>要是变量赋值就需要判断它的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span>  <span class="operator">=</span> n;   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><em>3、</em> byte char short 三个数据不能相互自动类型转换  他们三个在互相参与运算的时候会将精度提升到<strong>int</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a3</span> <span class="operator">=</span> a1 + a2;</span><br><span class="line"><span class="type">short</span> <span class="variable">a4</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a5</span> <span class="operator">=</span> a1 + a2 + a4;</span><br></pre></td></tr></table></figure>

<p><em>4、</em> 自动提升原则，多个精度参与运算的时候会将精度提升到最大的那个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">a4</span> <span class="operator">=</span> a1 + a2 + a3;   <span class="comment">//报错  用低精度的float接高精度的double 报错了</span></span><br><span class="line"><span class="type">double</span> <span class="variable">a5</span> <span class="operator">=</span> a1 + a2 + a3;</span><br></pre></td></tr></table></figure>

<h2 id="强制类型转化"><a href="#强制类型转化" class="headerlink" title="强制类型转化"></a><font color="#6dc1f7">强制类型转化</font></h2><p><em>1、</em> 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型使用时候加上强制类型转化符号（），但是可能造成精度降低或溢出 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> = (<span class="type">int</span>)<span class="number">1.1</span>;  <span class="comment">//精度丢失</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span> <span class="number">1000</span>);  <span class="comment">//-24</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label green">补充</mark>  ： 计算机的反码、补码、源码。 正数的反码和源码一样，负数的反码和源码有区别。

<p>byte 在Java中。由八位二进制表示最高0表示正数 1代表负数。 计算机中都是储存反码，负数反码规则是最高位不变前七位取反然后加1；10000000 原本是-0 byte里面表示-128 ;10000001是127的反码也就是-127。-127和-128相差1也很合理这样既不浪费-0 这个数 正负大概区分是（-128- -1）（0-127）</p>
<p><em>2、</em> 强制类型转换只对于最近的操作数有效，往往使用括号提升优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10</span>*<span class="number">0.1</span>+<span class="number">10.1</span>;   <span class="comment">//编译出错 不能将double给int</span></span><br></pre></td></tr></table></figure>

<p><em>3、</em> char 类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">a= (<span class="type">char</span>)b; <span class="comment">//输出ASCII 码中的10</span></span><br></pre></td></tr></table></figure>

<p><em>4、</em> byte short char 类型在进行运算时，当作int类型处理。</p>
<mark class="hl-label orange">练习题</mark> :

<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%BB%83%E4%B9%A0%E9%A2%98.png" alt="类型转换题目"></p>
<h2 id="String和其他类型转换"><a href="#String和其他类型转换" class="headerlink" title="String和其他类型转换"></a><font color="#6dc1f7">String和其他类型转换</font></h2><h3 id="其他类型转换成String"><a href="#其他类型转换成String" class="headerlink" title="其他类型转换成String"></a><font color="#5cb85c">其他类型转换成String</font></h3><p>一般在其他类型后面凭借一个””。完成类型转换</p>
<h3 id="String-转换成其他类型"><a href="#String-转换成其他类型" class="headerlink" title="String 转换成其他类型"></a><font color="#5cb85c">String 转换成其他类型</font></h3><p>调用相应的包装类来实现。</p>
<p>例如：<code>int s =Integer.parseInt(&quot;33&quot;);</code> 其他数据类型相应调用包装类</p>
<p>char数据类型不能使用。因为String就是由一个一个char组成的。使用String.charAt(位置)；</p>
<mark class="hl-label default">异常</mark> ：如果String类型里面是文字 要转换成int类型等则会异常。

<h2 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a><font color="#6dc1f7">原码 反码 补码</font></h2><blockquote>
<p><em>1、</em> 二进制最高位是符号位：0表示正数，1表示负数；</p>
<p><em>2、</em> 正数的原码、反码、补码都一样（三码合一）；</p>
<p><em>3、</em> 负数的反码&#x3D;它的原码符号位不变。其他位取反（0&gt;1,1&gt;0)；</p>
<p><em>4、</em> 负数的补码&#x3D;它的反码+1，负数的反码&#x3D;负数的补码-1</p>
<p><em>5</em>、0 的反码，补码都是0；</p>
<p><em>6、</em> Java没有无符号数，也就是Java中的数都是有符号的；</p>
<p><em>7、</em> 在计算机运算的时候，都是以补码的方式来运算的。（补码可以用来计算负数）</p>
<p><em>8、</em> 当我们看运算结果的时候，要看他的原码;</p>
</blockquote>
<h2 id="求余"><a href="#求余" class="headerlink" title="求余%"></a><font color="#6dc1f7">求余%</font></h2><p>a%b 当a是小数时，公式&#x3D;a-(int)a&#x2F;b*b; </p>
<h2 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a><font color="#6dc1f7">While循环</font></h2><ul>
<li>基本语法</li>
</ul>
<p>​	循环变量初始化；</p>
<p>​	while(循环条件) {</p>
<p>​			循环体(语句)；</p>
<p>​			循环变量迭代；</p>
<p>​	}</p>
<ol>
<li>while循环也有四个要素</li>
<li>只是四要素放的位置不同，不一样。</li>
</ol>
<mark class="hl-label red">注意</mark> ：

<p>循环条件中不能初始化，必须在循坏上面初始化，否者会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="type">int</span> i &lt; <span class="number">7</span>)&#123;<span class="comment">//会报错</span></span><br><span class="line">``````</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><font color="#6dc1f7">二维数组</font></h2><h3 id="动态创建静态创建"><a href="#动态创建静态创建" class="headerlink" title="动态创建静态创建"></a><font color="#5cb85c">动态创建静态创建</font></h3><h4 id="动态创建"><a href="#动态创建" class="headerlink" title="动态创建"></a><font color="#ffd253">动态创建</font></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>][<span class="number">3</span>];   <span class="comment">//创建一个含有3个一维数组的二维数组并且每个一维数组都是3的长度</span></span><br><span class="line"><span class="type">int</span> [][] arr1 =<span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>][];     <span class="comment">//创建一个含有3个一维数组的二维数组但是不能确定长度。</span></span><br><span class="line"><span class="type">int</span> [] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];      <span class="comment">//动态初始化一维数组</span></span><br><span class="line">arr[<span class="number">0</span>]= arr1;                <span class="comment">//将一维数组arr1 赋予给二维数组arr的第0个数</span></span><br><span class="line"><span class="type">int</span> [] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>&#125;;  <span class="comment">// 静态初始化一维数组</span></span><br><span class="line">arr[<span class="number">1</span>] = arr3;               <span class="comment">// 将一维数组arr1 赋予给二维数组arr的第1个数</span></span><br></pre></td></tr></table></figure>

<h4 id="静态创建"><a href="#静态创建" class="headerlink" title="静态创建"></a><font color="#ffd253">静态创建</font></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [][] arr = <span class="keyword">new</span> <span class="title class_">int</span> [][] &#123;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">4</span>&#125;&#125;;    <span class="comment">//静态创建 两个元素的二维数组 第一个元素是&#123;3，4，5&#125;   可以不是“长方形” 就是4X4之类的  ，也可以是不统一的</span></span><br><span class="line"><span class="type">int</span> [] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">12</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> [] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> [][] arr1 =<span class="keyword">new</span> <span class="title class_">int</span> [][]&#123;arr2,arr3&#125;;    <span class="comment">//静态创建当然里面也可以直接放创建好的数组（动态静态都可以）</span></span><br></pre></td></tr></table></figure>

<h3 id="数组数据传递机制"><a href="#数组数据传递机制" class="headerlink" title="数组数据传递机制"></a><font color="#5cb85c">数组数据传递机制</font></h3><p><img src="/images/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86.png" alt="二维数组内存"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] arr1 =&#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;5&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span>[] arr2 = arr1;</span><br><span class="line">arr1[<span class="number">2</span>] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">System.out.println(arr2);   <span class="comment">//字符串数组不需要tostring</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">总结</mark> 

<p>输出结果为sww5，因为arr1和arr2执行的是同一个空间，他们打印出来的元素都是相同的。数组传递机制如下图所示：</p>
<p><img src="/images/%E6%95%B0%E7%BB%84%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6.png" alt="数组传递机制"></p>
<h2 id="数组算法：双指针"><a href="#数组算法：双指针" class="headerlink" title="数组算法：双指针"></a><font color="#6dc1f7">数组算法：双指针</font></h2><blockquote>
<p>双指针，就是<strong>定义两个指针在指定的数组&#x2F;链表上游走，在做一些自定义的操作</strong>。 如果要细分的话，双指针有 左右指针 ， 快慢指针 ， 滑动窗口 三种类型，一般时间复杂度为O (n)，空间复杂度为O (1),这就是双指针的精妙之处。</p>
<p>不用再去创建一个数组。</p>
</blockquote>
<mark class="hl-label orange">案例1</mark> ：在数组中移除对应对应的数(val)——快慢指针判断有条件判断指针2是否前进

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElementcorrection</span><span class="params">(<span class="type">int</span> [] nums , <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      双指针思想</span></span><br><span class="line"><span class="comment">      个人理解： 两个指针都会遍历数组 一个用来比较是否是要移除的元素 第二个指针相当于新建一个数组：大小和原来一样</span></span><br><span class="line"><span class="comment">      并且如果是符合这个数组（即不等于要被移除的数）那么第二个指针就会自增1 那么有多少个数符合那么第二个指针就会有多长</span></span><br><span class="line"><span class="comment">      最坏的情况就是这个数组没有要移除的数那么两个指针都会遍历数组一遍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left1</span> <span class="operator">=</span> <span class="number">0</span> ; left1 &lt; len ; left1++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left1] != val) &#123;</span><br><span class="line">            nums[left] = nums[left1];</span><br><span class="line">            left++;    <span class="comment">//即完成移除元素 也记录了符合的数的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8C%E6%8C%87%E9%92%88.png" alt="双指针经典案例"></p>
<mark class="hl-label orange">案例2</mark> ：类似双指针——两个数组双指针(快慢指针)

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *一个升序数组要求加入一个元素后还是升序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] paixu(<span class="type">int</span>[] arr, Scanner sc) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  1、第一步找位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= arr[i]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">//关键不然一直要么是最后一个要么是倒数第二个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==-<span class="number">1</span>) &#123;</span><br><span class="line">            index = len;   <span class="comment">//没有找到位置那就是最后一个啦</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  2、数组扩容</span></span><br><span class="line">        <span class="type">int</span> [] Newarr = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 3、 类似双指针  最外层指针在扩容数组上 里面一层在旧数组上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>; i&lt; Newarr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">                Newarr [i] = arr [j];</span><br><span class="line">                j++;  <span class="comment">//非常的关键一步很牛叉的思想</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;   <span class="comment">// else 就说明是要插入的位置</span></span><br><span class="line">                 Newarr [i] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Newarr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">总结</mark> 

<blockquote>
<p>这是两个指针在不同数组上的应用，最明显的作用是减少代码量。<code>j++</code>这个很关键。</p>
</blockquote>
<h2 id="一些数组排序"><a href="#一些数组排序" class="headerlink" title="一些数组排序"></a><font color="#6dc1f7">一些数组排序</font></h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><font color="#5cb85c">冒泡排序</font></h3><blockquote>
<p>思想：总体像是水中小泡一个个有顺序（按一定的<strong>规则</strong>）冒出</p>
<blockquote>
<p>​		    第一次排序，找出数组中最大或者最小的数。</p>
<blockquote>
<p>​		    第二次排序，将第一次排序找出的最大值或者最大值排除，在剩下的数组中找出最大或者最小的</p>
<p>​            ~~</p>
</blockquote>
<p>排序次数&#x3D; n-1， n是数组中元素总个数。</p>
</blockquote>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> [] arr =<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>，<span class="number">34</span>，<span class="number">67</span>，<span class="number">7845</span>，<span class="number">341</span>，<span class="number">213</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;     <span class="comment">//两层嵌套循环实现每次i++ 。`j &lt; arr.length-i-1`  j的上限减一遍历范围减一 那么就相当于排好一个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-i-<span class="number">1</span>; j++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j+<span class="number">1</span>];         <span class="comment">//规则：这里是倒叙 当然也可以是升序~~等</span></span><br><span class="line">                    arr[j+<span class="number">1</span>] = arr[j]; </span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java函数方法"><a href="#Java函数方法" class="headerlink" title="Java函数方法"></a><font color="#6dc1f7">Java函数方法</font></h2><h3 id="方法的调用机制"><a href="#方法的调用机制" class="headerlink" title="方法的调用机制"></a><font color="#5cb85c">方法的调用机制</font></h3><blockquote>
<p>首先在<strong>栈</strong>里面创建一个空间，如果要创建对象（new）那么在<strong>堆</strong>内存中创建一个空间。再运行到方法时候，会在<strong>栈</strong>内存再开一个空间，如果要有参数。那么会对应传入。return语句则会相应返回：底层原理先会记住这个方法的地址最后在return语句中返回原来的地址。当return语句执行后，方法的栈内存则会<strong>释放</strong>。简单实例如下图所示。</p>
</blockquote>
<p><img src="/images/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6.png" alt="方法调用机制"></p>
<p>最后在方法执行（println）完成后，栈中的main方法也会释放。</p>
<h3 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a><font color="#5cb85c">递归思想</font></h3><blockquote>
<p>简单的说：递归方法自己调用自己，每次调用的时传入不同的变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。如算法中 二分查找，快排，归并排序，分治算法等就用到了递归思想。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">digui</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n==<span class="number">1</span> || n==<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> digui (n-<span class="number">1</span>) +digui (n-<span class="number">2</span>);   <span class="comment">//递归调用思想</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您输入的数据有误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">案例1</mark> ：斐波那契数（1，1，2，3，5，8 ~~~），上图所示代码完成返回第几位的值。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">taozi</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (day == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">if</span> (day &gt;= <span class="number">1</span> || day &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (taozi(day + <span class="number">1</span>) + <span class="number">1</span>) *<span class="number">2</span>;     <span class="comment">//递归</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;天数不符合实际&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">案例2</mark> ：猴子吃桃，每次吃掉前一天的一半并多一个，第十天剩1个。用递归求得每天的桃子个数。

<mark class="hl-label orange">案例3</mark> ：老鼠出迷宫。制定起始点、终点和障碍物。求出路线。

<p>1、迷宫生成、打印和方法调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [][] migong = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;   </span><br><span class="line">            migong [<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            migong [<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            migong [i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            migong [i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	migong [<span class="number">3</span>][<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">        migong [<span class="number">3</span>][<span class="number">2</span>] =<span class="number">1</span>;  </span><br><span class="line">    	<span class="comment">//二维迷宫生成。</span></span><br><span class="line">        <span class="type">migong</span> <span class="variable">laoshu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">migong</span> ();</span><br><span class="line">        laoshu.findway(migong,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ele : migong) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(ele));    <span class="comment">//for each 遍历二维数组。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2、寻找路的一种办法（findway）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    制定一个自动寻路方法：</span></span><br><span class="line"><span class="comment">    1、能够走通则返回true，不能走通或者走过了都返回false</span></span><br><span class="line"><span class="comment">    2、int [][] migong 是传入的迷宫 int i int j 代表起始位置</span></span><br><span class="line"><span class="comment">    3、递归找路先指定各个含义 ：</span></span><br><span class="line"><span class="comment">        0、代表可以走通</span></span><br><span class="line"><span class="comment">        1、代表障碍物</span></span><br><span class="line"><span class="comment">        2、代表走过的路可以通过(不好表示，如果终点为2那么已完成寻路，如果在平时遇到2需要返回false而不是true，不然会死循环)</span></span><br><span class="line"><span class="comment">        3、代表死路（当四面围墙的时候才会出现或者回溯现象）。</span></span><br><span class="line"><span class="comment">    4、寻路法则： 下&gt;右&gt;上&gt;左。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findway</span> <span class="params">(<span class="type">int</span> [][] migong , <span class="type">int</span> i , <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">//首先制定终点</span></span><br><span class="line">        <span class="keyword">if</span> (migong [<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (migong [i][j]==<span class="number">0</span>) &#123; <span class="comment">//先判断起点是没有障碍物的  也是判断下一个递归的位置有没有障碍物</span></span><br><span class="line">            migong [i][j]=<span class="number">2</span>;<span class="comment">// 先将这个点标记为可以通过的路，这个很关键下次递归选择也需要用得到</span></span><br><span class="line">            <span class="comment">//这里经行寻路法则： 下&gt;右&gt;上&gt;左。</span></span><br><span class="line">            <span class="keyword">if</span> (findway(migong,i+<span class="number">1</span>,j)) &#123;  <span class="comment">//很巧妙的将这个方法返回是Boolean和递归if结合</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (findway(migong,i,j+<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (findway(migong,i-<span class="number">1</span>,j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(findway(migong,i,j-<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                migong[i][j] = <span class="number">3</span>;<span class="comment">//不是j+1或者i+1,很巧妙。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//这个else是相较于寻路法则的else 第一句的终点判断可以相当是独立判断的。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//上下左右都是障碍物(1) 则返回false死路</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3、结果展示。</p>
<p><img src="/images/image-20220531172208441.png" alt="image-20220531172208441"></p>
<p>4、回溯现象。</p>
<p>由于此算法是不会走回头路的，下面就会出现回溯现象。</p>
<p><img src="/images/image-20220531223157742.png" alt="image-20220531223157742"></p>
<p>结果：</p>
<p><img src="/images/%E5%9B%9E%E6%BA%AF.png" alt="回溯"></p>
<p>这里就体现出来<mark class="hl-label red">3:代表死路</mark> 的重要性。</p>
<blockquote>
<p>总结：递归可以求已知某个结果，然后根据某一个条件可以依次推出别的结果。递归思想可以从已知结果开始推，如斐波那契数知道第一位第二位，就从这里着手。而猴子吃桃是知道第十天的桃子数量，就需要反推。老鼠出迷宫这个有点难度，但是最终还是找规律，递归需定一个范围。</p>
</blockquote>
<h4 id="递归与循环的区别于联系"><a href="#递归与循环的区别于联系" class="headerlink" title="递归与循环的区别于联系"></a><font color="#ffd253">递归与循环的区别于联系</font></h4><blockquote>
<p>相同点：<br>（1）都是通过控制一个变量的边界（或者多个），来改变多个变量为了得到所需要的值，而反复而执行的；<br>（2）都是按照预先设计好的推断实现某一个值求取；（请注意，在这里循环要更注重过程，而递归偏结果一点）</p>
<p>不同点：<br>（1）递归通常是逆向思维居多，“递”和“归”不一定容易发现（比较难以理解）；而循环从开始条件到结束条件，包括中间循环变量，都需要表达出来（比较简洁明了）。</p>
<p>简单的来说就是：用循环能实现的，递归一般可以实现，但是能用递归实现的，循环不一定能。因为有些题目①只注重循环的结束条件和循环过程，而往往这个结束条件不易表达（也就是说用循环并不好写）；②只注重循环的次数而不注重循环的开始条件和结束条件（这个循环更加无从下手了）。</p>
</blockquote>
<h2 id="可变参数的使用-重载类似升级"><a href="#可变参数的使用-重载类似升级" class="headerlink" title="可变参数的使用(重载类似升级)"></a><font color="#6dc1f7">可变参数的使用(重载类似升级)</font></h2><blockquote>
<p>可变参数相当于重载的任意形式，你可以往里面加任意个制定的类型组<br> 1、int…表示接受的是可变参数，类型是int，即可以接受多个int(0-n)个<br> 2、使用可变参数时，可以当作数组来使用，即nums相当于数组使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo1</span> <span class="variable">a</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Demo1</span>();</span><br><span class="line">    a.sum(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span>...nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ele :nums) &#123;</span><br><span class="line">        sum = sum +ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum1</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span>...nums1,<span class="type">int</span>...nums2)</span>&#123; <span class="comment">//报错，只能有一个可变参数</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> 

<ul>
<li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</li>
<li>由于可变参数必须是最后一个参数，所以一个函数最多只能有一个可变参数</li>
<li>Java的可变参数，会被编译器转型为一个数组</li>
<li>变长参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立</li>
</ul>
<mark class="hl-label purple">总结</mark> 

<p>可变参数的使用使得重载使用范围更广，也更为灵活。得益于其随意可以输入n个数，作为数组。同时又可以带入其他普通形参(用来接收调用该方法时传递的参数)。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a><font color="#6dc1f7">this关键字</font></h2><h3 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a><font color="#5cb85c">问题引出</font></h3><mark class="hl-label orange">构造器</mark> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">dog</span><span class="params">(String dname,<span class="type">int</span> dage)</span>&#123;</span><br><span class="line">        name = dname;</span><br><span class="line">        age = dage;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造器的形参，能够直接写成属性名就更好了。</p>
<p>但是有一个问题就是，根据变量名的作用域原则。如果把dname改成name。那么构造器重name&#x3D;name。那就是将形参传入进来的name赋值给形参传入进来的name。没有作用。</p>
<p>所以需要<font color="ED5A65"><strong>this关键字</strong></font>。</p>
<h3 id="this入门"><a href="#this入门" class="headerlink" title="this入门"></a><font color="#5cb85c">this入门</font></h3><ul>
<li><p>什么是this</p>
<p>Java虚拟机会给每个对象(不是类，new出来的很多对象)分配this，代表当前对象。</p>
<mark class="hl-label orange">例子</mark> ：[上帝创世界小故事]

<p><img src="/images/image-20220625133232693.png" alt="image-20220625133232693"></p>
</li>
<li><p>使用this解决前面变量命名问题</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...main&#123;</span><br><span class="line">    <span class="type">dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">dog</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="comment">//this.name 就是当前对象的属性name。</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this本质"><a href="#this本质" class="headerlink" title="this本质"></a><font color="#5cb85c">this本质</font></h3><p>通过内存理解this。</p>
<p><img src="/images/image-20220625165832754.png" alt="image-20220625165832754"></p>
<p>上图堆中的this指针是隐藏的，是指向对应的对象（每个对象都有对应的this）。</p>
<p>由于是运行在JVM虚拟机上面的，所以不能获得对象正真地址，可以使用对象的方法hashcode()来获得虚拟地址。来验证this地址与其对应对象是否相等。如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">dog1.hashcode();</span><br><span class="line">...</span><br><span class="line"><span class="built_in">this</span>.hashcode();  <span class="comment">//写在构造方法里面  dog类里面的方法用this.hashcode()也一样。</span></span><br></pre></td></tr></table></figure>

<p>可以得出结论是this与其对应对象的地址是一样的。</p>
<h3 id="this小结"><a href="#this小结" class="headerlink" title="this小结"></a><font color="#5cb85c">this小结</font></h3><blockquote>
<p>简单的说，哪个<font color="ED5A65">对象调用</font>，this就代表哪个<font color="ED5A65">对象</font>。不是类哦注意!!!</p>
</blockquote>
<h3 id="this使用细节"><a href="#this使用细节" class="headerlink" title="this使用细节"></a><font color="#5cb85c">this使用细节</font></h3><blockquote>
<ol>
<li>this关键字可以用来访问本类的属性、方法、构造器。</li>
<li>this用于区分当前类的属性和局部变量。</li>
<li>访问成员方法的语法：this.方法名(参数列表)；</li>
<li>访问构造器语法：this(参数列表)；注意只能在构造器中使用(即只能在构造器中访问另一个构造器，必须放在第一条语句)</li>
<li>this不能在类定义的外部使用，只能在类定义的方法中使用。</li>
</ol>
</blockquote>
<p><font color="7E2065">访问本类语法：this.属性名</font></p>
<p><font color="7E2065">访问本类方法：this.方法名(形参);</font></p>
<p><font color="7E2065">访问本类构造器：this(形参)；</font></p>
<mark class="hl-label orange">案例1</mark> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">this</span>细节&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;xx&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1方法调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;xx1&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;f2方法被调用&quot;</span>);</span><br><span class="line">        <span class="comment">//调用f1方法</span></span><br><span class="line">        <span class="comment">//1、</span></span><br><span class="line">        <span class="built_in">this</span>.f1();</span><br><span class="line">        <span class="comment">//2、直接调用</span></span><br><span class="line">        f1();</span><br><span class="line">        <span class="comment">//属性调用演示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;this调用&quot;</span>+<span class="built_in">this</span>.name+<span class="string">&quot;\t&quot;</span>+<span class="built_in">this</span>.age); <span class="comment">//一定调用本类属性xx 19 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;直接调用&quot;</span>+name+<span class="string">&quot;\t&quot;</span>+age);   <span class="comment">//结果根据局部变量 就近原则 xx1 19</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种调用方法有区别，在继承中体现。</p>
<mark class="hl-label orange">案例2</mark> :解释第四条

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">T</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//this调用构造器 ,必须要在第一行</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;lwt&quot;</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：一个构造器要访问另一个构造器的时候，必须要写在<font color="EEA2A4">构造器第一行</font>。调用的构造中形参的类型和位置要对应。

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><font color="#6dc1f7">继承</font></h2><h3 id="继承原理示意图"><a href="#继承原理示意图" class="headerlink" title="继承原理示意图:"></a><font color="#5cb85c">继承原理示意图:</font></h3><p><img src="/images/image-20220604133015736.png" alt="image-20220604133015736"></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a><font color="#6dc1f7">多态</font></h2><p>多态的注意事项和细节讨论：</p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a><font color="#5cb85c">向上转型</font></h3><p>多态的前提是：有继承&#x2F;实现关系；有父类引用指向子类的对象；有方法重写</p>
<p>多态的向上转型：将子类提升到父类，（我们默认父类在子类上面）</p>
<p>1)<mark class="hl-label green">本质</mark> :父类的引用指向了子类的对象。</p>
<p>2)<mark class="hl-label green">语法</mark> :父类类型  引用名 &#x3D; new 子类类型()；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();  <span class="comment">//多态的对象创建方法 有父类引用指向子类的对象；</span></span><br></pre></td></tr></table></figure>

<p>3)<mark class="hl-label green">特点</mark> :特点编译类型（编译时）看左边 ，运行类型（运行时）看右边。可以调用父类中的所有成员(需遵循访问权限)，如：属性如果是private——但是事实上private类型成员应该也是继承给了子类，只是他是私密的。就像你继承了你爸爸的一个保险箱，实质上已经继承了但是需要密码。Java中get，set就是密钥。继承也是这样的。</p>
<p><img src="/images/image-20220604134717209.png" alt="image-20220604134717209"></p>
<p>不能调用子类中特有成员(方法和方法)；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();  <span class="comment">//多态的对象创建方法</span></span><br><span class="line">dog.dogeat();   <span class="comment">//dogeat是子类的一个方法   报错。因为写代码时是在编译，编译的时候看左边，dog是animal类型，没有子类的方法，编译器报错（Javac）。</span></span><br></pre></td></tr></table></figure>

<p>最终运行效果看子类的具体实现。（如：重写了父类的方法），即运行的时候看左边子类，如果子类没有对应的属性和方法就调用父类的（继承）。</p>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a><font color="#5cb85c">向下转型</font></h3><p>多态的向下转型：</p>
<p>1)<mark class="hl-label green">语法</mark> : 子类类型 引用名 &#x3D;  （子类类型）父类引用；</p>
<p>2)只能强转父类的引用，不能强转父类的对象</p>
<p>3)要求父类的引用必须指向的是当前目标类型的对象</p>
<p>4)当向下转型后，可以调用子类类型中所有的成员(方法和属性)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 是 cat 和dog的父类</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (cat) animal  <span class="comment">//向下转型</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (dog) animal <span class="comment">//编译没问题 ，会抛出异常</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">试例</mark> :

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">a</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">b</span>();    <span class="comment">//父类的引用指向子类</span></span><br><span class="line">        System.out.println(s.age);   <span class="comment">//因为没有向下转型 ，调用属性的时候不会想方法一样，直接调用子类重写的方法，这里就只能调用父类的age（动态绑定机制）</span></span><br><span class="line">        s.sum();     <span class="comment">//由于子类有重写，动态绑定机制，调用子类中重写的sum（）方法</span></span><br><span class="line">        System.out.println(s.name);  <span class="comment">//这里就直接调用了，没啥好说 的，子类没有特有的name属性</span></span><br><span class="line">        <span class="type">b</span> <span class="variable">s1</span> <span class="operator">=</span> (b) s;   <span class="comment">//向下转型后</span></span><br><span class="line">        System.out.println(s1.age);  <span class="comment">//调用子类特有的属性</span></span><br><span class="line">        s1.sum();   <span class="comment">//和没有向下转型的一样，由于动态绑定机制，没有转型也会输出子类重写的方法</span></span><br><span class="line">        System.out.println(s.name); <span class="comment">//这里就输出子类继承自父类的name属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">name</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span> <span class="keyword">extends</span> <span class="title class_">a</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">总结</mark> ：多态的优点右边对象可以实现解耦合，便于扩展和维护。比如接口collection你想使用Arraylist ，后面要改LinkedList 。只需将`Collection<String> arr = new ArrayList<>();`改成`Collection<String> arr = new LinkedList<>();`arr就从ArryList 变成LinkedList。缺点是不能直接调用子类的特有方法，就需要向下转型。如上面代码块显示。<br>

<mark class="hl-label red">注意</mark> ：类型不能转换错误`Dog dog = (dog) animal`则会抛出异常。<br>

<mark class="hl-label default">异常</mark> ：ClassCastException  <br>

<p>可以使用instanceof：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(lwt <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">	<span class="type">Dog</span> <span class="variable">lwt1</span> <span class="operator">=</span> (Dog) lwt;</span><br><span class="line">	lwt1.eat();  <span class="comment">//这样强制类型转换可以调用多态的独有方法 ，弥补缺点</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(lwt <span class="keyword">instanceof</span> niu)&#123;</span><br><span class="line">    <span class="type">niu</span> <span class="variable">lwt2</span> <span class="operator">=</span> (niu) lwt;</span><br><span class="line">    lwt2.play();  <span class="comment">//这样强制类型转换可以调用多态的独有方法 ，弥补缺点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a><font color="#5cb85c">动态绑定机制</font></h3><mark class="hl-label orange">重要</mark> <br>

<p><img src="/images/image-20220606230737208.png" alt="image-20220606230737208"></p>
<p>前面学习的向上转型原则可以很简单的得出<code>Systems.out.println(a.sum()); //40</code> <code>Systems.out.println(a.sum1()); //30</code><br></p>
<p>但是当将子类的sum()和sum1()方法都除去时。如下图所示。</p>
<p><img src="/images/image-202206062307372081.png" alt="image-20220606230737208 - 副本.png"></p>
<p>更具Java的动态调用机制，当调用对象方法的时候，该方法会和该对象的<strong>内存地址(堆中产生的)&#x2F;运行类型绑定</strong>。所以即时在父类调用<code>sum()</code>方法时又遇到了<code>getI()</code>方法,这时候还是会先从子类开始找起。所以代码更改后的结果为，30和20。这个20根据属性没有动态绑定机制，所以i&#x3D;父类中10。<br></p>
<mark class="hl-label purple">总结</mark> ：<br>

<p>动态绑定机制，方法会绑定：子类有方法重写就用子类的即使是在父类中调用(由于多态的向上转型)。属性没有动态绑定机制，哪里访问就调用哪里（继承需遵守_没有重写的话)、(作用域)。</p>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a><font color="#6dc1f7">Object 类</font></h2><h3 id="x3D-x3D-比较运算符"><a href="#x3D-x3D-比较运算符" class="headerlink" title="&#x3D;&#x3D;比较运算符"></a><font color="#5cb85c">&#x3D;&#x3D;比较运算符</font></h3><p>&#x3D;&#x3D;和equals的对比<mark class="hl-label red">面试题</mark> </p>
<p>&#x3D;&#x3D;是一个比较运算符</p>
<p>1· &#x3D;&#x3D;：既可以判断基本类型，又可以判断引用类型</p>
<p>2· &#x3D;&#x3D;：如果判断基本类型，判断的是值是否相等。<mark class="hl-label orange">试例</mark> ：<code>int i = 10; double s = 10;</code></p>
<p>3· &#x3D;&#x3D;：如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象<mark class="hl-label orange">试例</mark> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> a;        <span class="comment">// 在栈里面创建一个c、b指向堆内存中的a；所以他们的地址都是一样的</span></span><br><span class="line">System.out.println(b==c);  <span class="comment">//true</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">//这是分别栈内存中开了两个内存，那么地址肯定也是不一样的</span></span><br><span class="line">System.out.println(e==f);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a><font color="#5cb85c">equals方法</font></h3><p>equals:是object类中的方法，只能判断引用类型——即默认判断的是地址是否相等，子类中往往<mark class="hl-label red">重写</mark> 该方法，用于判断内容是否相等。比如Object类的子类Integer，重写Object的equals的方法用于判断两个值是否相等<br></p>
<mark class="hl-label orange">试例</mark> :<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1000</span>);</span><br><span class="line">System.out.println(integer1 == integer2);  <span class="comment">//false 因为两个integer是引用类型地址不一样</span></span><br><span class="line">System.out.println(integer1.equals(integer2)); <span class="comment">//false 没有重写了equals方法</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">案例</mark> :

<p><img src="/images/image-20220607141515826.png" alt="image-20220607141515826"></p>
<h3 id="hashcode方法"><a href="#hashcode方法" class="headerlink" title="hashcode方法"></a><font color="#5cb85c">hashcode方法</font></h3><blockquote>
<p>1)提高具有哈希结构的容器的效率！</p>
<p>2)两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</p>
<p>3)两个引用，如果指向的是不同对象，则哈希值是不一样的</p>
<p>4)哈希值主要根据地址号来的！不能完全将哈希值等价于地址</p>
<p>5）后面在集合中hashcode如果需要的话，也会重写。</p>
</blockquote>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">a</span> <span class="variable">a1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">a</span>();</span><br><span class="line"><span class="type">a</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">a</span>();</span><br><span class="line">System.out.println(a1.hashCode());   <span class="comment">//返回哈希值</span></span><br><span class="line">System.out.println(a2.hashCode());  <span class="comment">//两者肯定不同</span></span><br><span class="line"><span class="type">a</span> <span class="variable">a3</span> <span class="operator">=</span> a1;</span><br><span class="line">System.out.println(a3.hashCode());  <span class="comment">//返回的哈希值和a1是一样的</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220606235220368.png" alt="image-20220606235220368"></p>
<mark class="hl-label purple">总结</mark> ：<br>

<p>hashcode是根据对象的内部地址(和java的地址不同，因为java是跑在虚拟机上面的，底层C语言可以获得内部地址)返回一个值。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><font color="#5cb85c">toString</font></h3><mark class="hl-label purple">基本介绍</mark> ：<br>

<blockquote>
<p>默认返回：全类名+@+哈希值的十六进制，<mark class="hl-label red">查看Object的toString方法</mark> </p>
<p>子类往往重写toString方法，用于返回对象的属性信息。</p>
<mark class="hl-label purple">Object的toString方法</mark> ：

<p><img src="/images/image-20220607142231150.png" alt="image-20220607142231150"></p>
<p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。</p>
<p>当直接输出一个对象的时候，toString方法会默认调用。(System.out.prinln();)</p>
</blockquote>
<mark class="hl-label orange">源码解释</mark> ：

<p>(1)getClass().getName() 类的全类名(包名+类名)</p>
<p>(2)Integer.toHexString(hashCode()) 将对象的hashCode值转成16进制字符串</p>
<mark class="hl-label orange">案例</mark> ：toString重写

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">wuhu</span> <span class="variable">s</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">wuhu</span>(<span class="string">&quot;lwt&quot;</span>,<span class="number">2</span>,<span class="number">123.0</span>);</span><br><span class="line">        System.out.println(s);     <span class="comment">//默认输出的时候会使用toString</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wuhu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    wuhu(String name, <span class="type">int</span> age ,<span class="type">double</span> salary) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;   <span class="comment">//idea可以自动生成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;wuhu&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, salary=&quot;</span> + salary +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="finalize-已弃用"><a href="#finalize-已弃用" class="headerlink" title="finalize(已弃用)"></a><font color="#5cb85c"><del>finalize</del>(已弃用)</font></h3><ol>
<li>当对象被回收时，系统自动调用该对象的finalize方法。子类可以<font color="EC8AA4">重写</font>该方法.做一些<font color="0F59A4">释放资源</font>的操作</li>
<li>什么时候被回收：当某个对象没有任何引用的时候，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。</li>
<li>垃圾回收机制的调用，是由系统来决定(有自己的GC算法)，也可以通过System.gc()主动触发垃圾回收机制</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">finalize</span>练习<span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">car</span>(<span class="string">&quot;lwt&quot;</span>);</span><br><span class="line">        car = <span class="literal">null</span>; <span class="comment">//这时候 car对象是垃圾.垃圾回收器就会回收(销毁)对象.把对应的堆空间释放.</span></span><br><span class="line">        <span class="comment">//在销毁对象前,会调用finalize方法.</span></span><br><span class="line">        <span class="comment">//程序员可以在这个方法中写自己的业务逻辑.(比如数据库连接,或者打开的文件)</span></span><br><span class="line">        <span class="comment">//如果程序员不重写,则什么事都不做</span></span><br><span class="line">        System.gc(); <span class="comment">//主动调用垃圾回收器,并且程序不会阻塞.</span></span><br><span class="line">        System.out.println(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">car</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;把你😀了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><font color="#6dc1f7">抽象类</font></h2><ul>
<li>引出</li>
</ul>
<p><img src="/images/image-20220728170713624.png" alt="image-20220728170713624"></p>
<mark class="hl-label orange">小结</mark> ：

<p>当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类</p>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abstract01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span> <span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里实现了这个方法没有什么意义。</span></span><br><span class="line">    <span class="comment">//即：父类方法不确定性的问题。不同动物吃的方法不同</span></span><br><span class="line">    <span class="comment">//考虑将这个方法设计为抽象(abstract)方法</span></span><br><span class="line">    <span class="comment">//所谓抽象方法就是没有实现的方法把他抽象了。</span></span><br><span class="line">    <span class="comment">//没有实现就是没有方法体</span></span><br><span class="line">    <span class="comment">//当一个类中存在抽象方法时需要将该类声明为abstract类</span></span><br><span class="line">    <span class="comment">//一般来说，抽象类会被继承，由其子类来实现方法</span></span><br><span class="line"><span class="comment">//    public void eat()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这是一个动物，但是不知道吃什么&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决之道-抽象类快速入门</li>
</ul>
<p>​		当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰类就是抽象类。</p>
<h3 id="抽象类使用细节1"><a href="#抽象类使用细节1" class="headerlink" title="抽象类使用细节1"></a><font color="#5cb85c">抽象类使用细节1</font></h3><ul>
<li>抽象类的介绍</li>
</ul>
<ol>
<li>用abstract关键字来修饰一个类时，这个类就叫抽象类<br>访问修饰符 abstract 类名 {}</li>
<li>用abstract 关键字来修饰一个方法时，这个方法就是抽象方法<br>访问修饰符 abstract 返回类型 方法名(参数列表)；&#x2F;&#x2F;没有方法体</li>
<li>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类（）</li>
<li>抽象类，<font color="F07C82">是考官比较爱问的知识点</font>，在框架和设计模式使用较多</li>
</ol>
<ul>
<li>抽象类使用的注意事项和细节讨论</li>
</ul>
<ol>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含abstract方法。也就是说，抽象了可以没有abstract方法</li>
<li>一旦类包含了abstract方法，则这个类<font color="F07C82">必须声明为abstract</font></li>
<li>abstract只能修饰类和方法，不能修饰属性和其它的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractDetial01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//抽象类不能被实例化</span></span><br><span class="line">        <span class="comment">//new A(); //false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类不一定要包含abstract方法，也就是说，抽象类可以没有abstract方法</span></span><br><span class="line"><span class="comment">//还可以有实现的方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//可以有实现的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有抽象方法的类必须为抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">//只能抽象类和方法其他不能抽象</span></span><br><span class="line">    <span class="comment">//abstract int A; //false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">S</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类的使用细节2"><a href="#抽象类的使用细节2" class="headerlink" title="抽象类的使用细节2"></a><font color="#5cb85c">抽象类的使用细节2</font></h3><ul>
<li>抽象类使用注意事项和细节2</li>
</ul>
<p>​	5、抽象类可以有任意成员[因为抽象的类还是类]，比如：非抽象方法，构造器，静态属性等等</p>
<p>​	6、抽象方法不能有主体，即不能实现</p>
<p><img src="/images/image-20220728173808898.png" alt="image-20220728173808898"></p>
<p>​	7、如果一个类继承了抽象类，则它必须<font color="F07c82">实现抽象类的所有抽象方法</font>，除非它自己也声明为abstrct类。</p>
<p>​	8、抽象方法不能使用<font color="F07C82">private、final和static来修饰</font>，因为这些关键字都是和<font color="f07c82">重写</font>相违背的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以有实现的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sss</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须把抽象父类的所有抽象方法实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sss</span><span class="params">()</span> &#123;  <span class="comment">//语法上只要有了&#123;&#125;就为方法实现</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个类都是抽象的时候就不用实现父类的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以有实现的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sss</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//有抽象方法的类必须为抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只能抽象类和方法其他不能抽象如：变量等。 抽象方法不能使用private、final和static修饰。</span></span><br><span class="line">    <span class="comment">//abstract int A; //false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">S</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">注意</mark> ：

<p>语法上只要有了{}（方法体）就为方法实现。</p>
<h3 id="抽象类课堂练习"><a href="#抽象类课堂练习" class="headerlink" title="抽象类课堂练习"></a><font color="#5cb85c">抽象类课堂练习</font></h3><p><img src="/images/image-20220728230845344.png" alt="image-20220728230845344"></p>
<mark class="hl-label orange">解答</mark> ：

<ol>
<li>不能通过，以为抽象方法一定需要被子类重写，而final表示这个方法已经满足需求，不用在被子类继承修改重写等。违背了abstract关键字。</li>
<li>不能通过，因为static表示类方法，这个方法是类所有。和重写没关系，所以这两个组合是错误的</li>
<li>不能通过，因为private关键字别的类不能访问，子类也不能，当然也不能被重写</li>
<li>看代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abstract</span>练习 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CommonEmployee</span> <span class="variable">lwt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonEmployee</span>(<span class="string">&quot;lwt&quot;</span>, <span class="number">454545</span>, <span class="number">3000</span>);</span><br><span class="line">        System.out.println(lwt.work(lwt.getName(), lwt.getId(), lwt.getSalary()));</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">jth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;jth&quot;</span>, <span class="number">898989</span>, <span class="number">30000</span>, <span class="number">2000</span>);</span><br><span class="line">        System.out.println(jth.work(jth.getName(), jth.getId(), jth.getSalary()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span> <span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">work</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBonus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBonus</span><span class="params">(<span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary, <span class="type">double</span> bonus)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, id, salary);</span><br><span class="line">        <span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">work</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        System.out.println(name + id + <span class="string">&quot;i am working&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bonus + salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommonEmployee</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonEmployee</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, id, salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">work</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        System.out.println(name + id +<span class="string">&quot;i am working&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象模板模式"><a href="#抽象模板模式" class="headerlink" title="抽象模板模式"></a><font color="#5cb85c">抽象模板模式</font></h3><p>需求：</p>
<ol>
<li>有多个类，完成不同的任务job</li>
<li>要求能够得到各自完成任务的时间</li>
<li>请编程实现</li>
</ol>
<mark class="hl-label blue">问题引出</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 抽象模板模式 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        aa.job();</span><br><span class="line"></span><br><span class="line">        <span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        bb.job();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="comment">//计算任务</span></span><br><span class="line">    <span class="comment">//1+……+10000；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//得到开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> time1 - time;</span><br><span class="line">        System.out.println(<span class="string">&quot;花费时间&quot;</span> + time2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//得到开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> time1 - time;</span><br><span class="line">        System.out.println(<span class="string">&quot;花费时间&quot;</span> + time2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要统计多个对象的job时间代码重复度高，可用模板模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 抽象模板模式 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        aa.calculateTime();</span><br><span class="line"></span><br><span class="line">        <span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">        bb.calculateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="comment">//计算任务</span></span><br><span class="line">    <span class="comment">//1+……+10000；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Job</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//得到开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Job();<span class="comment">//子类重写就会调用子类的job,从而实现代码复用度高</span></span><br><span class="line">        <span class="comment">//得到结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> time1 - time;</span><br><span class="line">        System.out.println(<span class="string">&quot;花费时间&quot;</span> + time2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">注意</mark> ：

<p>动态绑定机制，不一定需要有多态，只要是继承关系，就会使用。应该是任何情况下。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><font color="#6dc1f7">接口</font></h2><ul>
<li>为什么有接口</li>
</ul>
<p><img src="/images/image-20220811135132731.png" alt="image-20220811135132731"></p>
<ul>
<li>基本介绍</li>
</ul>
<p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。语法：<br>interface 接口名{</p>
<p>​	&#x2F;&#x2F;属性名</p>
<p>​	&#x2F;&#x2F;抽象方法</p>
<p>}</p>
<p>class 类名 implements 接口 {</p>
<p>​	自己属性；</p>
<p>​	自己方法；</p>
<p>​	必须实现的接口的抽象方法</p>
<p>}</p>
<p>小结：接口是更加抽象的抽象的类，抽象类里面的方法可以有方法体，接口里的所有方法都没有方法体[jdk7.0].接口体现了程序设计的多态的高内聚低偶合的设计思想。<br>特别说：jdk8.0后接口类可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现。 </p>
<p><img src="/images/image-20220811145509931.png" alt="image-20220811145509931"></p>
<mark class="hl-label blue">注意</mark> ：

<p>implements关键字就是实现的意思，所以叫实现接口</p>
<p>default是默认方法关键字，也可重写 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">hh</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hh</span><span class="params">()</span> &#123;</span><br><span class="line">    Usb.<span class="built_in">super</span>.hh();</span><br><span class="line">    System.out.println(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是接口方法，下面是重写。</p>
<p>static静态方法不能被重写。</p>
<ul>
<li>接口快速入门</li>
</ul>
<p>这样的设计需求在Java编程&#x2F;php&#x2F;.net&#x2F;go中也是会大量存在的，我曾经说过，一个程序就是一个世界，在现实世界存在的情况，在程序中也会出现，我们用程序来模拟一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="comment">//规定相关方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;<span class="comment">//方法默认是 public abstract的所以不用写也没事</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Usb</span>设备<span class="number">1</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机断开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Usb</span>设备<span class="number">2</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;</span><br><span class="line">    <span class="comment">//这里就相当于使用usb这个规范，就比如现实世界中，</span></span><br><span class="line">    <span class="comment">// 手柄有usb接口可用，要有这个接口就必须符合它制定的规范</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手柄启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手柄断开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Usb</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Usb</span>设备<span class="number">1</span>();</span><br><span class="line">        Usb设备<span class="number">1</span> usb设备<span class="number">1</span> = <span class="keyword">new</span> <span class="title class_">Usb</span>设备<span class="number">1</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Computer</span>().work(usb);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Computer</span>().work(usb设备<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Usb usb)</span> &#123;</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果当然都是Usb设备1里面的内容啦。</p>
<p>进一步证明动态绑定机制的重要性。</p>
<ul>
<li>深入探讨</li>
</ul>
<p>难的是不知道什么时候能使用接口</p>
<ol>
<li>说现在要制造战斗机，武装直升机，专家只需要把飞机需要的功能&#x2F;规定定下来即可，然后让别人具体实现就可以</li>
<li>说现在有一个项目经理，管理三个程序员，功能开发一个软甲，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员具体实现。<br>实际要求：3个程序员，编写三个类，分别完成对Mysql，Oracle，DB2数据库的连接 connect，close。。。<br><img src="/images/image-20220811152031678.png" alt="image-20220811152031678"><br>就是一种规定和管理，这里管理程序员的方法名。</li>
</ol>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a><font color="#5cb85c">使用细节</font></h3><ol>
<li>接口不能被实例化</li>
<li>接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰<br><img src="/images/image-20220811152836644.png" alt="image-20220811152836644"></li>
<li>一个普通类实现接口，就必须将接口的所有方法都是实现。默认方法已经有方法体就不用实现，重不重写都可以，static方法一定不能重写。</li>
<li>抽象类实现，可以不用实现接口的方法(抽象类可以包含抽象方法。)</li>
<li>一个类同时可以实现多个接口</li>
<li>接口中的属性，只能是final的，而且是public static final 修饰符。比如：int a &#x3D; 1；实际上是public static final int a &#x3D; 1；(必须初始化)</li>
<li>接口中属性的访问形式:接口名.属性名</li>
<li>一个接口不能继承其他的类，但是可以继承多个别的接口<br><img src="/images/image-20220811154207966.png" alt="image-20220811154207966"></li>
<li>接口的修饰符只能是public 和默认，这点和类的修饰符是一样的。</li>
</ol>
<h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a><font color="#5cb85c">课堂练习</font></h3><p><img src="/images/image-20220811161737651.png" alt="image-20220811161737651"></p>
<mark class="hl-label blue">注意</mark> ：

<p>重要概念，static修饰的可以被继承和引用，但是不能重写，<font color="EE3F4D">static是可以被继承和引用的。</font></p>
<h3 id="接口VS继承"><a href="#接口VS继承" class="headerlink" title="接口VS继承"></a><font color="#5cb85c">接口VS继承</font></h3><h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常-Exception"></a><font color="#6dc1f7">异常-Exception</font></h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><font color="#5cb85c">基本概念</font></h3><blockquote>
<p>Java语言中，将程序执行中发生的不正常情况称为“<mark class="hl-label default">异常</mark> ”。(开发过程中的语法错误和逻辑错误不是异常)。</p>
<p>执行过程中所发生的异常事件可分为两类</p>
<p>1)Error(错误)：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError[栈溢出]和OOM(out of memory)，Error是严重错误，程序会崩溃。</p>
<p>2)Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等。Exception分为两大类：运行时异常[]和编译时异常[]。</p>
</blockquote>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1、num1/num2 = 10/0</span></span><br><span class="line">    <span class="comment">//2、当程序执行到num1/num2时，因为分母为0程序会抛出异常 ArithmeticException</span></span><br><span class="line">    <span class="comment">//3、当抛出异常后，程序退出，崩溃了，下面的代码就不在运行</span></span><br><span class="line">    <span class="comment">//4、但是这样并不好，一个不致命的错误就导致整个代码奔溃</span></span><br><span class="line">    <span class="comment">//5、java设计者，提供了一个叫 异常处理机制来解决该问题</span></span><br><span class="line">    <span class="comment">//如果程序员，认为一段代码可能出现异常/问题，可以使用try-catch异常处理机制来解决</span></span><br><span class="line">    <span class="comment">//保证代码的健壮度</span></span><br><span class="line">    <span class="comment">//idea快捷键 ctrl + alt + t -&gt; 选中try-catch</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> num1 / num2 ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();       </span><br><span class="line">        System.out.println(e.getMessage());  <span class="comment">//输出异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;代码继续运行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">结果</mark> ：

<p><img src="/images/image-20220607154948429.png" alt="image-20220607154948429"></p>
<mark class="hl-label purple">总结</mark> ：

<p>可以看到这个代码有异常出现的时候还能继续执行下面。异常保证了代码的健壮度。</p>
<h3 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a><font color="#5cb85c">异常体系图</font></h3><p><img src="/images/image-20220607155937584.png" alt="image-20220607155937584"></p>
<p><img src="/images/image-20220607155703202.png" alt="image-20220607155703202"></p>
<mark class="hl-label purple">总结</mark> ：

<p>该图只是举例几个常见的异常，还有很多异常。总体上继承Throwable这个类，然后这个类实现了Serializable接口的方法。有编译时候异常，运行时候异常。还有一大类就是错误。</p>
<h2 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a><font color="#6dc1f7">事件处理机制</font></h2><p>收录到文章<font color="#1661AB">坦克大战</font>中。</p>
<h2 id="八大Wrapper-包装-类"><a href="#八大Wrapper-包装-类" class="headerlink" title="八大Wrapper(包装)类"></a><font color="#6dc1f7">八大Wrapper(包装)类</font></h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a><font color="#5cb85c">包装类</font></h3><ul>
<li>包装类的分类</li>
</ul>
<ol>
<li>针对八种基本数据类型相应的引用类型——包装类</li>
<li>有了类的特点，就可以调用类中的方法</li>
</ol>
<p><img src="/images/image-20220712125028970.png" alt="image-20220712125028970"></p>
<mark class="hl-label blue">解析</mark> ：

<p>黄色区域的父类都是：Number。</p>
<p>由于都是类就可以调用其中许多方法。</p>
<mark class="hl-label red">Boolean</mark> ：-> boolean

<p><img src="/images/image-20220712153022330.png" alt="image-20220712153022330"></p>
<mark class="hl-label purple">Character</mark> ： -> char

<p><img src="/images/image-20220712153213992.png" alt="image-20220712153213992"></p>
<mark class="hl-label blue">Number</mark> ： -> Byte、Short 、Integer 、Long、Float、Double

<p><img src="/images/image-20220712154422681.png" alt="image-20220712154422681"> </p>
<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a><font color="#5cb85c">装箱和拆箱</font></h3><ul>
<li>包装类和基本数据的转换<ol>
<li>jdk5前的手动装箱和拆箱方式，装箱：基本类型-&gt;包装类型，反之，拆箱</li>
<li>jdk5以后(含jdk5)的自动装箱和拆箱方式</li>
<li>自动装箱底层调用的是valueOf方法，比如Integer.valueOf()</li>
</ol>
</li>
</ul>
<mark class="hl-label blue">案例Integer</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//jdk5以前是手动拆箱和装箱</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);<span class="comment">//手动装箱</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1);<span class="comment">//手动装箱</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();<span class="comment">//手动拆箱</span></span><br><span class="line">    <span class="comment">//jdk5和jdk5以后就可以自动装箱和拆箱</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> n2; <span class="comment">//自动装箱  底层用的是Integer.valueOf(int int); 断点调试</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> integer2; <span class="comment">// 自动拆箱，底层仍然使用的是intValue()方法 .断点调试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">断点Debug</mark> ：

<p><img src="/images/image-20220712163144537.png" alt="image-20220712163144537"></p>
<p><img src="/images/image-20220712163500982.png" alt="image-20220712163500982"></p>
<blockquote>
<p>其他包装类的用法类似。</p>
</blockquote>
<mark class="hl-label purple">练习</mark> ：

<p><img src="/images/image-20220712193431936.png" alt="image-20220712193431936"></p>
<mark class="hl-label red">知识补充</mark> ：

<blockquote>
<p>添加尾缀说明</p>
<p>Java在变量赋值的时候，其中float、double、long数据类型变量，需要在赋值直接量后面分别添加f或F、d或D、l或L尾缀来说明。其中，long类型最好以大写L来添加尾缀，因为小写l容易和数字1混淆。</p>
</blockquote>
<p><img src="/images/image-20220712194150836.png" alt="image-20220712194150836"></p>
<mark class="hl-label red">注意</mark> ：

<blockquote>
<p>三元运算符是一个整体，虽然输出int类型，但是整体已经上升到double的精度。</p>
</blockquote>
<p><img src="/images/image-20220712200702129.png" alt="image-20220712200702129"></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><font color="#6dc1f7">集合</font></h2><p><img src="/images/image-20220722115722496.png" alt="image-20220722115722496"></p>
<h3 id="集合介绍"><a href="#集合介绍" class="headerlink" title="集合介绍"></a><font color="#5cb85c">集合介绍</font></h3><mark class="hl-label purple">集合的理解和好处</mark> ：

<p>前面我们保存多个数据使用的是数组，那么数组有不足的地方，我们分析一下。</p>
<ul>
<li>数组</li>
</ul>
<ol>
<li>长度开始时必须指定，而且一旦指定，不能更改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行增加&#x2F;删除元素的示意代码–比较麻烦</li>
</ol>
<mark class="hl-label purple">案例</mark> ：

<p>&#x2F;&#x2F;增加新的Person对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] pers2 = <span class="keyword">new</span> <span class="title class_">Person</span>[pers1.length+<span class="number">1</span>]; <span class="comment">//创建新的数组：长度比原来多一</span></span><br><span class="line"><span class="keyword">for</span>&#123;&#125; <span class="comment">//拷贝数组</span></span><br><span class="line">pers2[pers2.length-<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//添加新增的对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>集合</li>
</ul>
<ol>
<li>可以<font color="EE3F4D">动态保存</font>任意多个对象，使用比较方便！</li>
<li>提供了一系列方便的操作对象的方法：add、remove、set、get等</li>
<li>使用集合添加，删除新元素的示意代码–简洁了</li>
</ol>
<h3 id="集合体系图"><a href="#集合体系图" class="headerlink" title="集合体系图"></a><font color="#5cb85c">集合体系图</font></h3><p><img src="/images/image-20220711231316037.png" alt="image-20220711231316037"></p>
<ol>
<li>集合主要是两组(单列集合，双列集合)</li>
<li>Collection  接口有两个重要的子接口 List Set(如上图所示)，他们的实现子类都是单列集合</li>
<li>Map 接口的实现子类 是双列集合，存放的&lt;K,V&gt; (如下图所示)</li>
</ol>
<p><img src="/images/image-20220712113701593.png" alt="image-20220712113701593"></p>
<mark class="hl-label purple">示例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collection01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">// Collection</span></span><br><span class="line">       <span class="comment">// Map</span></span><br><span class="line">        ArrayList&lt;Object&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;lwt&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="number">1</span>,<span class="string">&quot;lwt&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="number">2</span>,<span class="string">&quot;lwt2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collection方法"><a href="#Collection方法" class="headerlink" title="Collection方法"></a><font color="#5cb85c">Collection方法</font></h3><ul>
<li>Collection接口实现类的特点：</li>
</ul>
<p>​		public interface Collection&lt; E &gt; extends Iterable&lt; E &gt;</p>
<ol>
<li>Collection实现子类可以存放多个元素，每个元素可以是Object</li>
<li>有些Collection的实现类，可以存放重复的元素，有些不可以</li>
<li>有些Collection的实现类，有些是有序的(List),有些不是有序(Set)</li>
<li>Collection接口没有直接的实现子类，是通过它的接口Set和List来实现的</li>
</ol>
<ul>
<li>Collection接口常用方法，以实现子类</li>
</ul>
<ol>
<li>add:添加单个元素<font color="681752">（返回boolean值）</font></li>
<li>remove:删除指定元素<font color="681752">（返回boolean值）</font></li>
<li>contains:查找元素是否存在<font color="681752">（返回boolean值）</font></li>
<li>size:获取元素个数<font color="681752">（返回长度int）</font></li>
<li>isEmpty:判断是否为空<font color="681752">（返回boolean值）</font></li>
<li>clear:清空<font color="681752">（void）</font></li>
<li>addAll:添加多个元素<font color="681752">（传入集合，返回boolean值）</font></li>
<li>containAll:查找多个元素是否都存在<font color="681752">（传入集合，返回boolean值）</font></li>
<li>removeAll:删除多个元素<font color="681752">（传入集合，返回boolean值）</font></li>
</ol>
<mark class="hl-label purple">ArrayList演示</mark> ：

<p>因为只有实现了这个接口的类才可以被实例化，选用ArrayList集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionMethod01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// add:添加单个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="number">10</span>); <span class="comment">//自动装箱 变成Integer</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="literal">true</span>);<span class="comment">//自动装箱</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// remove: 删除对象</span></span><br><span class="line">        list.remove(<span class="string">&quot;jack&quot;</span>); <span class="comment">//指定删除某个对象，并返回boolean值。这里就删除第一个jack不会删除两个jack</span></span><br><span class="line">        list.remove(<span class="number">0</span>); <span class="comment">//根据索引删除 。这里删除第0位置的元素,并返回删除元素Object</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//contains: 查找元素是否存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="literal">true</span>)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//size: 集合的长度 获取元素的个数</span></span><br><span class="line">        System.out.println(list.size()); <span class="comment">//2</span></span><br><span class="line">        <span class="comment">//isEmpty: 判断元素是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());<span class="comment">// false</span></span><br><span class="line">        <span class="comment">//clear: 清空</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//addAll: 添加多个元素。传入一个集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list2.add(<span class="string">&quot;qwer&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        <span class="comment">//containsAll: 查找多个元素是否存在,传入的是一个集合</span></span><br><span class="line">        System.out.println(list.containsAll(list2)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//removeAll: 删除多个元素 ，也是传入一个集合</span></span><br><span class="line">        list.add(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line">        list.removeAll(list2); <span class="comment">//返回boolean值</span></span><br><span class="line">        System.out.println(list); <span class="comment">// &quot;ssss&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a><font color="#5cb85c">迭代器遍历</font></h3><ul>
<li><p>Collection接口遍历元素<font color="#EE4866">方式1-使用Iterator(迭代器)</font></p>
<p>基本介绍：</p>
<p><img src="/images/image-20220714132634184.png" alt="image-20220714132634184"></p>
<ol>
<li>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。</li>
<li>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器。</li>
<li>Iterator的结构图。</li>
<li>Iterator仅用于遍历集合，Iterator本身并不存放对象。</li>
</ol>
</li>
<li><p>迭代器的执行原理</p>
</li>
</ul>
<p>​		Iterator iterator &#x3D; coll.iterator();  &#x2F;&#x2F;<code>iterator();</code><font color="#EE4866">返回一个迭代器Iterator</font>。</p>
<p>​		&#x2F;&#x2F;hasNext();判断是否还有下一个元素,这是<font color="#EE4866">迭代器里面的方法</font>,从-1开始。</p>
<p>​		while(iterator.hasNext()){</p>
<p>​		&#x2F;&#x2F;next(); 1、指针下移 2 、将下移后集合指针位置上的元素返回</p>
<p>​		System.out.println(iterator.next());</p>
<p>​		}</p>
<p><img src="/images/image-20220714150451660.png" alt="image-20220714150451660"></p>
<p><img src="/images/image-20220714151718187.png" alt="image-20220714151718187"></p>
<mark class="hl-label red">注意</mark> ：

<p>在调用iterator.next()方法之前必须要调用iterator.hasNext()进行检测。若不调用，且下一条记录无效，直接调用iterator.next()会抛出NoSuchElementException异常。</p>
<mark class="hl-label purple">演示</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;西游记&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>,<span class="number">89</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;你在干什么&quot;</span>,<span class="string">&quot;氢气球&quot;</span>,<span class="number">998</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;配哦我看到看到&quot;</span>,<span class="string">&quot;威威企鹅&quot;</span>,<span class="number">9878</span>));</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="comment">//1、得到集合的迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span>col.iterator();</span><br><span class="line">        <span class="comment">//2、使用while集合遍历集合</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//返回下一个元素，类型的Object</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(obj);  <span class="comment">//这里涉及到动态绑定机制，obj编译类型确实是Object类，运行类型是book</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快捷键（itit）  或者ctrl+J 可以提示当前的快捷键</span></span><br><span class="line">        <span class="comment">//3、当迭代器退出while循环后，这时候iterator迭代器指向最后一个元素</span></span><br><span class="line">        iterator.next(); <span class="comment">//在取一个就会超出，报出异常NoSuchElementException</span></span><br><span class="line">        <span class="comment">//4、如果需要再次遍历集合，需要重置遍历器</span></span><br><span class="line">        iterator = col.iterator(); <span class="comment">//重置遍历器</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">book</span><span class="params">(String name, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p><code>iterator.next();</code>返回的是Object类型，在<code>print</code>的时候会调用toString，因为book是Object的子类，并且也有重写toString。这是动态绑定机制，最终调用book里面的toString方法完成<code>print</code>。迭代器的快捷键是itit。其他快捷键是<code>Ctrl加J</code>。</p>
<ul>
<li>Collection接口遍历对象<font color="#EE4866">方式2-for循环增强</font></li>
</ul>
<p>​		增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样。<font color="#EE4866">只能用于遍历集合或数组</font>。</p>
<p>​	基本语法</p>
<p>​	for(元素类型 元素名：集合名或数组名) {</p>
<p>​		访问元素</p>
<p>​	}</p>
<mark class="hl-label purple">演示</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionFor</span>遍历 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;西游记&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>,<span class="number">89</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;你在干什么&quot;</span>,<span class="string">&quot;氢气球&quot;</span>,<span class="number">998</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">book</span>(<span class="string">&quot;配哦我看到看到&quot;</span>,<span class="string">&quot;威威企鹅&quot;</span>,<span class="number">9878</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用增强for遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Object book : col) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//增强for也可以直接在数组上使用</span></span><br><span class="line">        <span class="type">int</span> [] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j: nums) &#123;</span><br><span class="line">            System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Debug源码来证明</p>
<p><img src="/images/image-20220714203113831.png" alt="image-20220714203113831"></p>
<p><img src="/images/image-20220714203125711.png" alt="image-20220714203125711"></p>
<p><img src="/images/image-20220714203228508.png" alt="image-20220714203228508"></p>
<mark class="hl-label purple">小结</mark> ：

<ol>
<li>可以得到增强for<font color="#EE4866">底层原理是iterator迭代器</font>。</li>
<li>增强for可以理解成简化版本的迭代器遍历。</li>
<li>快捷键是大写<font color="#EE4866"> I</font>。</li>
</ol>
<mark class="hl-label blue">课堂练习</mark> ：

<blockquote>
<p>1、创建3个Dog{name,age}对象,放入到ArrayList中,赋给List引用<br>2、用迭代器和增强for循环两种方式来遍历<br>3、重写Dog的toString方法,输出name和age</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collection</span>课堂练习 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;Object&gt; collection = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//向上转型</span></span><br><span class="line">        collection.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;lwt&quot;</span>,<span class="number">11</span>));</span><br><span class="line">        collection.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;牧羊犬&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        <span class="keyword">for</span> (Object o : collection) &#123;<span class="comment">//增强for</span></span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();<span class="comment">//迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">Dog</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(Dog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>集合由于有许多接口，用到许多多态写法<code>Iterable list = new ArrayList&lt;&gt;();</code>这种写法也是可以的。但是<code>Iterable</code>中没有<code>add()</code>等方法。</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a><font color="#5cb85c">List接口</font></h3><ul>
<li>List接口基本介绍</li>
</ul>
<p>​	List接口是Collection接口的子接口</p>
<ol>
<li>List集合类中元素<font color="#EE4866">有序(即添加顺序和取出顺序一致)、且可重复</font>。</li>
<li>List集合中的每个元素都有其对应的顺序索引，即支持索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类有：</li>
</ol>
<p><img src="/images/image-20220714212356328.png" alt="image-20220714212356328"></p>
<mark class="hl-label blue">案例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、List集合类中元素有序(即添加顺序和取出顺序一致)、且可重复[案例]</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;milk&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[jack, tom, milk, mary]</span></span><br><span class="line">        <span class="comment">//2、List集合中的每个元素都有其对应的顺序索引，即支持索引</span></span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>)); <span class="comment">//当然索引是从0开始的 得到jack</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>List接口的常用方法</li>
</ul>
<p>​	List集合里添加了一些根据索引来操作集合元素的方法</p>
<ol>
<li>void add(int index, Object ele):在index位置插入ele元素,没有索引默认加在最后</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index): 获取指定index位置的元素</li>
<li>int indexOf(Object obj): 返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj): 返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele): 设置指定index位置的元素为ele，相当于是替换，返回被删除的元素</li>
<li>List subList(int fromIndex, int toIndex): 返回从fromIndex到toIndex位置的子集合</li>
</ol>
<mark class="hl-label blue">演示</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//多态写法，向上转型</span></span><br><span class="line">        list.add(<span class="string">&quot;小狗&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;小猫&quot;</span>);</span><br><span class="line"><span class="comment">//        1. void add(int index, Object ele):在index位置插入ele元素,没有索引默认加在最后</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;小狼&quot;</span>); <span class="comment">//注意是从0开始索引就行</span></span><br><span class="line">        System.out.println(list); <span class="comment">//[小狗, 小狼, 小猫]</span></span><br><span class="line"><span class="comment">//        2. boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;milk&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.addAll(list1);</span><br><span class="line">        System.out.println(list);<span class="comment">//[小狗, 小狼, 小猫, mary, milk, tom]</span></span><br><span class="line"><span class="comment">//        3. Object get(int index): 获取指定index位置的元素</span></span><br><span class="line">        System.out.println(list.get(<span class="number">1</span>)); <span class="comment">//&quot;小狼&quot;</span></span><br><span class="line"><span class="comment">//        4. int indexOf(Object obj): 返回obj在集合中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;小猫&quot;</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//        5. int lastIndexOf(Object obj): 返回obj在当前集合中末次出现的位置</span></span><br><span class="line">        list.add(<span class="string">&quot;小猫&quot;</span>);</span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;小猫&quot;</span>));<span class="comment">//6</span></span><br><span class="line"><span class="comment">//        6. Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        System.out.println(list.remove(<span class="number">2</span>));<span class="comment">//小猫</span></span><br><span class="line"><span class="comment">//        7. Object set(int index, Object ele): 设置指定index位置的元素为ele，相当于是替换。</span></span><br><span class="line">        System.out.println(list.set(<span class="number">5</span>, <span class="string">&quot;Tom&quot;</span>));<span class="comment">//返回被删除的对象</span></span><br><span class="line"><span class="comment">//        8. List subList(int fromIndex, int toIndex): 返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        System.out.println(list.subList(<span class="number">0</span>, <span class="number">3</span>));<span class="comment">//[小狗, 小狼, mary]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">练习</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    添加10个以上的元素(比如String &quot;hello&quot;)，</span></span><br><span class="line"><span class="comment">    在2号位插入一个元素&quot;韩顺平教育&quot;，获得第5个元素，删除第6个元素，</span></span><br><span class="line"><span class="comment">    修改第7个元素，在使用迭代器遍历集合，要求:使用List的实现类ArrayList完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List</span>练习 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//多态写法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;hello&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;韩顺平教育&quot;</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">4</span>));</span><br><span class="line">        list.remove(<span class="number">5</span>);</span><br><span class="line">        list.set(<span class="number">6</span>,<span class="string">&quot;修改&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.print(next+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>注意一下索引和位置的差别，索引从0开始</p>
<h4 id="List遍历"><a href="#List遍历" class="headerlink" title="List遍历"></a><font color="#ffd253">List遍历</font></h4><ul>
<li>List的三种遍历方式</li>
</ul>
<ol>
<li><p>方式一：使用iterator</p>
<p>Iterator iter &#x3D; col.iterator();</p>
<p>​		while(iter.hasNext()){</p>
<p>​			Object o &#x3D; iter.next();</p>
<p>​		}</p>
</li>
<li><p>方式二：使用增强for<br>for(Object o : col){<br>}</p>
</li>
<li><p>方式三： 使用普通for<br>for(int i&#x3D;0; i&lt;list.size(); i++){</p>
<p>Object object &#x3D; list.get(i);</p>
<p>System.out.println(Object);<br>}</p>
</li>
</ol>
<p>	</p>
<mark class="hl-label blue">说明</mark> ：

<p>使用<font color="#0F59A4">List子类</font>的完成使用方式和ArrayList一样，都能使用这三种方式。</p>
<mark class="hl-label blue">演示</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List</span>遍历 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;mike&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、迭代器iterator遍历</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="comment">//2、增强for</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="comment">//3、普通for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">练习</mark> ：

<p><img src="/images/image-20220715143755603.png" alt="image-20220715143755603"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">List</span>练习<span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//      List&lt;Book7&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">//      List&lt;Book7&gt; list = new LinkedList&lt;&gt;();</span></span><br><span class="line">        List&lt;Book7&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//使用了泛型，list里面不是Object所以就不用向下转型</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book7</span>(<span class="string">&quot;水浒传&quot;</span>,<span class="number">99</span>,<span class="string">&quot;施耐庵&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book7</span>(<span class="string">&quot;西游记&quot;</span>,<span class="number">77</span>,<span class="string">&quot;吴承恩&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book7</span>(<span class="string">&quot;三国演义&quot;</span>,<span class="number">120</span>,<span class="string">&quot;罗贯中&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book7</span>(<span class="string">&quot;ss&quot;</span>,<span class="number">2</span>,<span class="string">&quot;s&quot;</span>));</span><br><span class="line">        sort(list);</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;Book7&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">Book7</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; list.size()-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(j).getPrice() &gt; list.get(j+<span class="number">1</span>).getPrice()) &#123;</span><br><span class="line">                    temp = list.get(j);</span><br><span class="line">                    list.set(j,list.get(j+<span class="number">1</span>));</span><br><span class="line">                    list.set(j+<span class="number">1</span>,temp);</span><br><span class="line">                    <span class="comment">//或者将交换的对象都赋给Book7类，这样不用temp</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book7</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book7</span><span class="params">(String name, <span class="type">double</span> price, String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>这里使用了泛型，不用泛型在取<code>price</code>的时候需要向下转型。使用<code>Vector</code> <code>LinkedList</code> ，只需将<code>ArrayList</code>换成对应即可，这是多态的一个好处:易扩展和维护。</p>
<h4 id="ArrayList的注意事项"><a href="#ArrayList的注意事项" class="headerlink" title="ArrayList的注意事项"></a><font color="#ffd253">ArrayList的注意事项</font></h4><ul>
<li>ArrayList的注意事项</li>
</ul>
<ol>
<li>permits all elements, including null, Arraylist可以加入null,并且多个</li>
<li>ArrayList 是由数组来实现数据存储的</li>
<li>Arraylist基本等同于Vector，除了ArrayList是线程不安全(执行效率高)看源码，在多线程情况下，不建议使用ArrayList</li>
</ol>
<p><img src="/images/image-20220715143715733.png" alt="image-20220715143715733"></p>
 <mark class="hl-label blue">解释</mark> ：

<p>可以看到add方法前面没有synchronized(同步锁)，所以他线程不安全。</p>
<p><img src="/images/image-20220715144252948.png" alt="image-20220715144252948"></p>
<p>这是Vector集合的add方法。用有synchronized(同步锁)。</p>
<h4 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a><font color="#ffd253">ArrayList扩容机制</font></h4><ul>
<li>ArrayList的底层操作机制源码分析<font color="#FBDA41">(重难点)</font></li>
</ul>
<ol>
<li>ArrayList中维护了一个Object类型的数组elementData.[debug看源码]<br>transient Object[] elementData; &#x2F;&#x2F;transient 表示瞬间，短暂的，表示该属性不会被序列化</li>
<li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第1次<br>添加，则扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍。</li>
<li>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，<br>则直接扩容elementData为1.5倍。</li>
</ol>
<h4 id="ArrayList底层源码"><a href="#ArrayList底层源码" class="headerlink" title="ArrayList底层源码"></a><font color="#ffd253">ArrayList底层源码</font></h4> <mark class="hl-label blue">代码</mark> ：

<p>无参构造器的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListsource</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        ArrayList list = new ArrayList(9);</span></span><br><span class="line">        <span class="comment">//使用无参构造创建ArrayList</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add( i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        list.add(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ArrayList%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81.png"></p>
 <mark class="hl-label red">注意</mark> ：

<ol>
<li>这是JDK8的源码，不同版本的JDK版本源码不同。</li>
<li>其中size参数是ArrayList数组中包含的元素(不是容量)。</li>
<li>每次都有一个minCapacity，即size+1。</li>
<li>二进制数&gt;&gt;1，相当于&#x2F;2 。</li>
</ol>
<p>有参构造器源码：</p>
<p><img src="/images/image-20220716203219198.png" alt="image-20220716203219198"></p>
 <mark class="hl-label blue">解释和对比</mark> ：

<p>有参构造器的参数是改变elementData数组的长度，第一次扩容就是根据参数的大小扩大1.5倍。</p>
<p>区别：无参构造器第一次<code>DEFAULT_CAPACITY</code>作为容量默认为10，而有参构造器根据参数。</p>
<h4 id="Vector注意事项"><a href="#Vector注意事项" class="headerlink" title="Vector注意事项"></a><font color="#ffd253">Vector注意事项</font></h4><ul>
<li>Vector的基本介绍</li>
</ul>
<ol>
<li>Vector类的定义说明<br><img src="/images/image-20220716204159197.png" alt="image-20220716204159197"></li>
<li>Vector底层也是一个对象数组，protected Object[] elementData</li>
<li>Vector是线程同步的，即线程安全、Vector类的操作方法(get、set等)带有synchronized（同步锁）</li>
<li>在开发中，需要<font color="D2568C">线程同步安全</font>&gt;时，考虑使用Vector</li>
</ol>
<h4 id="Vector源码解读"><a href="#Vector源码解读" class="headerlink" title="Vector源码解读"></a><font color="#ffd253">Vector源码解读</font></h4><ul>
<li>Vector和ArrayList的比较</li>
</ul>
<p><img src="/images/image-20220716204929859.png" alt="image-20220716204929859"></p>
 <mark class="hl-label blue">代码</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//无参构造器</span></span><br><span class="line">        <span class="comment">//Vector vector = new Vector&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//源码</span></span><br><span class="line"><span class="comment">//        public Vector() &#123;</span></span><br><span class="line"><span class="comment">//            this(10);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">Vector</span> <span class="variable">vector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//源码</span></span><br><span class="line"><span class="comment">//        public Vector(int initialCapacity) &#123;</span></span><br><span class="line"><span class="comment">//            this(initialCapacity, 0);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        public Vector(int initialCapacity, int capacityIncrement) &#123;</span></span><br><span class="line"><span class="comment">//            super();</span></span><br><span class="line"><span class="comment">//            if (initialCapacity &lt; 0)</span></span><br><span class="line"><span class="comment">//                throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span></span><br><span class="line"><span class="comment">//                        initialCapacity);</span></span><br><span class="line"><span class="comment">//            this.elementData = new Object[initialCapacity];</span></span><br><span class="line"><span class="comment">//            this.capacityIncrement = capacityIncrement;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector.add(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//集合扩容源码</span></span><br><span class="line"><span class="comment">//        private void grow(int minCapacity) &#123;</span></span><br><span class="line"><span class="comment">//            // overflow-conscious code</span></span><br><span class="line"><span class="comment">//            int oldCapacity = elementData.length;</span></span><br><span class="line"><span class="comment">//            int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span></span><br><span class="line"><span class="comment">//                    capacityIncrement : oldCapacity);</span></span><br><span class="line"><span class="comment">//            if (newCapacity - minCapacity &lt; 0)</span></span><br><span class="line"><span class="comment">//                newCapacity = minCapacity;</span></span><br><span class="line"><span class="comment">//            if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span></span><br><span class="line"><span class="comment">//                newCapacity = hugeCapacity(minCapacity);</span></span><br><span class="line"><span class="comment">//            elementData = Arrays.copyOf(elementData, newCapacity);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label red">注意</mark> ：

<p>有参构造器与无参构造器的区别是：传入了一个<code>initialCapacity</code>并调用另外一个构造器，并用这个数确定<code>elementData</code>数组的大小。</p>
<p><img src="/images/image-20220717110233997.png" alt="image-20220717110233997"></p>
<p><img src="/images/image-20220717110252747.png" alt="image-20220717110252747"></p>
<p>其余都和ArrayLIst差不多，grow有些许不同。</p>
<p><img src="/images/image-20220717110423186.png" alt="image-20220717110423186"></p>
<h4 id="LinkedList底层结构"><a href="#LinkedList底层结构" class="headerlink" title="LinkedList底层结构"></a><font color="#ffd253">LinkedList底层结构</font></h4><ul>
<li>LinkedList的全面说明</li>
</ul>
<ol>
<li>LinkedList底层实现了双向链表和双端队列特点</li>
<li>可以添加任意元素(元素可以重复)，包括null</li>
<li>线程不安全，没有实现同步</li>
</ol>
<ul>
<li>LinkedList的底层操作机制</li>
</ul>
<ol>
<li>LinkedList底层维护了一个双向链表。</li>
<li>LinkedLIst中维护了两个属性first和last分别指向首节点和尾节点。</li>
<li>每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过<br>prev指向前一个，通过next指向后一个节点。最终实现双向链表。</li>
<li>所以LinkedList的元素的添加元素删除，不是通过数组完成的，相对来说效率高。</li>
</ol>
 <mark class="hl-label blue">模拟双向链表</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">mike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">marry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Marry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      tom-&gt;mike-&gt;mike</span></span><br><span class="line">        tom.next = mike;</span><br><span class="line">        mike.next = marry;</span><br><span class="line"><span class="comment">//      marry-&gt;mike-&gt;tom</span></span><br><span class="line">        marry.prev = mike;</span><br><span class="line">        mike.prev = tom;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      首尾定义</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> tom;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> marry;</span><br><span class="line"><span class="comment">//      遍历(从头到尾)</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(first);</span><br><span class="line">                first = first.next; <span class="comment">//指向下一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                first = tom;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      遍历(从尾到头)</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="literal">null</span>) &#123;</span><br><span class="line">                last = marry;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(last);</span><br><span class="line">            last = last.prev;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      链表优越的地方，添加和删除元素</span></span><br><span class="line"><span class="comment">//      在mike和marry中间加元素</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">sss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;SSS&quot;</span>);</span><br><span class="line">        mike.next = sss;</span><br><span class="line">        sss.next = marry;</span><br><span class="line"></span><br><span class="line">        marry.prev = sss;</span><br><span class="line">        sss.prev = mike;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(first);</span><br><span class="line">                first = first.next; <span class="comment">//指向下一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                first = tom;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Node类,被实例化的Node对象可以当作一个双向链表的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object item; <span class="comment">//真正存放数据的地方</span></span><br><span class="line">    <span class="keyword">public</span> Node next; <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> Node prev; <span class="comment">//指向前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;item=&quot;</span> + item +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedList源码"><a href="#LinkedList源码" class="headerlink" title="LinkedList源码"></a><font color="#ffd253">LinkedList源码</font></h4><ul>
<li>LinkedList的增删改查案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        linkedList.add(<span class="number">1</span>);</span><br><span class="line">        linkedList.add(<span class="number">2</span>);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//默认删除的是第一个结点</span></span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">        linkedList.set(<span class="number">1</span>,<span class="number">999</span>);<span class="comment">//注意索引也是从0开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器底层源码</li>
</ul>
<p><img src="/images/image-20220718153426938.png" alt="image-20220718153426938"></p>
<p><img src="/images/image-20220718153415913.png" alt="image-20220718153415913"></p>
 <mark class="hl-label red">注意</mark> ：

<p>构造器创建后有四个参数：size,first,last,modCount。无参默认都为0；而他另一个有参构造器源码如下，调用无参构造器，和<code>addAll();</code>方法。</p>
<p><img src="/images/image-20220718154122054.png" alt="image-20220718154122054"></p>
 <mark class="hl-label red">注意</mark> ：

<p>其中<code>&lt;? extends E&gt;</code>指的是E这个类和其子类。</p>
<ul>
<li>LinkedList <code>add();</code>方法源码</li>
</ul>
<p><img src="/images/image-20220718154323649.png" alt="image-20220718154323649"></p>
<p><img src="/images/image-20220718154432152.png" alt="image-20220718154432152"></p>
 <mark class="hl-label blue">解释</mark> ：

<p>集合中存放的是一个个Node类(结点)。</p>
<p><code>last</code>指的是LinkedList的最后一个Node，所以这里<code>add</code>方法默认是添加元素到末尾。</p>
<p><code>last = newNode</code> 这就保证了传入的元素都会先变成集合的last</p>
<p>如果集合中没有元素，则进入if第一个判断，将<code>first</code>也给原本<code>last</code>元素；</p>
<p>如果集合中原本有元素，那么<code>last</code>指向的Node肯定是集合中最后一个，然后进入if的第二个判断，将原本集合的”last” 也就是<code>l</code>的next指向新传入的newNode(也是现在的<code>last</code>)。</p>
<p>Node类是一个结点，上图中的三个参数分别为<code>prev</code> <code> item</code> <code>next</code>.就是指向前一个Node、内容和指向后一个Node。具体如下图所示</p>
<p><img src="/images/image-20220718154747317.png" alt="image-20220718154747317"></p>
<ul>
<li>LinkedList remove();方法</li>
</ul>
<p><img src="/images/image-20220718172947080.png" alt="image-20220718172947080"></p>
<p><img src="/images/image-20220718173152218.png" alt="image-20220718173152218"></p>
<p><img src="/images/image-20220718224517790.png" alt="image-20220718224517790"></p>
 <mark class="hl-label blue">解释</mark> ：

<p>原理就是将结点的<code>next</code>和 <code>prev</code>改变。上面注释中 help.gc是Java处理机制，会把第一个元素认为是一个垃圾。</p>
<p>也可以删除指定位置的元素，索引也是从0开始，使用了类似对分查找的方法，但是最终还是走的是<code>unlink()</code>方法。</p>
<ul>
<li>遍历方式</li>
</ul>
<p>​	因为LinkedList是实现了List接口的，所以可以使用<code>iterator</code>迭代器，增强for和普通for循环。详见<code>List</code>遍历方式。</p>
<h3 id="List集合选择"><a href="#List集合选择" class="headerlink" title="List集合选择"></a><font color="#5cb85c">List集合选择</font></h3><ul>
<li>ArrayList和LinkedList的比较</li>
</ul>
<p><img src="/images/image-20220814153217844.png" alt="image-20220814153217844"></p>
<p>如何选择ArrayList和LinkedList：</p>
<ol>
<li>如果我们改查的操作多，选择ArrayList</li>
<li>如果我们增删的操作多，选择LinkedList</li>
<li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList</li>
<li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList.</li>
<li>注意插入方式的不同尾插和头插两者效率不同，头插入是LinkedList双向链表快。具体看<a href="https://juejin.cn/post/6844903790156447752?tdsourcetag=s_pctim_aiomsg">https://juejin.cn/post/6844903790156447752?tdsourcetag=s_pctim_aiomsg</a><br><img src="/images/image-20220911232259220.png" alt="image-20220911232259220"></li>
</ol>
<h2 id="Set接口方法"><a href="#Set接口方法" class="headerlink" title="Set接口方法"></a><font color="#6dc1f7">Set接口方法</font></h2><ul>
<li>Set接口基本介绍</li>
</ul>
<ol>
<li>无序（添加和取出的顺序不一致），没有索引</li>
<li>不允许重复元素，所以最多包含一个null</li>
<li>JDK API中set接口的实现类有：</li>
</ol>
<p><img src="/images/image-20220814162725887.png" alt="image-20220814162725887"></p>
<ul>
<li>Set接口的常用方法</li>
</ul>
<p>和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样</p>
<ul>
<li>Set接口的遍历方式</li>
</ul>
<p>同Collection的遍历方式一样，因为Set接口是Collecton接口的子接口。</p>
<ol>
<li>可以使用迭代器</li>
<li>增强for</li>
<li><font color="C02C38">不能使用索引</font>的方式获取</li>
</ol>
<ul>
<li>Set接口的常用方法举例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetMethod_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//以Set 接口的实现子类 HashSet 来讲解Set接口的方法</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;我要买键盘&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;suit80多帅哦&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;我要买键盘&quot;</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;set&quot;</span>+ set);</span><br><span class="line">        <span class="comment">//可以得出结论，添加的顺序和取出的顺序并不一样，但是取出的顺序是一致，就只是和添加的顺序不同，不允许重复的元素</span></span><br><span class="line">        <span class="comment">//可以添加null，只能有一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//方式1：使用迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========迭代器遍历=========&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2：增强for (底层就是迭代器)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========增强for========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传统for循环set接口没有提供get方法，即不能通过索引来获取</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除remove</span></span><br><span class="line">        set.remove(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet全面说明"><a href="#HashSet全面说明" class="headerlink" title="HashSet全面说明"></a><font color="#5cb85c">HashSet全面说明</font></h3><ol>
<li>HashSet实现了Set接口</li>
<li>HashSet实际上是HashMap，看下源码。<br><img src="/images/image-20220814205608084.png" alt="image-20220814205608084"></li>
<li>可以存放null值，但是只能有一个null</li>
<li>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果</li>
<li>不能有重复元素&#x2F;对象，在前面Set接口使用已经讲过。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//HashSet构造器走的是HashMap</span></span><br><span class="line"><span class="comment">//        /**</span></span><br><span class="line"><span class="comment">//         * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">//         * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">//         */</span></span><br><span class="line"><span class="comment">//    public HashSet() &#123;</span></span><br><span class="line"><span class="comment">//            map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">Set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//多态写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">案例01</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet01_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//add()方法后，会返回一个boolean值 添加成功就返回true，否则返回false</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;john&quot;</span>));<span class="comment">//T</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;john&quot;</span>));<span class="comment">//T</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;john&quot;</span>));<span class="comment">//F</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;mary&quot;</span>));<span class="comment">//T</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="string">&quot;mary&quot;</span>));<span class="comment">//F</span></span><br><span class="line">        System.out.println(hashSet.add(<span class="literal">null</span>));<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以通过remove指定删除某个对象</span></span><br><span class="line">        hashSet.remove(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;HashSet&quot;</span> + hashSet);</span><br><span class="line">        hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">// 这个hashSet为空哦</span></span><br><span class="line">        hashSet.add(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Dog_</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Dog_</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">        <span class="comment">//这是两个不同对象，所以两个Dog都是可以的</span></span><br><span class="line">        <span class="comment">//new相当于初始化，一个哦</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//经典面试题目，</span></span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;sb&quot;</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;sb&quot;</span>));<span class="comment">//这里加入不了</span></span><br><span class="line">        <span class="comment">//需要看源码</span></span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog_</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog_</span> <span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog_&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">注意</mark> ：

<p>上述结论涉及到add()方法底层原理，但是抛开问题，new是会新创建一个对象的，对象的概念要理解。</p>
<ul>
<li>HashSet底层机制说明</li>
</ul>
<p>分析HashSet底层是HashMap，HashMap底层是(数组+链表+红黑树)</p>
<p><img src="/images/image-20220814212018115.png" alt="image-20220814212018115"></p>
 <mark class="hl-label blue">模拟链表</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetStructure</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、创建一个数组,数组的类型是Node[]</span></span><br><span class="line">        <span class="comment">//2、有些人，直接把Node[] 数组称为表</span></span><br><span class="line">        Node[] table = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、创建结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;John&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        table[<span class="number">2</span>] = john;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Jack&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        john.next = jack; <span class="comment">//将jack 结点挂载到John后</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">rose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;Rose&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        jack.next = rose; <span class="comment">//将rose结点挂在到jack后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;table&quot;</span> + table);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;<span class="comment">//结点，存储数据，可以指向下一个node，从而形成链表</span></span><br><span class="line">    Object item;  <span class="comment">//存放数据</span></span><br><span class="line">    Node next;    <span class="comment">//指向下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">结果</mark> 

<p><img src="/images/hashmap.png" alt="hashmap"></p>
<h3 id="HashSet扩容机制"><a href="#HashSet扩容机制" class="headerlink" title="HashSet扩容机制"></a><font color="#5cb85c">HashSet扩容机制</font></h3><ul>
<li>分析HashSet的添加元素底层是如何实现(hash()+equals())</li>
</ul>
 <mark class="hl-label blue">结论</mark> ：

<p><img src="/images/image-20220815145848519.png" alt="image-20220815145848519"></p>
<h3 id="HashSet源码解读"><a href="#HashSet源码解读" class="headerlink" title="HashSet源码解读"></a><font color="#5cb85c">HashSet源码解读</font></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;php&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        构造器源码</span></span><br><span class="line"><span class="comment">        * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">        * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public HashSet() &#123;</span></span><br><span class="line"><span class="comment">            map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //执行add方法</span></span><br><span class="line"><span class="comment">        public boolean add(E e) &#123;</span></span><br><span class="line"><span class="comment">        return map.put(e, PRESENT)==null;//private static final Object PRESENT = new Object();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //执行put方法，</span></span><br><span class="line"><span class="comment">        该方法会执行 hash(key) 得到key对应的hash值 是通过return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);是native方法。</span></span><br><span class="line"><span class="comment">        public V put(K key, V value) &#123;//key=&quot;java&quot; value = PRESENT 是静态的、共享的</span></span><br><span class="line"><span class="comment">        return putVal(hash(key), key, value, false, true);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //核心代码 putVal</span></span><br><span class="line"><span class="comment">        final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="comment">                   boolean evict) &#123;</span></span><br><span class="line"><span class="comment">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//定义辅助变量</span></span><br><span class="line"><span class="comment">        //table就是 hashmap的一个数组，类型是Node[],Node数组。</span></span><br><span class="line"><span class="comment">        if ((tab = table) == null || (n = tab.length) == 0)</span></span><br><span class="line"><span class="comment">        //如果当前table是null，或者大小 = 0，就是第一次扩容，到16个空间</span></span><br><span class="line"><span class="comment">            n = (tab = resize()).length;</span></span><br><span class="line"><span class="comment">        //根据key得到hash值，去计算该key应该存放到table表的哪个索引位置</span></span><br><span class="line"><span class="comment">        //并且把这个位置的对象，赋给变量p (索引)</span></span><br><span class="line"><span class="comment">        //再判断这个p是否为null</span></span><br><span class="line"><span class="comment">        //如果p为null,表示还没有存放元素，就创建一个Node(Key= 自己传入的&quot;Java&quot;,value = 内部变量 PRESENT)</span></span><br><span class="line"><span class="comment">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">            tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">        else &#123;</span></span><br><span class="line"><span class="comment">            Node&lt;K,V&gt; e; K k;</span></span><br><span class="line"><span class="comment">            if (p.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                e = p;</span></span><br><span class="line"><span class="comment">            else if (p instanceof TreeNode)</span></span><br><span class="line"><span class="comment">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="comment">            else &#123;</span></span><br><span class="line"><span class="comment">                for (int binCount = 0; ; ++binCount) &#123;</span></span><br><span class="line"><span class="comment">                    if ((e = p.next) == null) &#123;</span></span><br><span class="line"><span class="comment">                        p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span></span><br><span class="line"><span class="comment">                            treeifyBin(tab, hash);</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    if (e.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    p = e;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="comment">                V oldValue = e.value;</span></span><br><span class="line"><span class="comment">                if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="comment">                    e.value = value;</span></span><br><span class="line"><span class="comment">                afterNodeAccess(e);</span></span><br><span class="line"><span class="comment">                return oldValue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ++modCount;</span></span><br><span class="line"><span class="comment">        if (++size &gt; threshold)</span></span><br><span class="line"><span class="comment">            resize();</span></span><br><span class="line"><span class="comment">        afterNodeInsertion(evict);</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">小解析</mark> ：

<p>上面讲了如何将第一个元素添加到HashSet这个集合中去，他本质是Node[]数组的集合，首先如果集合大小为null的话，调用<code>tab = resize()</code>方法，第一次会扩容成16的大小。然后用n记录table的长度，用p记录集合索引位置是否为null，空就可以加入（p的需要一系列算法计算）。</p>
 <mark class="hl-label blue">注意</mark> ：

<p>hash值和hashcode()不一样。需要<code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code>右移16位得到hash值。右移防止哈希冲突。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a><font color="#6dc1f7">线程</font></h2><h3 id="线程相关概念"><a href="#线程相关概念" class="headerlink" title="线程相关概念"></a><font color="#5cb85c">线程相关概念</font></h3><ul>
<li><p><font color="12AA8C">程序(program)</font></p>
<p>是为完成特定任务、用某种语言编写的一组指令的集合。简单的说：就是我们写的代码。</p>
</li>
<li><p><font color="12AA8C">进程</font></p>
<ol>
<li>进程是指运行中的程序，比如我们使用QQ，启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间。</li>
<li>进程是程序的一次执行过程，或是正在运行的一个程序，是动态过程：有它自身的产生、存在和消亡的过程。</li>
</ol>
</li>
<li><p><font color="12AA8C">线程</font></p>
<ol>
<li><p>线程由进程创建的，是进程的一个实体。</p>
</li>
<li><p>一个进程可以拥有多个线程，如下图。</p>
<p><img src="/images/image-20220701121223052.png" alt="image-20220701121223052"></p>
<p>有多个同时下载内容。坦克大战[后面会把多线程加入到坦克大战中，学以致用]</p>
</li>
</ol>
</li>
<li><p><font color="12AA8C">其他相关概念</font></p>
<ol>
<li>单线程：同一个时刻，只允许执行一个线程。</li>
<li>多线程：同一个时刻，可以执行多个线程，比如：一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件。</li>
<li>并发：同一个时刻，多个任务交替执行，造成一种”貌似同时“的错觉，简单的说，单核cpu实现的多任务就是并发。</li>
<li>并行：同一个时刻，多个任务同时执行，多核cpu可以实现并行。</li>
</ol>
</li>
</ul>
<mark class="hl-label purple">案例</mark> ：

<p>Java查看计算机有一个CPU(核)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="comment">//可用处理器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">CPUNums</span> <span class="operator">=</span> runtime.availableProcessors();</span><br><span class="line">        System.out.println(CPUNums);<span class="comment">//16</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a><font color="#5cb85c">线程的基本使用</font></h3><p>在Java中线程来使用有两种方法：</p>
<ol>
<li>继承Thread类，重写run方法。</li>
<li>实现Runnable接口，重写run方法。</li>
</ol>
<p><img src="/images/image-20220701170613035.png" alt="image-20220701170613035"></p>
<mark class="hl-label purple">案例1</mark> : <font color="D2568C">继承Thread类。</font>

<ol>
<li>该线程每隔一秒钟，在控制台输出”喵喵，我是小猫咪”</li>
<li>并在输出80次后，结束该线程。</li>
<li>增加main线程内容。</li>
<li>用jconsole监控线程执行情况注意：需用管理员身份打开idea。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threaduse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建Cat对象，可以当作线程使用</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        cat.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());<span class="comment">//主线程名字为main。</span></span><br><span class="line">        <span class="comment">//说明，当main线程启动一个子线程 Thread-0，主线程main不会阻塞，会继续执行。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">60</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程输出&quot;</span>+i);</span><br><span class="line">            <span class="comment">//主线程休眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//单位ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//重写run()方法，实现自己的业务逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//输出&quot;喵喵&quot; 和当前线程名字(currentThread)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;喵喵,我是小猫咪&quot;</span>+ (++times)+ Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//休眠1秒种。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">//单位ms</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">80</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//当8次退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="D2568C">线程示意图：</font></p>
<p><img src="/images/image-20220702132905125.png" alt="image-20220702132905125"></p>
<mark class="hl-label red">小结</mark> ：

<p>主线程结束，进程不一定结束，如有其他子线程在执行。</p>
<ol>
<li>当一个类继承Thread类，就可以当作线程使用</li>
<li>我们会重写run方法，写上自己的业务代码</li>
<li>run Thread 类，实现了Runnable 接口的run方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Thread里面的run();</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么是Start"><a href="#为什么是Start" class="headerlink" title="为什么是Start();"></a><font color="#5cb85c">为什么是Start();</font></h3><p>如上所示，如果调用<code>run();</code>方法，会和普通方法调用一样。不会开额外的线程，会等他执行完也就是阻塞。而<code>start();</code>方法是调用底层native方法<code>start0();</code>。start0()是本地方法，是JVM调用，底层是c&#x2F;c++实现。真正实现多线程的效果，是start0(),而不是run。<code>private native void start0();</code></p>
<p><img src="/images/image-20220702154036038.png" alt="image-20220702154036038"></p>
<mark class="hl-label purple">案例2</mark> : <font color="D2568C">实现Runnable接口</font>

<p>说明：</p>
<ol>
<li>Java是单继承的，在某个情况下一个类可能已经继承了某个父类，这时在用继承Thread类方法来创建线程显然不可能了。</li>
<li>Java设计者们提供了另外一个方式创建线程，就是通过实现Runnable接口来创建线程。</li>
</ol>
<p>该案例可以每个一秒钟，在控制台输出”hi！”，当输出10次后，自动退出。请使用实现Runnable接口的方式实现。这里是<font color="FF9900">静态代理。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    继承Runnable接口实现多线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threaduse2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dog);<span class="comment">//Thread提供的构造器</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadProxy</span> <span class="variable">threadProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadProxy</span>(dog);</span><br><span class="line">        threadProxy.start();<span class="comment">//本质调用Runnable类重写过后的run方法,并没有启用多线程start0();</span></span><br><span class="line">        <span class="comment">//其实不用代理也一样的,ThreadProxy 就是将thread类源码极简的模拟了一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi&quot;</span>+(++times)+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">//单位ms.</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程代理,模拟了极简的线程代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadProxy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//ThreadProxy可以当作Thread类的代理(都是继承Runnable)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//属性, 类型是Runnable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();  <span class="comment">//Runnable里面的run();方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadProxy</span> <span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ThreadProxy继承了Runnable,可以当作类似的Thread的代理.这里模拟最简的Thread.</span></span><br><span class="line">    <span class="comment">//下面这些,可以说是为了同继承Thread接口启用多线程方法相同,所做出的举动</span></span><br><span class="line">    <span class="comment">//如Dog dog = new dog(); dog.start;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        start0(); <span class="comment">//这个方法是真正实现多线程的(模拟)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span> &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> :

<p>静态代理只是用自己写的一个类模拟Thread类，上面展示的是极简的。并没有真正调用<font color="EEA2A4">native 方法 </font><code>start0();</code> 。所以还是<font color="EEA2A4">main线程</font>。代理：最后结果还是自己做。第一个没有用代理，直接用Thread的会<font color="EEA2A4">新开一个线程</font>。</p>
<mark class="hl-label purple">案例3</mark> :<font color="D2568C">多线程执行</font>

<p>创建两个线程，一个线程每隔一秒输出”hello,world”,输出10次后，退出，一个线程每个一秒输出”hi”，输出5次后退出。</p>
<mark class="hl-label red">注意</mark> : 都是通过<font color="C06F98">实现Runnable接口。</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多线程执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threaduse3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>();</span><br><span class="line">        <span class="type">teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">teacher</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(student);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(teacher);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">extends</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>+(++times)+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span> <span class="keyword">extends</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi&quot;</span> + (++times)+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">小结</mark> :

<p>实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	共享资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">T3</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T3</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t3);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t3);</span><br></pre></td></tr></table></figure>

<p>如采用继承方式，则需要new两个对象，资源浪费。</p>
<h3 id="多线程售票系统"><a href="#多线程售票系统" class="headerlink" title="多线程售票系统"></a><font color="#5cb85c">多线程售票系统</font></h3><p>模拟三个售票窗口，分别使用继承Thread和实现Runnable方式。</p>
<mark class="hl-label orange">方式1</mark> : <font color="C06F98">继承Thread。</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 售票系统 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//继承Thread方法</span></span><br><span class="line">        <span class="type">windows1</span> <span class="variable">windows1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows1</span>();</span><br><span class="line">        <span class="type">windows1</span> <span class="variable">windows11</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows1</span>();</span><br><span class="line">        <span class="type">windows1</span> <span class="variable">windows12</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows1</span>();</span><br><span class="line">        windows1.start();</span><br><span class="line">        windows11.start();</span><br><span class="line">        windows12.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">windows1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;窗口1已售完&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;卖出一张票&quot;</span>+<span class="string">&quot;剩余&quot;</span>+(--tickets)+Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能会出现超卖现象，因为三个线程同时工作，如果最后只剩两张票的时候，第一个线程判断符合<font color="C06F98">不小于0</font>的条件，但是期间存在休眠。当还未减去票数的时候，另外两个线程会把表数当作2处理。那么就会出现多卖的情况。</p>
<mark class="hl-label orange">方式2</mark> : <font color="C06F98">实现Runnable接口。</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 售票系统 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实现Runnable接口</span></span><br><span class="line">		<span class="type">windows2</span> <span class="variable">windows2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows2</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows2);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">windows2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;窗口2已售完&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;卖出一张票&quot;</span>+<span class="string">&quot;剩余&quot;</span>+(--tickets)+Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是实现Runnable接口的方法，本质上和继承Thread类一样，所以也可能会出现多卖的情况。和<code>sleep</code>时长有关。</p>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a><font color="#5cb85c">线程终止</font></h3><mark class="hl-label orange">基本说明</mark> : 

<ol>
<li>当线程完成任务后，会自动退出。</li>
<li>还可以通过使用变量<font color="EE4866">控制run方法</font>退出的方法停止线程，即通知方法。</li>
</ol>
<mark class="hl-label red">案例</mark> : 启动一个线程t,要求在main线程中去停止线程t。<font color="EE4866">通知方法</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 线程终止 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">t</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">t</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        t.setLoop(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">t</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//设置一个控制变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;你妈隔壁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//想当于main程序控制线程的一个接口.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a><font color="#5cb85c">线程中断</font></h3><ul>
<li>常用方法第一组</li>
</ul>
<ol>
<li>setName : 设置线程名称，使之与参数name相同。</li>
<li>getName：返回该线程的名称。</li>
<li>start ：使该线程开始执行；Java虚拟机底层调用该线程的start0方法。</li>
<li>run : 调用该线程对象run方法。</li>
<li>setPriority : 更改线程的优先级。</li>
<li>getPriority：获取线程的优先级。</li>
<li>sleep：在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)。</li>
<li>interrupt：中断线程。</li>
</ol>
<mark class="hl-label red">注意</mark> :

<ol>
<li>start底层会创建新的线程，调用run，run就是一个简单的方法调用，不会启动新的线程</li>
<li>线程优先级的范围。</li>
<li>interrupt，中断线程，但并没有真正的结束线程。所以一般用于中断正在休眠线程</li>
<li>sleep：线程的<font color="EC8AA4">静态方法</font>，是当前线程休眠。</li>
</ol>
<mark class="hl-label red">方法案例</mark> : 各种ThreadMethod的使用方法

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">T1</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>();</span><br><span class="line">    t.start();</span><br><span class="line">    t.setName(<span class="string">&quot;李文涛&quot;</span>);</span><br><span class="line">    t.setPriority(Thread.MIN_PRIORITY); <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="comment">//主线程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;吊毛&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;你在干什么&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;休眠中&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//当该线程执行到一个interrupt方法时，就会catch一个异常，可以加入自己的业务代码</span></span><br><span class="line">                <span class="comment">//interruptedException 是捕获到一个中断异常。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;休眠被打断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常用方法第二组</li>
</ul>
<ol>
<li><font color="C45A65">yield(静态方法)</font>：线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也<font color="C45A65">不一定礼让成功</font>。</li>
<li>join: 线程的插队。插队的线程一旦成功，则肯定先执行完插入的线程<font color="C45A65">所有的任务</font>。</li>
</ol>
<p><img src="/images/image-20220706123621448.png" alt="image-20220706123621448"></p>
<mark class="hl-label orange">案例</mark> :

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethod02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T4</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T4</span>();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;吃&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                t4.join(); <span class="comment">//让t4的线程先执行完，后继续执行main线程</span></span><br><span class="line">                Thread.yield(); <span class="comment">//静态方法使用类名.方法调用。这个方法礼让不一定成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T4</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;吃包子&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//1秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>对象.join();</code>方法的时候。对象是’’大哥’’。会先执行完，这个对象的线程内容后，继续执行本线程的内容。</p>
<mark class="hl-label purple">练习</mark> :

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    线程方法的练习</span></span><br><span class="line"><span class="comment">    主线程每隔一秒钟，输出hi，共10次</span></span><br><span class="line"><span class="comment">    当主线程执行到第五次的时候，启功子线程（要求是实现接口Runnable的），每个一秒钟输出hello共10次</span></span><br><span class="line"><span class="comment">    然后继续执行主线程。完成后退出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethodExercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        T5 t5 = new T5();</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(t5);</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">T5</span>());  <span class="comment">//Thread 构造器传入Runnable对象</span></span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;hi&quot;</span>+ i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">                t5.start(); <span class="comment">//启动子线程</span></span><br><span class="line">                t5.join();  <span class="comment">//子线程“插队”</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T5</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;hello&quot;</span>+ i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> : 

<p>实现Runnable接口时候，多线程启动的原理。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a><font color="#5cb85c">守护线程</font></h3><ul>
<li>用户线程和守护线程</li>
</ul>
<ol>
<li>用户线程：也叫工作线程，当线程的任务执行完或通知方式结束。</li>
<li>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束</li>
<li>常见的守护线程：垃圾回收机制。</li>
</ol>
<mark class="hl-label red">应用案例</mark> : 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethod03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">MyDaemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyDaemonThread</span>());</span><br><span class="line">        MyDaemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        MyDaemonThread.start();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;wuhu&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDaemonThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你麻痹&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;whu&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>守护线程： 理解为他是守护别的线程的，当别的线程全部结束后，也就不需要它的守护了，他也就自动结束了。可以用于监控其他线程，获取其他线程的信息。</p>
<h3 id="线程七大状态"><a href="#线程七大状态" class="headerlink" title="线程七大状态"></a><font color="#5cb85c">线程七大状态</font></h3><p><img src="/images/image-20220706170124615.png" alt="image-20220706170124615"></p>
<p><img src="/images/image-20220706170054622.png" alt="image-20220706170054622"></p>
<mark class="hl-label red">注意</mark> : 

<p>官方文档是6个状态，Runnable可以细分为两个状态，都是内核控制，图中yeild方法虽然将它从Runnable状态变成Ready状态，但是线程调度还是由内核控制，所以礼让不一定成功。图上有个单词打错了，Teminated，应该是Terminated。 </p>
<mark class="hl-label red">案例</mark> : 

<p>获取线程状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">T</span>());</span><br><span class="line">        System.out.println(t.getName()+<span class="string">&quot;状态&quot;</span>+t.getState()); <span class="comment">//获取线程当前的状态</span></span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(t.getName()+<span class="string">&quot;状态&quot;</span>+t.getState());</span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.State.TERMINATED != t.getState()) &#123; <span class="comment">//意思是当前线程状态不是等于终止(TERMINATED)状态</span></span><br><span class="line">            System.out.println(t.getName()+ <span class="string">&quot;状态&quot;</span>+ t.getState());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.getName()+<span class="string">&quot;状态&quot;</span>+t.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;wuhu&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">部分结果</mark> : 

<p><img src="/images/image-20220706174300267.png" alt="image-20220706174300267"></p>
<p>只能获取部分状态，有些是底层内核的，不易获取。</p>
<h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a><font color="#5cb85c">线程同步机制</font></h3><ol>
<li>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。</li>
<li>也可以这里理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该地址内存进行操作。</li>
</ol>
<ul>
<li>同步具体方法</li>
</ul>
<ol>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123; <span class="comment">//得到对象的锁，才能操作同步代码</span></span><br><span class="line">    <span class="comment">//需要被同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>synchronized还可以放在方法声明中，表示整个方法-为同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span> <span class="params">(String name)</span>&#123;  <span class="comment">//此时m方法已经是同步方法</span></span><br><span class="line">	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如何理解<br>就好像某个小伙伴上厕所前先把门关上(上锁)，完事后再出来(解锁)，那么其他小伙伴就可在使用厕所了。</p>
</li>
<li><p>使用synchronized 解决前面售票问题。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现接口方法，使用synchronized实现线程同步</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">windows3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已售完&quot;</span>);</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;卖出一张票&quot;</span>+<span class="string">&quot;剩余&quot;</span>+(--tickets)+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//同步方法，在同一个时刻只能有一个线程来执行run方法。</span></span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            sell();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">小结</mark> : 这是使用在方法声明中加入synchronized。

<blockquote>
<ol>
<li>public synchronized void sell() {} 就是一个同步方法</li>
<li>这时锁在this对象</li>
<li>也可以在代码块上写synchronize， 同步代码块，互斥锁还是在this对象</li>
</ol>
</blockquote>
<ul>
<li>同步原理分析。</li>
</ul>
<p><img src="/images/image-20220707213146945.png" alt="image-20220707213146945"></p>
<p>锁是在<font color="EEA2A4">对象</font>上的，然后t1，t2，t3三个线程去抢夺这个锁。然后完成相应方法。再将锁还回去，下次抢的时候还是三个人一起抢，不是<font color="EEA2A4">公平锁</font>。这个锁可以配合前面<font color="#5cb85c">线程七大状态</font>图理解，就是<font color="C02C38">Blocked状态</font>，翻译过来就是<font color="EEA2A4">锁</font>。</p>
<p><img src="/images/image-20220709205225117.png" alt="image-20220709205225117"></p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><font color="#5cb85c">互斥锁</font></h3><ol>
<li>在Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。</li>
<li>每个对象都对应于一个可称为”互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</li>
<li>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问</li>
<li>同步的局限性：导致程序的执行效率要降低</li>
<li>同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象) （加在当前对象）</li>
<li>同步方法(静态的)的锁为当前类本身。(加在当前类)</li>
</ol>
<mark class="hl-label blue">代码块形式</mark> : 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">windows4</span> <span class="variable">windows4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">windows4</span>();</span><br><span class="line"><span class="comment">//        windows4 windows41 = new windows4();</span></span><br><span class="line"><span class="comment">//       windows4 windows42 = new windows4();</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows4);</span><br><span class="line">    	<span class="type">Thread</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows4);</span><br><span class="line">   	    <span class="type">Thread</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(windows4);</span><br><span class="line"><span class="comment">//        Thread s2 = new Thread(windows42);</span></span><br><span class="line"><span class="comment">//        Thread s3 = new Thread(windows41);</span></span><br><span class="line">        s1.start();</span><br><span class="line">        s2.start();</span><br><span class="line">        s3.start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="comment">/*this*/</span>object) &#123;  <span class="comment">//代码块形式</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票已售完&quot;</span>);</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;卖出一张票&quot;</span> + <span class="string">&quot;剩余&quot;</span> + (--tickets) + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">小结</mark> : 

<p>synchronized(对象)。这里object 和this作用一样，都是锁当前对象。在main测试中(看上文)，共用一个对象<code>windows4 windows4 = new windows4();</code>,如果用多个对象<code>windows4 windows41 = new windows4();</code>锁就会失效。将<code>synchronized(对象)</code>里面对象换用<code>windows4.class</code>对这个类进行锁。</p>
<mark class="hl-label red">注意</mark> : 

<blockquote>
<p><code>sleep();</code>最好放在<font color="C02C38">锁外面</font>，这样可以给别的线程机会。不然可能由于底层CPU调度导致只有一个线程运行。也符合逻辑，休眠的时候不应该占用锁。</p>
<p>同步代码块中不能有死循环，会导致一个线程进去后就一直运作，占用锁。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (money &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                money -= <span class="number">1000</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;剩余&quot;</span> + money);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">静态方法</mark> : 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步方法为静态的时候 锁为当前本身类。</span></span><br><span class="line"><span class="comment">//public synchronized static void m1() &#123;&#125; 锁是加在windows4.class</span></span><br><span class="line"><span class="comment">//如果静态方法中，实现一个代码块，需用windows.class 获取类，在加类上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//静态方法上加锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (windows4.class) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">小结</mark> : 

<p>如果使用代码块形式，<code>synchronized(对象)</code>里面的对象，相当于它的作用范围。加在方法前面的声明则要求较少。</p>
<mark class="hl-label red">注意事项</mark> : 

<blockquote>
<ol>
<li><p>同步方法如果没有使用static修饰：默认锁对象为this</p>
</li>
<li><p>如果方法使用static修饰，默认锁对象：当前类.class，static肯定要被多次调用，用类.class可以锁多个对象。</p>
</li>
<li><p>实现的落地步骤：</p>
<p>需要先分析上锁的代码</p>
<p>选择同步代码块或同步方法</p>
<p>要求多个线程的锁对象为同一个即可!</p>
</li>
</ol>
<p>	</p>
</blockquote>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a><font color="#5cb85c">线程死锁</font></h3><ul>
<li>基本介绍</li>
</ul>
<p>​	多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生。</p>
<mark class="hl-label blue">案例</mark> : 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 死锁 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">sisuo</span>(<span class="literal">true</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">sisuo</span>(<span class="literal">false</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sisuo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">//保证多线程，共享一个对象，这里使用static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> loop;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">sisuo</span> <span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (loop) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入1&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入3&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;进入4&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">存疑</mark> :

<p><code>Object object = new Object();</code>的原理。</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a><font color="#5cb85c">释放锁</font></h3><ul>
<li>下面操作会释放锁。</li>
</ul>
<ol>
<li>当前线程的同步方法、同步代码执行结束<br>案例：上厕所、完事出来</li>
<li>当前线程在同步代码块、同步方法中遇到break、return<br>案例：没有正常的完事，经理叫他修改bug，不得已出来</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束<br>案例：没有正常完成的完事，发现忘带纸，不得已出来</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁<br>案例：没有正常完事，觉得需要酝酿下，所以出来等会再进去。</li>
</ol>
<ul>
<li>下面操作不会释放锁</li>
</ul>
<ol>
<li>线程执行同步代码块或同步方法时，程序调用<code>Thread.sleep()</code>、<code>Thread.yield()</code>方法暂停当前线程的执行，不会释放锁<br>案例：上厕所，太困了，在坑位上眯了一会。</li>
<li>线程执行同步代码块时，其他线程调用了该线程的<code>suspend()</code>方法将该线程挂起，该线程不会释放锁。<br>提示：应尽量避免使用<code>suspend()</code>和<code>resume()</code>来控制线程，方法不再推荐使用</li>
</ol>
<h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a><font color="#6dc1f7">I&#x2F;O流</font></h2><p><img src="/images/image-20220722115624344.png" alt="image-20220722115624344"></p>
<h3 id="文件基础知识"><a href="#文件基础知识" class="headerlink" title="文件基础知识"></a><font color="#5cb85c">文件基础知识</font></h3><ul>
<li>什么是文件</li>
</ul>
<p>​		文件，是<font color="#0F59A4">保存数据的地方</font>，比如word文档，txt文件·····</p>
<ul>
<li>文件流</li>
</ul>
<p>​		文件在程序中是以流的形式来操作的</p>
<p>​		流：数组在数据源(文件)和程序(内存)之间经历的路径</p>
<p>​		输入流：数据从数据源(文件)到程序(内存)的路径</p>
<p>​		输入流：数据从程序(内存)到数据源(文件)的路径</p>
<p><img src="/images/image-20220722120916773.png" alt="image-20220722120916773"></p>
<h3 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a><font color="#5cb85c">常用的文件操作</font></h3><ul>
<li>创建文件对象相关构造器和方法</li>
</ul>
<p>​	new File(String pathname) &#x2F;&#x2F;根据路径构建一个File对象</p>
<p>​	new File(File parent , String child) &#x2F;&#x2F;根据父目录文件 + 子路径构建</p>
<p>​	new File(String parent, String child) &#x2F;&#x2F;根据父目录+子路径构建 </p>
<p>​	createNewFile 创建新文件</p>
<mark class="hl-label red">类图</mark> :

<p><img src="/images/image-20220722123911907.png" alt="image-20220722123911907"></p>
<mark class="hl-label purple">代码</mark> :

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jth.javaee.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示文件创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCreate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Create1();</span><br><span class="line">        Create2();</span><br><span class="line">        create3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一：new File(String pathname) //根据路径构建一个File对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Create1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/text01.txt&quot;</span>; <span class="comment">//文件路径  /也可以用两个\\转义</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile(); <span class="comment">//调用方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二 ：new File(File parent , String child) //根据父目录文件 + 子路径构建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Create2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//parent</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentfile, <span class="string">&quot;text02.txt&quot;</span>);<span class="comment">//在jvm内存里面有对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile(); <span class="comment">//这个才是实现文件创建的方法/步骤 //在磁盘里面执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式三： new File(String parent, String child) //根据父目录+子路径构建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>, <span class="string">&quot;text03.txt&quot;</span>).createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取文件相关信息</li>
</ul>
<p>​	一些常用方法：</p>
<p>​	getName 获取文件名</p>
<p>​    getAbsolutePath 获取绝对路径</p>
<p>​	getParent  获取文件父目录</p>
<p>​	length 获取文件大小(字节计算)</p>
<p>​	exists 判断是否存在</p>
<p>​	isFile 判断是否是一个文件</p>
<p>​	isDirectory 判断是否是一个目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fileinformation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        getinformation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getinformation</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/text03.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="comment">//file.createNewFile();</span></span><br><span class="line">        System.out.println(file.getName());<span class="comment">//获取文件名</span></span><br><span class="line">        System.out.println(file.getAbsolutePath());<span class="comment">//绝对路径</span></span><br><span class="line">        System.out.println(file.canRead());<span class="comment">//true</span></span><br><span class="line">        System.out.println(file.exists());<span class="comment">//true</span></span><br><span class="line">        System.out.println(file.isFile());<span class="comment">//true</span></span><br><span class="line">        System.out.println(file.getParent());<span class="comment">//D:\</span></span><br><span class="line">        System.out.println(file.length());<span class="comment">//35 编码不同，字节长度不同，这个长度是计算字节长度</span></span><br><span class="line">        System.out.println(file.isDirectory());<span class="comment">//是否是目录 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> :

<p>这里不用没有创建文件<code>createFile</code>就可以调用下面方法，进一步说明，产生文件是由file的createFile方法实现，这里没有创建是以前创建好了，就是上次创建的text03.txt如果这个路径中没有这个文件，那么就有<code>exists()</code>这个方法存在的意义了，返回false。比如将路径改成<code>D:/text04.txt</code>。</p>
<p>还需注意的是编码方式不同，<code>length</code>返回的长度也不同，这里txt文件使用的UTF-8。一个英文字母、数字或英文标点一个字节，一个汉字或汉字标点占三个字节。</p>
<ul>
<li>目录操作</li>
</ul>
<p>​	mkdir创建一级目录，mkdirs创建多级目录、delete删除空目录或文件。</p>
<mark class="hl-label blue">代码</mark> :

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示目录创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MakeDirectory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        m1();</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/text01.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.delete()) &#123;<span class="comment">//delete方法删除 ，并且会返回一个boolean值</span></span><br><span class="line">                System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建目录，目录其实就是相当于文件夹多个嵌套</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">directorypath</span> <span class="operator">=</span> <span class="string">&quot;D:/directory&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(directorypath);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目录存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.mkdirs()) &#123;<span class="comment">//这个是创建多级目录的方法不能使用mkdir()方法创建多级目录</span></span><br><span class="line">                System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO流原理和分类"><a href="#IO流原理和分类" class="headerlink" title="IO流原理和分类"></a><font color="#5cb85c">IO流原理和分类</font></h3><ul>
<li>Java IO流原理</li>
</ul>
<ol>
<li>I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术是非常实用的技术，用于处理数据传输。<br>如读&#x2F;写文件，网络通讯等。</li>
<li>Java程序中，对于数据的输入&#x2F;输出操作以”流(stream)”的方式进行。</li>
<li>Java.io包下提供了各种”流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据。</li>
<li>输入input：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中。</li>
<li>输出output：将程序(内存)数据输出到磁盘、光盘等存储设备中。</li>
</ol>
<p><img src="/images/image-20220726144159722.png" alt="image-20220726144159722"></p>
<ul>
<li>流的分类</li>
</ul>
<p>​		按操作数据单位不同分为：字节流(8 bit) 二进制文件，字符流(按字符，编码不同大小不同)文本文件</p>
<p>​		按数据流的流向不同分为：输入流，输出流</p>
<p>​		按流的角色的不同分为：节点流，处理流&#x2F;包装流</p>
<p><img src="/images/image-20220726144544013.png" alt="image-20220726144544013"></p>
<ol>
<li>Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的。</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</li>
</ol>
<p><img src="/images/image-20220726145227421.png" alt="image-20220726145227421"></p>
<p><img src="/images/image-20220726145649356.png" alt="image-20220726145649356"></p>
<h3 id="IO流体系图-常用的类"><a href="#IO流体系图-常用的类" class="headerlink" title="IO流体系图-常用的类"></a><font color="#5cb85c">IO流体系图-常用的类</font></h3><ul>
<li>InputStream:字节输入流</li>
</ul>
<p>​		InputStream抽象类是所有类字节输入流的超类</p>
<p>​		InputStream常用的子类</p>
<ol>
<li>FileInputStream: 文件输入流</li>
<li>BufferedInputStream: 缓冲字节输入流</li>
<li>ObjectInputStream: 对象字节输入流</li>
</ol>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a><font color="#ffd253">FileInputStream</font></h4><p><img src="/images/image-20220726153210658.png" alt="image-20220726153210658"></p>
<p><img src="/images/image-20220726153119741.png" alt="image-20220726153119741"></p>
<mark class="hl-label blue">应用案例</mark> :

<p>要求：请使用FileInputStream 读取 hello.txt 文件，并将文件内容显示到控制台。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    要求：请使用FileInputStream 读取 hello.txt 文件，并将文件内容显示到控制台。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        readFile01();</span><br><span class="line">        readFile02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用read();</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:/hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//扩大作用域</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建FileInputStream对象，用于读取文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="comment">//从该输入流读取一个字节的数据，如果没有输入可用，此方法将阻止</span></span><br><span class="line">            <span class="comment">//如果返回-1，表示读取完毕</span></span><br><span class="line">            <span class="keyword">while</span> ((readData = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)readData);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;打开成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭文件流，释放资源</span></span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用read(byte[] b)方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile02</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:/hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];<span class="comment">//一次可以一次读取8个字节</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//扩大作用域</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建FileInputStream对象，用于读取文件</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="comment">//将字符读入数组。此方法将阻塞，直到某些输入可用、发生 I/O 错误或到达流的末尾。</span></span><br><span class="line">            <span class="comment">//如果返回-1，表示读取完毕</span></span><br><span class="line">            <span class="comment">//如果读取正常，返回实际读取的字节数</span></span><br><span class="line">            <span class="keyword">while</span> ((readlen = fileInputStream.read(buf))!= -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span> , readlen));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;打开成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭文件流，释放资源</span></span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> :

<p>方式一：<code>read()</code>方法返回读取到的字节值。</p>
<p>方式二：<code>read(byte[] b)</code>方法返回读取到的char数组长度</p>
<p>文件<code>read</code>完后需要<code>close</code>释放资源。</p>
<mark class="hl-label blue">Debug</mark> :

<p>hello.txt文件只有hello内容。所以第一次readlen长度为5。</p>
<p><img src="/images/image-20220726190829285.png" alt="image-20220726190829285"></p>
<p><img src="/images/image-20220726191142742.png" alt="image-20220726191142742"></p>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a><font color="#ffd253">FileOutputStream</font></h4><p><img src="/images/image-20220726192511879.png" alt="image-20220726192511879"></p>
<p><img src="/images/image-20220726192547131.png" alt="image-20220726192547131"></p>
<mark class="hl-label blue">应用实例</mark> :

<p>要求：请使用FileOutputStream 在 a.txt文件中写入 “hello,world”如果不存在则它自己会创建文件。(注意：前提是目录必须正确)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileWrite01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">FileWrite01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/a.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到fileOutputStream对象</span></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filepath);</span><br><span class="line">            fileOutputStream.write(<span class="string">&#x27;H&#x27;</span>);<span class="comment">//写入单个字节</span></span><br><span class="line">            fileOutputStream.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;);<span class="comment">//写入多个字符</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">            fileOutputStream.write(b.getBytes(StandardCharsets.UTF_8));<span class="comment">//可以把字符串 -&gt; 字节数组</span></span><br><span class="line">            fileOutputStream.write(b.getBytes(StandardCharsets.UTF_8), <span class="number">0</span>, b.length());<span class="comment">//write(byte[] b, int off, int len) 将len字节从位于偏移量 off的指定字节数组写入此文件输出流</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">解释</mark> :

<p>上面展示了三种方法，其中<code>b.getBytes()</code>是String中的一种方法，括号中可以填写编码方法。上面使用UTF-8.</p>
<p>上面这种创建方式，多次运行是覆盖方式，当写入内容时，会覆盖原来的内容。</p>
<p>当构造器<code>FileOutputStream()</code>添加一个参数<code>append</code>为true，则写入内容为追加方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filepath, <span class="literal">true</span>);<span class="comment">//写入为追加方式</span></span><br></pre></td></tr></table></figure>

<h3 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a><font color="#5cb85c">文件的拷贝</font></h3><mark class="hl-label blue">案例</mark> :

<p>要求:编程完成图片&#x2F;音乐的拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fuzi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//图片地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/java图片/Colleciton.png&quot;</span>;</span><br><span class="line">    <span class="comment">//要复制到的地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">goalpath</span> <span class="operator">=</span> <span class="string">&quot;D:/Collection.png&quot;</span>; <span class="comment">//这里是目标路径，文件名可以改，write动作只需路径目录，没有文件它自己可以创建也符合复制的操作</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span> []b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filepath);</span><br><span class="line">        outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(goalpath);</span><br><span class="line">        <span class="keyword">while</span> ((readlen = inputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            outputStream.write(b, <span class="number">0</span>, readlen);  <span class="comment">//一定要用这个方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> :

<p><code>write</code>方法一定要用<code>b,0,readlen</code>因为如果文件大小不是数组大小的倍速，由于原理是不会清空数组再装填，所有会有一些数据重复。所以使用这个方法就能避免重复。</p>
<h3 id="文件字符流说明"><a href="#文件字符流说明" class="headerlink" title="文件字符流说明"></a><font color="#5cb85c">文件字符流说明</font></h3><ul>
<li>FileReader和FileWriter介绍</li>
</ul>
<p>​	FileReader和FileWriter是字符流，即按照字符来操作io</p>
<p><img src="/images/image-20220727153219146.png" alt="image-20220727153219146"></p>
<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a><font color="#ffd253">FileReader</font></h4><ul>
<li>FileReader相关方法：</li>
</ul>
<ol>
<li>new FileReader(File&#x2F;String)</li>
<li>read:每次读取单个字符，返回该字符，如果到文件末尾返回-1；</li>
<li>read(char[]): 批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</li>
</ol>
<p>​	相关API：</p>
<ol>
<li>new String(char[]):将char[]转换成String；</li>
<li>new String(char[], off, len):将char[]的指定部分转换成String。</li>
</ol>
<p><img src="/images/image-20220727154800323.png" alt="image-20220727154800323"></p>
<mark class="hl-label blue">案例</mark> :

<p>使用FileReader从story.txt读取内容，并显示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filereader_1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">txtpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/story.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(txtpath);</span><br><span class="line">        <span class="comment">//读取单个字节</span></span><br><span class="line">        <span class="keyword">while</span> ((readData = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)readData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照单个字符</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(fileReader.read(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(fileReader.read(buf, 0, buf.length));</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filereader_2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">txtpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/story.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(txtpath);</span><br><span class="line">        <span class="comment">//按照单个字符</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filereader_3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">txtpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/story.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(txtpath);</span><br><span class="line">        <span class="comment">//按照单个字符</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileReader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">小结</mark> :

<p>总体用法和以前的<code>FileinputStream</code>差不多，一个是字节输入，这个是字符输入。</p>
<p>注意一下String相关API的调用。</p>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a><font color="#ffd253">FileWriter</font></h4><ul>
<li>FileWriter常用方法</li>
</ul>
<p><img src="/images/image-20220727153917844.png" alt="image-20220727153917844"></p>
<ol>
<li>new FileWriter(File&#x2F;String): 覆盖模式。相当于流的指针在首端</li>
<li>new FileWriter(File&#x2F;String,true): 追加模式，相当于流的指针在末端</li>
<li>write(int):写入单个字符</li>
<li>write(char[]):写入指定数组</li>
<li>write(char[], off,len): 写入指定数组的指定部分</li>
<li>write(string): 写入整个字符串</li>
<li>write(string , off ,len )写入字符串的指定部分</li>
</ol>
<p>相关API：String类： toCharArray:将String转换成char[]</p>
<mark class="hl-label red">注意</mark> :

<p>FileWriter使用后，必须使用关闭close或者刷新flush，否则文件无法写入</p>
<p><img src="/images/image-20220727154524642.png" alt="image-20220727154524642"></p>
<mark class="hl-label blue">案例</mark> :

<p>使用FileWriter将”风雨之后，定见彩虹”，写入到note.txt文件中，注意细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">FileWriter_1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">txtpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/note.txt&quot;</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;在&#x27;</span>,<span class="string">&#x27;干&#x27;</span>,<span class="string">&#x27;什&#x27;</span>,<span class="string">&#x27;么&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">buf1</span> <span class="operator">=</span> <span class="string">&quot;吊毛&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(txtpath); <span class="comment">//默认是覆盖模式</span></span><br><span class="line">        <span class="comment">//fileWriter = new FileWriter(txtpath, true) true参数表示的是追加模式</span></span><br><span class="line">        <span class="comment">//使用单字符写</span></span><br><span class="line">        fileWriter.write(<span class="string">&#x27;你&#x27;</span>);</span><br><span class="line">        fileWriter.write(buf);</span><br><span class="line">        fileWriter.write(buf, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//注意第二个参数是位置索引，第三个参数是长度len</span></span><br><span class="line">        fileWriter.write(buf1);</span><br><span class="line">        fileWriter.write(buf1, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//和上面的char数组一样的参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">小结</mark> :

<p>和<code>FileOutputStream</code>差不多。注意API的参数。</p>
<mark class="hl-label blue">源码</mark> :

<p><code>close()</code>里面有真正干活的函数。</p>
<p><code>close()</code>&#x3D;<code>flush()</code>+关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeBytes</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    bb.flip();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lim</span> <span class="operator">=</span> bb.limit();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> bb.position();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rem &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch.write(bb) != rem)</span><br><span class="line">            <span class="keyword">assert</span> <span class="literal">false</span> : rem;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        out.write(bb.array(), bb.arrayOffset() + pos, rem);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bb.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a><font color="#5cb85c">节点流和处理流</font></h3><ul>
<li>基本介绍</li>
</ul>
<ol>
<li>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter[源码]<br><img src="/images/image-20220727194413357.png"></li>
<li>处理流(也叫包装流)是”连接”在已存在的流(节点流或处理流)之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter[源码]<br><img src="/images/image-20220727194745435.png" alt="image-20220727194745435"></li>
</ol>
<ul>
<li>节点流和处理流一览图</li>
</ul>
<p><img src="/images/image-20220727195037031.png" alt="image-20220727195037031"></p>
<mark class="hl-label blue">案例</mark> :

<p><img src="/images/image-20220727210049269.png" alt="image-20220727210049269"></p>
<p><img src="/images/image-20220727210405684.png" alt="image-20220727210405684"></p>
<p><img src="/images/image-20220727210552073.png" alt="image-20220727210552073"></p>
<p><img src="/images/image-20220727210801093.png" alt="image-20220727210801093"></p>
<mark class="hl-label blue">小结</mark> :

<p>节点流是点对点、灵活性不足，出现处理流更为灵活。</p>
<ul>
<li>节点流和处理流的区别和练习</li>
</ul>
<ol>
<li>节点流是底层流&#x2F;低级流，直接跟数据源相接。</li>
<li>处理流(包装流)包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。[源码理解]</li>
<li>处理流(也叫包装流)对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连[模拟修饰器设计模式]</li>
</ol>
<ul>
<li>处理流的功能主要体现在以下两方面：</li>
</ul>
<ol>
<li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率。</li>
<li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大量的数据，使用更加灵活方便。</li>
</ol>
<h4 id="处理流设计模式"><a href="#处理流设计模式" class="headerlink" title="处理流设计模式"></a><font color="#ffd253">处理流设计模式</font></h4><mark class="hl-label orange">模拟</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    做成处理流/包装流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferReader_</span> <span class="keyword">extends</span> <span class="title class_">Reader_</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Reader_ reader_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferReader_</span> <span class="params">(Reader_ reader_)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.reader_ = reader_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装一层</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span> <span class="params">()</span> &#123;</span><br><span class="line">        reader_.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让方法更加灵活，多次读取文件,或者加缓冲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFiles</span> <span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            reader_.readFile();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展readString,批量处理字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readStrings</span> <span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            reader_.readString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    可以认为是节点流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader_</span> <span class="keyword">extends</span> <span class="title class_">Reader_</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader_</span> &#123; <span class="comment">//抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;caonim&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readString</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringReader_</span> <span class="keyword">extends</span> <span class="title class_">Reader_</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取字符串&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BufferReader_</span> <span class="variable">bufferReader_</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferReader_</span>(<span class="keyword">new</span> <span class="title class_">FileReader_</span>());<span class="comment">//灵魂是这个传入的参数已经向上转型。</span></span><br><span class="line">        bufferReader_.readFiles(<span class="number">3</span>);<span class="comment">//这里输出三次文件读取，因为向上转型的原因，这里会调用FileReader_()里面的方法</span></span><br><span class="line">        bufferReader_.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">解析</mark> ：

<p>最关键的是<code>BufferReader_</code>里面传入了<code>Reader_</code>在test类中，构造器传入一个<code>new FileReader_()</code>。因为他是Reader_的子类。这里相当于<font color="Ed5A65">向上转型</font>所以可以传入。所以下面调用的是<code>FileReader_()</code>的方法。</p>
<p>向上转型：有父类引用<code>reader_</code>指向子类的对象<code>FileReader_</code>。</p>
<mark class="hl-label orange">拓展</mark> ：

<p>也可以将<code>Reader_</code>类中的方法改为一个<font color="ed5a64">抽象方法</font>，由子类重写，然后在初始化的时候用动态绑定机制，实现不同方法的调用。</p>
<h3 id="Buffered"><a href="#Buffered" class="headerlink" title="Buffered"></a><font color="#5cb85c">Buffered</font></h3><ul>
<li>处理流-BufferedReader和BufferedWriter</li>
</ul>
<p>​	BufferedReader和BufferedWriter属于字符流，是按照字符来读取数据的<br>​	关闭时，只需要关闭外层流即可[<font color="ed5a64">后面看源码</font>]。底层会自动关闭节点流</p>
<h4 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a><font color="#ffd253">BufferedReader</font></h4><mark class="hl-label orange">应用案例</mark> ：

<p>使用BufferedReader 读取文本文件，并显示在控制台。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示bufferedreader使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bufferedreader_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Bufferedreader.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//创建Bufferedreader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 按行读取 当返回null时候，表示文件读取完毕</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不要忘记关闭流</span></span><br><span class="line">        bufferedReader.close(); <span class="comment">//只需要关闭BufferReader，因为底层就会自动关闭节点流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">源码</mark> ：Bufferedreader

<p><img src="/images/image-20220729215813441.png" alt="image-20220729215813441"></p>
<p><img src="/images/image-20220729221402153.png" alt="image-20220729221402153"></p>
<p>可以看出来<code>Bufferedreader.close</code>调用的还是传入<code>read</code>类里面的对应<code>close</code>方法。</p>
<h4 id="Bufferedwriter"><a href="#Bufferedwriter" class="headerlink" title="Bufferedwriter"></a><font color="#ffd253">Bufferedwriter</font></h4><mark class="hl-label orange">案例</mark> ：

<p>使用Bufferedwriter 写入文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示Bufferedwriter使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bufferedwriter_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Bufferedwriter.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(path));<span class="comment">//覆盖模式</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(path, <span class="literal">true</span>));<span class="comment">//追加模式</span></span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;你是傻屄吗&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();<span class="comment">//插入一个和系统相关的换行</span></span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;原来你是sss&quot;</span>);</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">案例</mark> ：

<p> 使用Buffered  Copy文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    用Buffered实现拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCopy_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Bufferedwriter.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">derFilePath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/BufferedCopy.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFilePath));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(derFilePath));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="comment">//readline 读取一行内容，但是不会读取换行符</span></span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            bufferedWriter.write(line);</span><br><span class="line">            bufferedWriter.newLine();<span class="comment">//插入换行符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>Bufferedwriter和Bufferedread是对字符的操作，不要对二进制文件进行操作[音频、视频、PDF、doc]等等。</p>
<h3 id="Buffered字节处理流"><a href="#Buffered字节处理流" class="headerlink" title="Buffered字节处理流"></a><font color="#5cb85c">Buffered字节处理流</font></h3><ul>
<li>处理流—BufferedInputStream和BufferedOutputStream</li>
</ul>
<p>​	介绍BufferedInputStream</p>
<p><img src="/images/image-20220729231400127.png" alt="image-20220729231400127"></p>
<p>​	BufferedInputStream是字节流，在创建的BufferedInputStream时,会创建一个内部缓冲区数组。</p>
<p><img src="/images/image-20220729231501603.png" alt="image-20220729231501603"></p>
<p><img src="/images/image-20220729235530934.png" alt="image-20220729235530934"></p>
<p>​	介绍BufferedOnpuStream</p>
<p><img src="/images/image-20220729235915522.png" alt="image-20220729235915522"></p>
<p>BufferedOnputStream是字节流，实现缓冲的输出流，可以将多个字节写入底层输出流中，而不必对每次字节写入调用底层系统</p>
<p><img src="/images/image-20220730000043857.png" alt="image-20220730000043857"></p>
<p><img src="/images/image-20220730000256338.png" alt="image-20220730000256338"></p>
<mark class="hl-label orange">小结</mark> ：

<p>与BufferedWriter 和BufferedReader不同是，修饰器是从父类继承下来的。如上面类图所示。</p>
<p>注意<code>FilterInputStream</code>类和<code>FileInputStream</code>类的区别</p>
<p><img src="/images/image-20220730171214048.png" alt="image-20220730171214048"></p>
<mark class="hl-label purple">案例</mark> ：

<p>要求：编程完成图片&#x2F;音乐的拷贝（要求使用BufferedInput…流）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCopy02_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//源头文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">scrpath</span> <span class="operator">=</span> <span class="string">&quot;D:/java图片/Collection.png&quot;</span>;</span><br><span class="line">        <span class="comment">//目标文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Collection.png&quot;</span>;</span><br><span class="line">        <span class="comment">//新建读 的包装流</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(scrpath));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dpath));</span><br><span class="line">        <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//read方法返回读取到的长度，读完了就返回-1</span></span><br><span class="line">        <span class="keyword">while</span> ((readlen = bufferedInputStream.read(b)) != -<span class="number">1</span> ) &#123;</span><br><span class="line">            bufferedOutputStream.write(b, <span class="number">0</span>, readlen);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法使用和BufferedWriter&#x2F;Reader差不多。</p>
<mark class="hl-label purple">思考</mark> ：

<p>可以使用BufferedOutStream和BufferedInputStream完成操作文本文件吗</p>
<p><font color="EE3F4D">当然可以</font>，字符由字节组成，字节是这里最小的单位了。反过来用BufferedWriter就不能操作字节文件了。</p>
<h3 id="对象流-序列化"><a href="#对象流-序列化" class="headerlink" title="对象流(序列化)"></a><font color="#5cb85c">对象流(序列化)</font></h3><p>ObjectInputStream和ObjectoutputStream</p>
<p>看一个需求</p>
<ol>
<li>将int num &#x3D; 100 这个int 数据保存到文件中，注意不是100数字，而是int 100, 并且，能够从文件中直接恢复int 100</li>
<li>将Dog dog &#x3D; new Dog(“小黄”，3)这个对象保存到文件中，并且能够从文件中恢复</li>
<li>上面的要求，就是能够将基本数据类型或者对象进行<font color="#5cb85c">序列化和反序列化</font>操作</li>
</ol>
<p>序列化和反序列化</p>
<ol>
<li>序列化就是在保存数组时，保存<font color="EE3F4D">数据的值和数据类型</font></li>
<li>反序列化就是在恢复数据时，恢复数据的值和数据类型</li>
<li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类<br>必须实现如下两个接口之一：<br><font color="EE3F4D">Serializable</font> &#x2F;&#x2F;这是一个标记接口, 没有任何方法<br><font color="#5cb85c">Externalizable</font> &#x2F;&#x2F;该方法有方法需要实现，因此我们一般实现上面这个接口</li>
</ol>
<p><img src="/images/image-20220731180225488.png" alt="image-20220731180225488"></p>
<p>基本介绍</p>
<p><img src="/images/image-20220731181219341.png" alt="image-20220731181219341"></p>
<ol>
<li>功能：提供了对基本类型或者对象类型的序列化和反序列化的方法</li>
<li>ObjectOutputStream提供序列化功能</li>
<li>ObjectInputStream提供了反序列化功能</li>
</ol>
<h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a><font color="#ffd253">ObjectOutputStream</font></h4><p><img src="/images/image-20220731181512198.png" alt="image-20220731181512198"></p>
<mark class="hl-label purple">案例</mark> ：

<p>使用ObjectOutputStream序列化基本数据类型和一个Dog对象(name, age),并保存到data.dat文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示：对象流ObjectOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Object01.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line">        <span class="comment">//序列化数据到：D:/JavaIO练习/Object01.dat</span></span><br><span class="line">        oos.writeInt(<span class="number">100</span>);<span class="comment">//int -&gt; integer 自动装箱 （这里实现了Serializable）因为Integer类继承了Number而Number实现了接口Serializable</span></span><br><span class="line">        oos.writeBoolean(<span class="literal">true</span>);<span class="comment">//boolean -&gt; Boolean  也是实现了序列化</span></span><br><span class="line">        oos.writeByte(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// char -&gt; Charactar</span></span><br><span class="line">        oos.writeDouble(<span class="number">9.8</span>);<span class="comment">// double -&gt;Double</span></span><br><span class="line">        oos.writeUTF(<span class="string">&quot;飒飒撒&quot;</span>);<span class="comment">//String</span></span><br><span class="line">        <span class="comment">//保存一个dog对象,dog类没有实现接口Serializable，没有序列化</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;lwt&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">//序列化的版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">注意</mark> ：

<p>上面的基本类型都是实现了接口Serializable的，所以不用序列化，他自动装箱后就已经可以序列化了。</p>
<p><code>.dat</code>文件：</p>
<p>.dat并不是一种标准文件。许多文件都使用这个扩展名，但文件含义不同。而许多数据分析软件也用这个扩展名保存数据。所以这要看具体的软件情况来定。DAT文件，可以按照扩展名来看就是DATA的意思，即数据文件，这类文件并没有进行绝对化的定义，例如VCD光盘中的dat文件就可以用一般的视频播放器打开，而QQ的dat文件中则存储了用户信息，是不能使用常规方式打开的，只有QQ程序可以访问。还有一些其他程序都有自己对dat文件的定义，要通过产生它的程序来打开与之相关联的dat文件。</p>
<h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a><font color="#ffd253">ObjectInputStream</font></h4><p><img src="/images/image-20220731201542482.png" alt="image-20220731201542482"></p>
<mark class="hl-label purple">案例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jth.javaee.IO.InputStream_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    演示对象流输入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//指定反序列化的位置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">scrpath</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/Object01.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(scrpath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="comment">//1、读取顺序（反序列化）的顺序需要和保存的数据顺序（序列化）保持一直</span></span><br><span class="line">        <span class="comment">//2、否则会出现异常</span></span><br><span class="line">        System.out.println(ois.readInt());</span><br><span class="line">        System.out.println(ois.readBoolean());</span><br><span class="line">        System.out.println(ois.readChar());</span><br><span class="line">        System.out.println(ois.readDouble());</span><br><span class="line">        System.out.println(ois.readUTF());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行类型&quot;</span>+o.getClass());</span><br><span class="line">        <span class="comment">//System.out.println(ois.readObject()); //底层Object -&gt; Dog</span></span><br><span class="line">		<span class="comment">//读取两次会报错</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">注意</mark> ：

<p>文件只能读取一次，这里读取了两次，会报错EOFexception</p>
<ol>
<li>如果我们希望调用Dog里面的方法，需要向下转型</li>
<li>需要我们将Dog类的定义，拷贝到可以引用的位置，比如public class。</li>
</ol>
<h3 id="对象处理流的注意事项"><a href="#对象处理流的注意事项" class="headerlink" title="对象处理流的注意事项"></a><font color="#5cb85c">对象处理流的注意事项</font></h3><ol>
<li>读写顺序要求一致。</li>
<li>要求实现序列化或反序列化对象，需要实现Serializable.</li>
<li>序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性<br>private static final long serialVersionUID &#x3D; 1L;<br>当类进行序列化时，他不会因为类中添加属性等操作，而认为是一个全新的类。他会认为只是原先的升级版或修改版。</li>
<li>序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员<br>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</li>
<li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li>
<li>序列化具备可继承性，也就是如果某类已经实现了序列化，则它所有的子类也已经默认实现了序列化</li>
</ol>
<h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a><font color="#5cb85c">标准输入输出流</font></h3><ul>
<li>标准输入输出流</li>
</ul>
<p>​													类型									默认设备</p>
<p>System.in 标准输入                   InputStream   				  键盘</p>
<p>System.out 标准输出  			  PrintSteam						显示器</p>
<mark class="hl-label purple">案例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputAndOutput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//System in 的public final static InputStream in = null;</span></span><br><span class="line">        <span class="comment">//可得System.in 编译类型是 InputStream</span></span><br><span class="line">        <span class="comment">//System.in 运行类型 BufferedInputStream</span></span><br><span class="line">        <span class="comment">//表示标准输入是键盘</span></span><br><span class="line">        System.out.println(System.in.getClass());<span class="comment">//class java.io.BufferedInputStream</span></span><br><span class="line">        <span class="comment">//public final static PrintStream out = null;</span></span><br><span class="line">        <span class="comment">//System.out 的编译类型是PrintStream</span></span><br><span class="line">        <span class="comment">//运行类型是PrintStream</span></span><br><span class="line">        <span class="comment">//表示：标准输出 显示器</span></span><br><span class="line">        System.out.println(System.out.getClass());<span class="comment">//class java.io.PrintStream</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="comment">//键盘输入这个构造器传入的就是标准输入System.in</span></span><br></pre></td></tr></table></figure>

<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a><font color="#5cb85c">转换流</font></h3><mark class="hl-label purple">案例引出</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codequestion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取D盘下a.txt文件，这个文件是ANSI国标码编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/a.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//创建字符输入流</span></span><br><span class="line">        <span class="comment">//这个读取默认的按照UTF-8的编码读取，所以会出现乱码</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220801215148388.png" alt="image-20220801215148388"></p>
<mark class="hl-label purple">解析</mark> ：

<p>所以需要一个转换格式的确定，保证不会乱码。</p>
<ul>
<li>转换流-InputStreamReader 和OutputStreamWriter</li>
</ul>
<p>介绍</p>
<ol>
<li>InputStreamReader：Reader的子类，可以将InputStream(字节流)包装(转换)成Reader(字符流)</li>
<li>OutputStreamWriter:Writer的子类，实现将OutputStream(字节流)包装成Writer(字符流)</li>
<li>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以将字节流转换成字符流</li>
<li>可以在使用时指定编码格式(比如UTF-8，GBK2312，ISO8859-1等)</li>
</ol>
<h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a><font color="#ffd253">InputStreamReader</font></h4><mark class="hl-label purple">类图</mark> ：

<p><img src="/images/image-20220801220441933.png" alt="image-20220801220441933"></p>
<mark class="hl-label blue">案例</mark> ：

<p>编程将字节流FileIntputStream 包装(转换)成字符流InputStreamReader,对文件进行读取(按照 gbk格式),进而包装成BufferedReader。</p>
<p>解决中文字符乱码问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/a.txt&quot;</span>;<span class="comment">//文件路径</span></span><br><span class="line">        <span class="comment">//解读</span></span><br><span class="line">        <span class="comment">//FileInputStream转换成InputStreamReader</span></span><br><span class="line">        <span class="comment">//指定编码UTF-8</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">//把InputStreamReader 转换成 BufferedReader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//关闭外层流</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">小结</mark> ：

<p>注意各个类的关系，可以看前面对整个IO整合的图。上面实现了两次的包装。</p>
<h4 id="OutputStreamReader"><a href="#OutputStreamReader" class="headerlink" title="OutputStreamReader"></a><font color="#ffd253">OutputStreamReader</font></h4><mark class="hl-label purple">类图</mark> ：

<p><img src="/images/image-20220801221023145.png" alt="image-20220801221023145"></p>
<mark class="hl-label blue">案例</mark> ：

<p>编程将字节流FileOutputStream 包装成(转换成)字节流OutputStreamWriter,对文件进行写入(按照gbk格式，可以指定其他，比如utf-8).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:/JavaIO练习/OutputStreamWriter.txt&quot;</span>;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">ous</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path), StandardCharsets.UTF_8);<span class="comment">//追加模式</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(ous);</span><br><span class="line">        <span class="type">String</span> <span class="variable">scrouce</span> <span class="operator">=</span> <span class="string">&quot;起飞辣&quot;</span>;</span><br><span class="line">        bw.write(scrouce);</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a><font color="#5cb85c">PrintStream</font></h3><p>打印流只有输出流，没有输入流。</p>
<mark class="hl-label purple">类图</mark> ：

<p><img src="/images/image-20220801224453008.png" alt="image-20220801224453008"></p>
<mark class="hl-label purple">构造方法</mark> ：

<p><img src="/images/image-20220801224509368.png" alt="image-20220801224509368"></p>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printstream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">        <span class="comment">//在默认情况下PrintStream输出数据位置是标准位置即显示器，还可以打印到文件中</span></span><br><span class="line">        out.println(<span class="string">&quot;买不买轴&quot;</span>);</span><br><span class="line">        <span class="comment">//源码</span></span><br><span class="line"><span class="comment">//        public void println(String x) &#123;</span></span><br><span class="line"><span class="comment">//            synchronized (this) &#123;</span></span><br><span class="line"><span class="comment">//                print(x);</span></span><br><span class="line"><span class="comment">//                newLine();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        public void print(String s) &#123;</span></span><br><span class="line"><span class="comment">//            if (s == null) &#123;</span></span><br><span class="line"><span class="comment">//                s = &quot;null&quot;;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            write(s);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//可以看出底层println用的就是writer</span></span><br><span class="line">        out.write(<span class="string">&quot;冲吧就100块钱&quot;</span>.getBytes());<span class="comment">//结果还是一样的</span></span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们可以修改打印流的位置/设备</span></span><br><span class="line">        <span class="comment">//这里修改到对应路径</span></span><br><span class="line">        System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;D:/JavaIO练习/printstream.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//底层源码</span></span><br><span class="line"><span class="comment">//        public static void setOut(PrintStream out) &#123;</span></span><br><span class="line"><span class="comment">//            checkIO();</span></span><br><span class="line"><span class="comment">//            setOut0(out);  //这是一个native方法</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;好棒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a><font color="#5cb85c">PrintWriter</font></h3><mark class="hl-label purple">类图</mark> ：

<p><img src="/images/image-20220801224733848.png" alt="image-20220801224733848"></p>
<mark class="hl-label orange">案例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printwriter_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out);</span><br><span class="line">        printWriter.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        printWriter.close();</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:/JavaIO练习/printwriter.txt&quot;</span>));</span><br><span class="line">        printWriter1.println(<span class="string">&quot;diaomao&quot;</span>);</span><br><span class="line">        printWriter1.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>打完数据一定要<code>close</code>和之前写都一样，底层源码close才是正正干活的地方。真真写入的地方。</p>
<p><img src="/images/image-20220801232906451.png" alt="image-20220801232906451"></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a><font color="#5cb85c">Properties</font></h3><ul>
<li>看一个需求</li>
</ul>
<p>如下一个配置文件 mysql.properties</p>
<p>ip &#x3D; 192.168.0.13</p>
<p>user &#x3D; root</p>
<p>pwd &#x3D; 12345</p>
<p>请问编程读取ip , user, 和pwd的值是多少</p>
<ol>
<li>传统的方法</li>
<li>使用Properties类可以方便实现</li>
</ol>
<mark class="hl-label red">传统方法</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取mysql.properties文件</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src/mysql.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">            String[] split = line.split(<span class="string">&quot;=&quot;</span>);  <span class="comment">//正则表达式</span></span><br><span class="line">            System.out.println(split[<span class="number">0</span>]+<span class="string">&quot;值是&quot;</span>+split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();<span class="comment">//关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">问题引出</mark> ：

<p>如果使用这种方法，需求是取ip地址，那么就会很麻烦。还需要判断<code>split[0]</code>。</p>
<p>String.split是正则表达式。</p>
<h3 id="properties读文件"><a href="#properties读文件" class="headerlink" title="properties读文件"></a><font color="#5cb85c">properties读文件</font></h3><ul>
<li>基本介绍</li>
</ul>
<p><img src="/images/image-20220802152053929.png" alt="image-20220802152053929"></p>
<ol>
<li>专门用于读写配置文件的<font color="F07C82">集合类</font><br>配置文件的格式：<br>键&#x3D;值<br>键&#x3D;值</li>
<li>注意：键值对不需要有空格，值不需要用引号括起来，默认类型是<code>String</code>。</li>
<li>Properties常用方法</li>
</ol>
<ul>
<li>load:加载配置文件的键值对到Properties对象</li>
<li>list:将数据显示到指定设备</li>
<li>getProperty(key):根据键获取值</li>
<li>setPropety(key，value): 设置键值对到Properties对象</li>
<li>store:将Properties中的键值对存储到配置文件中，在idea中，保存信息到配置文件，如果含有中文，会存储为Unicode码。、</li>
</ul>
<mark class="hl-label blue">案例</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//使用Properties类读取文件</span></span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//加载指定配置文件</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//显示到指定位置（控制台）</span></span><br><span class="line">        properties.list(System.out);</span><br><span class="line">        <span class="comment">//根据Key获取对应的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名是&quot;</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">解析</mark> ：

<p>因为文件类型是<code>.properties</code>。所以在调用<code>getProperty</code>方法时候会按照他的源码方式读取，如果我将getPropeties参数改成”root”，没有按照底层格式，则会返回null。</p>
<h3 id="properties修改文件"><a href="#properties修改文件" class="headerlink" title="properties修改文件"></a><font color="#5cb85c">properties修改文件</font></h3><mark class="hl-label blue">案例</mark> ：

<p>1.使用Properties类添加key-val到新文件 mysql2.properties中</p>
<p>2.使用Properties类完成对mysql.properties的读取，并修改某个key-val</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;芜湖&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;0002&quot;</span>,<span class="string">&quot;niubi&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;0003&quot;</span>,<span class="string">&quot;niubi2&quot;</span>);</span><br><span class="line">        <span class="comment">//1.使用Properties类添加key-val到新文件 mysql2.properties中</span></span><br><span class="line">        <span class="comment">//使用字节流输出，不然会乱码。因为他是Unicode编码</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql2.properties&quot;</span>),<span class="string">&quot;cao&quot;</span>);<span class="comment">//cao这个位置是comments注解注释的意思</span></span><br><span class="line">        System.out.println(<span class="string">&quot;保存成功&quot;</span>);</span><br><span class="line">        <span class="comment">//2.使用Properties类完成对mysql.properties的读取，并修改某个key-val</span></span><br><span class="line">        <span class="comment">//如果该文件没有对应的key就是创建，</span></span><br><span class="line">        <span class="comment">//如果该文件有对应的key就是修改</span></span><br><span class="line">        <span class="comment">//底层源码</span></span><br><span class="line"><span class="comment">//        public synchronized V put(K key, V value) &#123;</span></span><br><span class="line"><span class="comment">//            // Make sure the value is not null</span></span><br><span class="line"><span class="comment">//            if (value == null) &#123;</span></span><br><span class="line"><span class="comment">//                throw new NullPointerException();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            // Makes sure the key is not already in the hashtable.</span></span><br><span class="line"><span class="comment">//            Hashtable.Entry&lt;?,?&gt; tab[] = table;</span></span><br><span class="line"><span class="comment">//            int hash = key.hashCode();</span></span><br><span class="line"><span class="comment">//            int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span></span><br><span class="line"><span class="comment">//            @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="comment">//            Hashtable.Entry&lt;K,V&gt; entry = (Hashtable.Entry&lt;K,V&gt;)tab[index];</span></span><br><span class="line"><span class="comment">//            for(; entry != null ; entry = entry.next) &#123;</span></span><br><span class="line"><span class="comment">//                if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span></span><br><span class="line"><span class="comment">//                    V old = entry.value;</span></span><br><span class="line"><span class="comment">//                    entry.value = value;</span></span><br><span class="line"><span class="comment">//                    return old;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            addEntry(hash, key, value, index);</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO流作业"><a href="#IO流作业" class="headerlink" title="IO流作业"></a><font color="#5cb85c">IO流作业</font></h3><ol>
<li>编程题</li>
</ol>
<p>​		判断D盘下是否有文件夹mytemp,如果没有就创建mytemp</p>
<p>​		在D:&#x2F;mytemp目录下，创建文件hello.txt</p>
<p>​		如果hello.txt已经存在，提示该文件已经存在，就不要再重复创建了</p>
<p>​        写入hello.world</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 作业<span class="number">01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">directorypath</span> <span class="operator">=</span> <span class="string">&quot;D:/mytemp&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(directorypath);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该目录存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.mkdirs()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;目录创建成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;目录创建失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filepath</span> <span class="operator">=</span> <span class="string">&quot;D:/mytemp/hello.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filepath);</span><br><span class="line">        <span class="keyword">if</span> (file1.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已经存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            file1.createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filepath));<span class="comment">//会自动创建文件。</span></span><br><span class="line">            bw.write(<span class="string">&quot;hello.world&quot;</span>);</span><br><span class="line">            bw.close();<span class="comment">//关闭流</span></span><br><span class="line">            System.out.println(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>真正创建文件的是<code>createFile()</code>这个方法。</p>
<p><code>BufferedWriter bw = new BufferedWriter(new FileWriter(filepath));</code>这句话如果没有文件他自动会创建好，只要路径对。所以将对象写到最里面，避免影响。</p>
<p>2、编程题</p>
<p>要求：使用BufferedReader读取一个文本文件，为每行加上行号。</p>
<p>再连同内容一并输出到屏幕上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 作业<span class="number">02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/a.txt&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(i +<span class="string">&quot; &quot;</span>+ line);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、编程题</p>
<p>要求编写一个dog.properties</p>
<p>name&#x3D;tom</p>
<p>age&#x3D;5</p>
<p>color&#x3D;red</p>
<p>编写Dog类（name,age,color)创建一个dog对象，读取dog.properties用相应的内容完成属性初始化，并输出。</p>
<p>序列化、反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 作业<span class="number">03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;src/dog.properties&quot;</span>;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> properties.get(<span class="string">&quot;name&quot;</span>)+<span class="string">&quot;&quot;</span>;<span class="comment">//将object类型转换成String</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span>Integer.parseInt(properties.get(<span class="string">&quot;age&quot;</span>)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> properties.get(<span class="string">&quot;color&quot;</span>)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(name, age, color);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将dog类序列化到dog.dat</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path1</span> <span class="operator">=</span> <span class="string">&quot;src/dog.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path1));</span><br><span class="line">        oos.writeObject(dog);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path1));</span><br><span class="line">        <span class="comment">//System.out.println(ois.readObject());//都行</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span>(Dog) ois.readObject();</span><br><span class="line">        System.out.println(dog1);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;<span class="comment">//实现序列化</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p><code>properties.get</code>这个方法返回Object类，使用<code>getproperties</code>是返回String类型。</p>
<p>类型转换的时候，Object转成一个int类型需要先转换成String类型。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a><font color="#6dc1f7">网络编程</font></h2><h3 id="网络相关概念"><a href="#网络相关概念" class="headerlink" title="网络相关概念"></a><font color="#5cb85c">网络相关概念</font></h3><ul>
<li>网络通信</li>
</ul>
<ol>
<li>概念：两台设备之间通过网络实现数据传输</li>
<li>网络通信：将数据通过网络从一台设备传输到另一台设备</li>
<li>java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信</li>
</ol>
<p><img src="/images/image-20220805225621787.png" alt="image-20220805225621787"></p>
<ul>
<li>网络</li>
</ul>
<ol>
<li>概念：两台或多态设备通过一定物理设备连接起来构成了网络</li>
<li>根据网络的覆盖范围不同，对网络进行分类：<br>局域网：覆盖范围最小，仅仅覆盖一个教师或一个机房<br>城域网：覆盖范围较大，可以覆盖一个城市<br>广域网：覆盖范围最大，可以覆盖全国，甚至全球，万维网是广域网的代表。</li>
</ol>
<p><img src="/images/image-20220805225835947.png" alt="image-20220805225835947"></p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a><font color="#5cb85c">IP地址</font></h3><ol>
<li>概念：用于唯一标识网络中的每台计算机</li>
<li>查看ip地址：ipconfig</li>
<li>ip地址的表示形式：点分十进制 xx.xx.xx.xx</li>
<li>每一个十进制数的范围：0~255</li>
<li>ip地址的组成&#x3D;网络地址+主机地址，比如：192.168.16.69</li>
<li>IPv6是互联网工程任务组设计的用于替代IPv4的下一代IP协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址[1].</li>
<li>由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍。</li>
</ol>
<p><img src="/images/image-20220806204614876.png" alt="image-20220806204614876"></p>
<ul>
<li>ipv4地址分类</li>
</ul>
<p><img src="/images/image-20220806210841167.png" alt="image-20220806210841167"></p>
<mark class="hl-label red">注意</mark> ：

<p>服务器的地址一般是静态的，固定不变的。主机什么的可以修改。</p>
<h3 id="域名和端口"><a href="#域名和端口" class="headerlink" title="域名和端口"></a><font color="#5cb85c">域名和端口</font></h3><ul>
<li>域名</li>
</ul>
<ol>
<li><a href="http://www.baidu.com/">www.baidu.com</a></li>
<li>好处：为了方便</li>
<li>概念：将ip地址映射成域名 (http协议)</li>
</ol>
<ul>
<li>端口号</li>
</ul>
<ol>
<li>概念：用于标识计算机上某个<font color="EE3F4D">特定的网络程序</font></li>
<li>表示形式：以整数形式，范围0~65535</li>
<li><font color="EE3F4D">0~1024已经被占用</font>，比如ssh 22, ftp 21, smtp 25 http 80</li>
<li>常见的网络程序端口号：<br>tomcat:8080<br>mysql:3306<br>oracle:1521<br>sqlserver:1433</li>
</ol>
<p><img src="/images/image-20220807141620533.png" alt="image-20220807141620533"></p>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a><font color="#5cb85c">网络协议</font></h3><ul>
<li>网络通信协议</li>
</ul>
<p>协议（tcp&#x2F;ip）</p>
<p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）的简写。</p>
<p>中文译名为传输控制协议&#x2F;因特网互联协议，又叫网络通讯协议，这个协议是Internet最基本的协议、Internet国际互联网络的基础，简单地说，就是由网络层的IP协议和传输层的TCP协议组成的</p>
<p><img src="/images/image-20220807145042556.png" alt="image-20220807145042556"></p>
<p><img src="/images/image-20220807145226451.png" alt="image-20220807145226451"></p>
<p><img src="/images/image-20220807150940405.png" alt="image-20220807150940405"></p>
<h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a><font color="#5cb85c">TCP和UDP</font></h3><ul>
<li>TCP和UDP</li>
</ul>
<p>​	TCP协议：</p>
<ol>
<li>使用TCP协议前，必须建立TCP连接，形成传输数据通道</li>
<li>传输前，采用”三次握手”方式，是<font color="#5cb85c">可靠的</font></li>
<li>TCP协议进行通信的两个应用程序：客户端、服务端</li>
<li>在连接中可进行大数据量的传输</li>
<li>传输完毕，需释放已建立的连接，<font color="EE3F4D">效率低</font>。</li>
</ol>
<p>​	UDP协议：</p>
<ol>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据的大小限制在64K内，不适合传输大量数据</li>
<li>因无需连接，故是<font color="EE3F4D">不可靠的</font></li>
<li>发送数据结束时无需释放资源(因为不是面向连接)，速度快</li>
<li>举例：厕所通知：发短信</li>
</ol>
<mark class="hl-label red">三次握手</mark> ：

<p>第一次向server发包</p>
<p><img src="/images/image-20220807151949220.png" alt="image-20220807151949220"></p>
<p>第二次回一个</p>
<p><img src="/images/image-20220807152023584.png" alt="image-20220807152023584"></p>
<p>第三次再向server回一个包</p>
<p><img src="/images/image-20220807152053682.png" alt="image-20220807152053682"></p>
<mark class="hl-label blue">模拟</mark> ：

<p>TCP</p>
<p><img src="/images/image-20220807161942943.png" alt="image-20220807161942943"></p>
<p>UDP</p>
<p><img src="/images/image-20220807162406978.png" alt="image-20220807162406978"></p>
<h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a><font color="#5cb85c">InetAddress类</font></h3><ul>
<li>相关方法</li>
</ul>
<ol>
<li>获取本机InetAddress对象 getLocalHost</li>
<li>根据指定主机名&#x2F;域名获取ip地址对象 getByName </li>
<li>获取InetAddress对象的主机名 getHostName</li>
<li>获取InetAddress对象的地址 getHostAddress</li>
</ol>
<mark class="hl-label blue">代码</mark> ：

<p><img src="/images/image-20220807182436108.png" alt="image-20220807182436108"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">API_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">//1、这是一个类方法</span></span><br><span class="line">        <span class="comment">//获取本机的InetAddress对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(localHost);<span class="comment">//LAPTOP-D4QMQFD0/192.168.0.107</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、根据主机指定主机名称，获取InetAddress对象。</span></span><br><span class="line">        System.out.println(InetAddress.getByName(<span class="string">&quot;LAPTOP-D4QMQFD0&quot;</span>));<span class="comment">//LAPTOP-D4QMQFD0/192.168.0.107</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、根据域名返回InetAddress对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(byName);<span class="comment">//www.baidu.com/180.101.49.11</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、通过InetAddress，获取对应地址/获取主机名，如果他没有主机名字可能返回域名</span></span><br><span class="line">        System.out.println(localHost.getHostAddress());<span class="comment">//192.168.0.107</span></span><br><span class="line">        System.out.println(byName.getHostName());<span class="comment">//www.baidu.com</span></span><br><span class="line">        System.out.println(localHost.getHostName());<span class="comment">//LAPTOP-D4QMQFD0</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a><font color="#5cb85c">Socket</font></h3><ul>
<li>基本介绍</li>
</ul>
<ol>
<li>套接字（Socket）开发网络应用程序被广泛采用，以至于成为事实上的标准。</li>
<li>通信的两端都要有Socket，是两台机器间通信的端点</li>
<li>网络通信其实就是Socket间的通信。</li>
<li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输</li>
<li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li>
</ol>
<p><img src="/images/image-20220807214235614.png" alt="image-20220807214235614"></p>
<ul>
<li><p>TCP网络通信编程（可靠的）</p>
<ul>
<li>基本介绍</li>
</ul>
<ol>
<li>基于客户端–服务端的网络通信</li>
<li>底层使用的是TCP&#x2F;IP协议</li>
<li>应用场景举例：客户端发送数据，服务端接受并显示</li>
<li>基于Socket的TCP编程</li>
</ol>
</li>
</ul>
<p><img src="/images/image-20220807214915856.png" alt="image-20220807214915856"></p>
<mark class="hl-label red">注意</mark> ：

<p>客户端和服务器端通常情况下，是在不同主机的，但是下面例子都是在同一台机器演示</p>
<h4 id="TCP字节流编程"><a href="#TCP字节流编程" class="headerlink" title="TCP字节流编程"></a><font color="#ffd253">TCP字节流编程</font></h4><mark class="hl-label orange">案例1</mark> ：

<ol>
<li>编写一个服务器端，和一个客户端</li>
<li>服务器端在9999端口监听（只能监听一次）</li>
<li>客户端连接到服务器端，发送”hello，server“；然后退出</li>
<li>服务器端接收到客户端发送的信息，输出，并退出</li>
</ol>
<mark class="hl-label red">注意</mark> ：

<p>注意写的是两个程序   服务端和客户端。</p>
<mark class="hl-label blue">示意图</mark> ：

<p><img src="/images/image-20220808171406707.png" alt="image-20220808171406707"></p>
<mark class="hl-label blue">代码</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 编写一个服务器端，和一个客户端</span></span><br><span class="line"><span class="comment">//        2. 服务器端在9999端口监听（只能监听一次）</span></span><br><span class="line"><span class="comment">//        3. 客户端连接到服务器端，发送”hello，server“；然后退出</span></span><br><span class="line"><span class="comment">//        4. 服务器端接收到客户端发送的信息，输出，并退出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP01Sever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//表示在本机的9999端口监听 。 要求本机没有占用这个端口9999</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//当没有客户端接到9999端口时，程序会阻塞，等待连接</span></span><br><span class="line">        <span class="comment">//如果有客户端连接， 就会返回一个Socket对象，程序继续</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端口9999在监听，等待连接&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端 Socket=&quot;</span> + socket.getClass());</span><br><span class="line">        <span class="comment">//获得输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//IO流读取</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span> [] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ( (read = inputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, read));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP01Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//意思是连接这个主机（本机)的9999端口</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端 socket返回&quot;</span>+ socket.getClass());</span><br><span class="line">        <span class="comment">//连接上后生成socket通过方法得到输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;去死吧&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//关闭流对象和socket   必须</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220808172143368.png" alt="image-20220808172143368"></p>
<p><img src="/images/image-20220808172153676.png" alt="image-20220808172153676"></p>
<mark class="hl-label blue">细节</mark> ：

<p><code>Socket socket = serverSocket.accept();</code>可以返回多个Socket【多个客户端连接服务器的并发】，所以最后需要关闭这个，避免资源的浪费。</p>
<p><code>ServerSocket serverSocket = new ServerSocket(9999);</code></p>
<p>&#x2F;&#x2F;当没有客户端接到9999端口时，程序会阻塞，等待连接</p>
<mark class="hl-label orange">案例2</mark> ：

<ol>
<li>编写一个服务器端，和一个客户端</li>
<li>服务器端在9999端口监听</li>
<li>客户端连接到服务器端，发送”hello,sever”,并接收服务器端回发的“hello，client，再退出</li>
<li>服务器端接收到客户端发送的信息，输出，并发送”hello，client“，再退出</li>
</ol>
<mark class="hl-label blue">示意图</mark> ：

<p><img src="/images/image-20220808185555195.png" alt="image-20220808185555195"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP02Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,sever&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput();<span class="comment">//相当于一个输出结束标识符</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((read = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span> ,read));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP02Sever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((read = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, read));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;hello,Client&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">解析</mark> ：

<p>和案例一的区别就是加一个，结束标识符号就行<code>socket.shutdownInput();socket.shutdownOutput();</code></p>
<h4 id="TCP字符流编程"><a href="#TCP字符流编程" class="headerlink" title="TCP字符流编程"></a><font color="#ffd253">TCP字符流编程</font></h4><mark class="hl-label orange">案例3</mark> ：

<p><font color="#ffd253">使用字符流</font></p>
<ol>
<li>编写一个服务端，和一个客户端</li>
<li>服务端再8888端口监听</li>
<li>客户端连接到服务端，发送”hello,server”,并接收服务端回发的“hello,client,再退出。</li>
<li>服务端接收到客户端发送的信息，输出，并发送”hello,client”,再退出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP03Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//使用转换流</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(outputStreamWriter);</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,sever&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();<span class="comment">//结束符</span></span><br><span class="line">        bufferedWriter.flush();<span class="comment">//必须要刷新，不刷新不会写入，并且会导致异常</span></span><br><span class="line">        <span class="comment">//socket.shutdownOutput();</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP03Sever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(outputStreamWriter);</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,client&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();<span class="comment">//结束符</span></span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        <span class="comment">//socket.shutdownOutput();</span></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>可以使用<code>write.newline()</code>,但是另一边读取的时候必须用<code>readline();</code></p>
<p>写入后必须使用<code>flush()</code>才能是数据写入，不然会报异常（使用socket.shutdownOutput();当作结束符的时候），在<code>bufferedWriter.close();</code>报异常。因为没有写入就close了。</p>
<p>BufferedWriter装饰器，不用使用循环读数据，里面已经给你封装好方法，切勿混淆。</p>
<h4 id="网络上传文件"><a href="#网络上传文件" class="headerlink" title="网络上传文件"></a><font color="#ffd253">网络上传文件</font></h4><mark class="hl-label orange">案例4</mark> ：

<ol>
<li>编写一个服务端，和一个客户端</li>
<li>服务端在8888端口监听</li>
<li>客户端连接到服务端，发送一张图片</li>
<li>服务端接收到客户端发送的图片，保存到src下，发送”收到图片”再退出</li>
<li>客户端接收到服务端发送的”收到图片“。再退出</li>
<li>该程序要求使用StreamUtils.java 自己封装的类</li>
</ol>
<mark class="hl-label blue">示意图</mark> ：

<p><img src="/images/image-20220808214655646.png" alt="image-20220808214655646"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP04Sever</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//等待连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">//得到输入流， 读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//使用输入流转数组的方法</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = StreamUtils.streamToByteAray(inputStream);</span><br><span class="line">        outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src/Collection01.png&quot;</span>);</span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向客户端发送收到图片使用字符流</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">        bw.write(<span class="string">&quot;收到图片&quot;</span>);</span><br><span class="line">        bw.flush();<span class="comment">//把内容真正写入（刷新）</span></span><br><span class="line">        <span class="comment">//socket.shutdownOutput();//写入结束标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        bw.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        <span class="comment">//关闭其他流</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP04Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//调用方法，将图片转换成数组</span></span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/Collection.png&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = StreamUtils.streamToByteAray(inputStream);</span><br><span class="line">        <span class="comment">//传图片对应的数组内容写入到数据通道</span></span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        <span class="comment">//结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接受服务端的消息使用字节流读入</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream1</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//使用工具类中方法，将输入流转换成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> StreamUtils.streamToString(inputStream1);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        inputStream1.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamUtils</span> &#123;</span><br><span class="line">    <span class="comment">//将流转换成数组的方法，输入形参可以是图片，通过fileInputStream就可以传入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] streamToByteAray(InputStream is) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readlen = is.read(buf)) != -<span class="number">1</span>) &#123;<span class="comment">//循环读取的目的防止数组太小，不能一次性读完</span></span><br><span class="line">            bo.write(buf, <span class="number">0</span>, readlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes = bo.toByteArray();</span><br><span class="line">        bo.close();<span class="comment">//注意关闭流</span></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将inputStream转换成String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">streamToString</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line=bw.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            builder.append(line+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">注意</mark> ：

<p>这个版本的JDK不用每次都有结束符，比如就要发送一次数据。有了<code>socket.close()</code>上面不用写结束标志，不然会报错。</p>
<p>输入流输出流的读写都是，靠数组转换，输入就<code>read()</code>，因为不确定大小，并且数组在初始化后就能改变大小，所以需要循环读取。然后会保存到流中，这个很关键，就可以调用这个流类里面的方法，比如上面&#96;StreamToArrays，调用toArrays方法完成转换。</p>
<h4 id="netstat指令"><a href="#netstat指令" class="headerlink" title="netstat指令"></a><font color="#ffd253">netstat指令</font></h4><ol>
<li>netstat -an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况</li>
<li>netstat -an | more 可以分页显示</li>
<li>netstat -anb 可以显示具体是哪个软件在使用这个端口(需要管理员身份)</li>
<li>要求在dos控制台下执行(cmd)</li>
</ol>
<p><img src="/images/image-20220809133140373.png" alt="image-20220809133140373"></p>
<mark class="hl-label orange">说明</mark> ：

<ol>
<li>Listening 表示某个端口在监听</li>
<li>如果有一个外部程序(客户端)连接到该端口，就会显示一条连接消息。</li>
<li>Ctrl+C 退出程序</li>
</ol>
<h4 id="TCP连接秘密"><a href="#TCP连接秘密" class="headerlink" title="TCP连接秘密"></a><font color="#ffd253">TCP连接秘密</font></h4><ol>
<li><p>当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是TCP&#x2F;IP来分配的,是不确定的，是随机的</p>
</li>
<li><p>示意图<br><img src="/images/image-20220809155233928.png" alt="image-20220809155233928"></p>
</li>
<li><p>程序验证+netstat</p>
<p><img src="/images/image-20220809160109224.png" alt="image-20220809160109224"><br><img src="/images/image-20220809160131485.png" alt="image-20220809160131485"></p>
</li>
</ol>
<mark class="hl-label orange">说明</mark> ：

<p>客户端的socket端口是随机的，重启就会改变端口号(60285)；</p>
<p>为什么能看到两个8888，因为服务器和客户端在同一台电脑上。</p>
<h3 id="UDP编程-了解"><a href="#UDP编程-了解" class="headerlink" title="UDP编程(了解)"></a><font color="#5cb85c">UDP编程(了解)</font></h3><ul>
<li>基本介绍</li>
</ul>
<ol>
<li>类DatagramSocket和DatagramPacket[数据报&#x2F;数据包]实现了基于UDP协议网络程序。</li>
<li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送发哦目的地，也不能确定什么时候可以抵达</li>
<li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接</li>
</ol>
<ul>
<li>基本流程</li>
</ul>
<ol>
<li>核心的两个类&#x2F;对象 DatagramSocket与DatagramPacket</li>
<li>建立发送端，接收端（没有服务端和客户端的概念）</li>
<li>建立数据包&#x2F;报 DatagramPacket对象</li>
<li>调用DatagramSocket的发送，接收方法</li>
<li>关闭DatagramSocket</li>
</ol>
<p><img src="/images/image-20220809162203784.png" alt="image-20220809162203784"></p>
<p><img src="/images/image-20220809162226379.png" alt="image-20220809162226379"></p>
<mark class="hl-label blue">案例</mark> ：

<ol>
<li>编写一个接收端A和一个发送端B</li>
<li>接收端A在9999端口等待接收数据（receive）</li>
<li>发送端B向接收端A发送数据”hello，明天吃火锅“</li>
<li>接收端A接收到发送端B发送的数据，回复”好的明天吃火锅”</li>
<li>发送端接收回复的数据，再退出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketUDP_B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建DatagramSocket 对象，准备在9998接收数据</span></span><br><span class="line">        <span class="comment">//同一台机器，所以端口要不一样</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="comment">//2、将需要发送的数据，装包到DatagramPacket对象中，</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;明天吃火锅,caonima&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//3、发送数据</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">        <span class="comment">//拆包</span></span><br><span class="line">        socket.receive(packet1);</span><br><span class="line">        <span class="type">byte</span>[] data = packet1.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet1.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length));</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketUDP_A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个DatagramSocket对象，准备在9999接收数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、构建一个DatagramPacket对象，准备接收数据</span></span><br><span class="line">        <span class="comment">//前面说过UDP协议，最大支持64K的数据包</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">        <span class="comment">//调用接收方法，将通过网络传输的DatagramPacket对象</span></span><br><span class="line">        <span class="comment">//填充到packet对象</span></span><br><span class="line">        <span class="comment">//提示：当有数据包发送到端口9999时候，此方法就会接收到数据</span></span><br><span class="line">        <span class="comment">//如果没有数据包发送到本机的9999端口，就会阻塞等待。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数据端A等待数据。。。。&quot;</span>);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把packet进行拆包</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength();<span class="comment">//实际接收到的数据长度</span></span><br><span class="line">        <span class="type">byte</span>[] data = packet.getData();<span class="comment">//实际接收到的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A端回消息</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="string">&quot;好的，明天见&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes1, bytes1.length, InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">9998</span>);</span><br><span class="line">        socket.send(packet1);</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;A端退出。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">区别</mark> ：

<p>和TCP的区别是，UDP把数据打包成一个包，就无需考虑截止信号等，流的关闭等。<code>receive（）</code>就相当于TCP的<code>accpet</code>。但是UDP是不可靠的。</p>
<h3 id="网络编程作业"><a href="#网络编程作业" class="headerlink" title="网络编程作业"></a><font color="#5cb85c">网络编程作业</font></h3><p>作业1：</p>
<ol>
<li>使用字符流的方式，编写一个客户端程序和服务端程序</li>
<li>客户端发送”name”,服务端接收到后，返回”我是nova”，nova是你自己的名字</li>
<li>客户端发送”hoby”,服务端接收到后，返回”编写Java程序”</li>
<li>不是这两个问题，回复”你说啥呢”。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 服务器<span class="number">01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//转换流</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">//装饰器</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发来&quot;</span>+s);</span><br><span class="line">        socket.shutdownInput();<span class="comment">//标记结束</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">            bw.write(<span class="string">&quot;我是nova&quot;</span>);</span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;hoby&quot;</span>)) &#123;</span><br><span class="line">            outputStream =socket.getOutputStream();</span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">            bw.write(<span class="string">&quot;写Java程序&quot;</span>);</span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputStream =socket.getOutputStream();</span><br><span class="line">            <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">            bw.write(<span class="string">&quot;你在说啥&quot;</span>);</span><br><span class="line">            bw.flush();</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        br.close();<span class="comment">//关闭流</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 客户端<span class="number">01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>),<span class="number">9999</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//使用转换流</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">//装饰器</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">         <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你的问题&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">massage</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        bw.write(massage);</span><br><span class="line">        bw.flush();<span class="comment">//刷新 写入</span></span><br><span class="line"></span><br><span class="line">        socket.shutdownOutput();<span class="comment">//标识符</span></span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span>  br.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        bw.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>关闭流的时候要在程序末尾关闭，不然会报错。</p>
<p>作业02：</p>
<ol>
<li>编写一个接收端A，和一个发送端B，使用UDP协议完成</li>
<li>接收端在8888端口等待接收数据(receive)</li>
<li>发送端向接收端发送数据”四大名著是哪些”</li>
<li>接收端接收到发送端发送的问题后，返回”四大名著《红楼梦》。。”否则返回你麻痹</li>
<li>接收端和发送端程序退出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 接收端A &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个DatagramSocket对象，准备在9999接收数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2、构建一个DatagramPacket对象，准备接收数据</span></span><br><span class="line">        <span class="comment">//前面说过UDP协议，最大支持64K的数据包</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">        <span class="comment">//调用接收方法，将通过网络传输的DatagramPacket对象</span></span><br><span class="line">        <span class="comment">//填充到packet对象</span></span><br><span class="line">        <span class="comment">//提示：当有数据包发送到端口9999时候，此方法就会接收到数据</span></span><br><span class="line">        <span class="comment">//如果没有数据包发送到本机的9999端口，就会阻塞等待。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数据端A等待数据。。。。&quot;</span>);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把packet进行拆包</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength();<span class="comment">//实际接收到的数据长度</span></span><br><span class="line">        <span class="type">byte</span>[] data = packet.getData();<span class="comment">//实际接收到的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;四大名著是哪些&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//A端回消息</span></span><br><span class="line">            answer = <span class="string">&quot;你这都不知道,红楼梦,三国演义,水浒传,西游记&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//A端回消息</span></span><br><span class="line">            answer = <span class="string">&quot;what&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] bytes1 = answer.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet1</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes1, bytes1.length, InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">9998</span>);</span><br><span class="line">        socket.send(packet1);</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;A端退出。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 发送端B &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建DatagramSocket 对象，准备在9998接收数据</span></span><br><span class="line">        <span class="comment">//同一台机器，所以端口要不一样</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="comment">//2、将需要发送的数据，装包到DatagramPacket对象中，</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入你的问题&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">problem</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">byte</span>[] bytes = problem.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//3、发送数据</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收消息</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);<span class="comment">//bug所在</span></span><br><span class="line">        <span class="comment">//拆包</span></span><br><span class="line">        socket.receive(packet1);</span><br><span class="line">        <span class="type">byte</span>[] data = packet1.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet1.getLength();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> ：

<p>这个输出还是有问题，根据你输入的字符长度显示一样的长度，就导致数据显示不全，不知道问题出哪里了。很难受。</p>
<p>破案了上面的问题就是，数组长度出错了</p>
<p><code>DatagramPacket packet1 = new DatagramPacket(bytes, bytes.length);</code></p>
<p>应该用<code>bvtes1</code>的</p>
<p>作业3：</p>
<ol>
<li>编写客户端程序和服务端程序</li>
<li>客户端可以输入一个音乐文件名，比如高山流水，服务端收到音乐后，可以给可以给客户端返回这个音乐文件，如果服务器没有这个文件，返回默认一个音乐即可，</li>
<li>客户端收到文件后，保存到src</li>
<li>提示：该程序可以使用StreamUtils.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 服务端<span class="number">02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//用于传输音乐文件</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//音乐文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">musicPath</span> <span class="operator">=</span> <span class="string">&quot;D:\\CloudMusic\\Ampyx - Ember.mp3&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">musicPath1</span> <span class="operator">=</span> <span class="string">&quot;D:\\CloudMusic\\Anastasia Kushnir - Yesterday.mp3&quot;</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(musicPath);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(musicPath1);</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        socket.shutdownInput();<span class="comment">//结束标志语句</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;高山流水&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//调用工具类方法将音乐流变成数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = StreamUtils.streamToByteAray(fileInputStream);</span><br><span class="line">            outputStream.write(bytes);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = StreamUtils.streamToByteAray(fileInputStream1);</span><br><span class="line">            outputStream.write(bytes);</span><br><span class="line">            outputStream.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        br.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        fileInputStream1.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 客户端<span class="number">02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;192.168.0.107&quot;</span>), <span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//装饰器</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src/music.mp3&quot;</span>);</span><br><span class="line">        <span class="comment">//消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你想要的歌曲&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">massage</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        bw.write(massage);</span><br><span class="line">        bw.flush();</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始接收音乐文件文件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((readlen = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(bytes, <span class="number">0</span>, readlen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭各种流</span></span><br><span class="line">        bw.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a><font color="#6dc1f7">反射</font></h2><ul>
<li>问题引出</li>
</ul>
<ol>
<li>根据配置文件 re.properties 指定信息，创建Cat对象并调用方法hi<br>classfullpath&#x3D;com.jth.question.Cat<br>method&#x3D;hi</li>
<li>这样的需求在学习框架时特别多，即通过外部文件配置，在不修改源码情况下，来控制程序，也符合设计模式的ocp原则（开闭原则）</li>
<li>代码尝试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    反射问题引入</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionQuestion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//根据配置文件 re.properties 指定信息，创建Cat对象并调用方法hi</span></span><br><span class="line">    <span class="comment">//传统方式</span></span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    cat.hi();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试使用配置文件</span></span><br><span class="line">    <span class="comment">//1、使用Properties类，可以读写配置文件</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/re.properties&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>)+<span class="string">&quot;&quot;</span>;<span class="comment">//转换成字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(classfullpath);</span><br><span class="line">    System.out.println(method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建对象，传统的方法行不通,需要用到反射机制</span></span><br><span class="line">    <span class="comment">//new classfullpath();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jth.question;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;说hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classfullpath=com.jth.question.Cat</span><br><span class="line">method=hi</span><br></pre></td></tr></table></figure>

<ul>
<li>使用反射解决(非常牛逼)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3、使用反射机制解决</span></span><br><span class="line"><span class="comment">//加载类</span></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(classfullpath);</span><br><span class="line"><span class="comment">//通过aClass得到你加载的类 com.jth.Cat的对象实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">System.out.println(o.getClass()); <span class="comment">//Cat类</span></span><br><span class="line"><span class="comment">//3、通过aClass得到你加载的类Cat里面的方法,通过配置文件名字</span></span><br><span class="line"><span class="comment">//即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> aClass.getMethod(method);</span><br><span class="line"><span class="comment">//4、通过method1调用方法，即通过方法对象来实现调用方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">method1.invoke(o);<span class="comment">//传统方法，是对象调用方法，这里反射是方法.invoke(对象)。</span></span><br></pre></td></tr></table></figure>

<mark class="hl-label red">优点</mark> ：

<p>假如Cat类中有两个方法：hi() 和cry</p>
<p>使用传统方法调用cry时候只能修改源码添加代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统方式</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">cat.hi();</span><br><span class="line">cat.cry();</span><br></pre></td></tr></table></figure>

<p>而使用反射机制只需要改配置文件properties即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classfullpath=com.jth.question.Cat</span><br><span class="line">method=cry</span><br></pre></td></tr></table></figure>

<h3 id="反射原理图"><a href="#反射原理图" class="headerlink" title="反射原理图"></a><font color="#5cb85c">反射原理图</font></h3><ul>
<li>Java Reflection</li>
</ul>
<ol>
<li>反射机制允许程序在执行期借助于ReflectionAPI取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</li>
<li>加载完类之后，在堆中就产生一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为：反射。</li>
</ol>
<ul>
<li>Java反射机制原理示意图</li>
</ul>
<p><img src="/images/image-20220822234037124.png" alt="image-20220822234037124"></p>
<p>类加载器是通过<code>loadClass()</code>方法完成类的对象加载。</p>
<mark class="hl-label red">解释</mark> ：

<p>类加载阶段，会映射成<font color="#5cb85c">对象</font>，由于有多个对象和构造器等（一些泛型啊异常都没写）。就会映射成数组用于存放多个。</p>
<h3 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a><font color="#5cb85c">反射相关类</font></h3><ul>
<li>反射可以完成什么事</li>
</ul>
<ol>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时得到任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>生成动态代理</li>
</ol>
<p><img src="/images/image-20220822235555797.png" alt="image-20220822235555797"></p>
<p>这些类在java.lang.reflect 包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1、使用Properties类，可以读写配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>)+<span class="string">&quot;&quot;</span>;<span class="comment">//转换成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(classfullpath);</span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、使用反射机制解决</span></span><br><span class="line">        <span class="comment">//加载类</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//通过aClass得到你加载的类 com.jth.Cat的对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        System.out.println(o.getClass()); <span class="comment">//Cat类</span></span><br><span class="line">        <span class="comment">//3、通过aClass得到你加载的类Cat里面的方法,通过配置文件名字</span></span><br><span class="line">        <span class="comment">//即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> aClass.getMethod(method);</span><br><span class="line">        <span class="comment">//4、通过method1调用方法，即通过方法对象来实现调用方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">        method1.invoke(o);<span class="comment">//传统方法，是对象调用方法，这里反射是方法.invoke(对象)。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示反射Field 代表类的成员变量</span></span><br><span class="line">        <span class="comment">//得到name字段</span></span><br><span class="line">        <span class="comment">//getField不能得到私有的属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(name.get(o));  <span class="comment">//传统方法：对象.成员变量。反射就是成员变量.get(对象)。反过来的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Constructor类方法  代表类的构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = aClass.getConstructors();<span class="comment">//无参构造器，()中可以指定构造器参数类型</span></span><br><span class="line">        System.out.println(Arrays.toString(constructors));</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt;[] constructors1 = aClass.getConstructors(String.class);//这里传入的String.class就是Sting的类(class)对象 //由于JDK不一样这里不能单独调用某个构造函数，他直接给你全部显示出来了。</span></span><br><span class="line">        <span class="comment">//破案了，其实是我这里使用了getConstuctorsAPI是获得全部的构造器，当然里面就不能填参数</span></span><br><span class="line">        <span class="comment">//应使用</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors1 = aClass.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(constructors1));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">解释</mark> ：

<p>String.class可以返回一个代表String类的类对象（官方叫类类型，Class Type，因为Java里面万物皆对象，所以类其实也是一个对象）。类对象，官方给他取名<code>Class</code>所以就叫类对象。反射就是将这个类也变成对象，怎么用慢慢学。</p>
<p>反射调用也是反过来的，比如调用方法，<code>method.invoke(o);</code> ，方法调用对象。</p>
<h3 id="反射调用优化"><a href="#反射调用优化" class="headerlink" title="反射调用优化"></a><font color="#5cb85c">反射调用优化</font></h3><ul>
<li>反射优点和缺点</li>
</ul>
<ol>
<li>优点：可以动态的创建和使用对象(也是框架底层核心)，使用灵活，没有反射机制，框架技术就失去底层支撑。</li>
<li>缺点：使用反射基本是解释执行，对执行速度有影响。</li>
<li>应用实例：Reflection02.java</li>
</ol>
<ul>
<li>反射调用优化-关闭访问检查</li>
</ul>
<ol>
<li>Method和Field、Constructor对象都有setAccessible()方法</li>
<li>setAccessible作用是启动和禁用访问安全检查的开关</li>
<li>参数值为true表示反射的对象在使用时取消访问检查，提高反射效率。参数值为false则表示反射的对象执行访问检查</li>
</ol>
<p><img src="/images/image-20220823224554309.png" alt="image-20220823224554309"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflction02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        m1();<span class="comment">//5ms</span></span><br><span class="line">        m2();<span class="comment">//1196ms</span></span><br><span class="line">        m3();<span class="comment">//1074ms</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统方法调用hi()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            cat.hi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;传统方法调用hi耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射机制调用hi()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.jth.question.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            method.invoke(o);<span class="comment">//Java万物皆对象，将方法变成对象，调用invoke方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方法调用hi耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.jth.question.Cat&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">false</span>); <span class="comment">//此方法在反射调用方法时候，取消访问检查</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">900000000</span>; i++) &#123;</span><br><span class="line">            method.invoke(o);<span class="comment">//Java万物皆对象，将方法变成对象，调用invoke方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;优化反射方法调用hi耗时&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Class类分析"><a href="#Class类分析" class="headerlink" title="Class类分析"></a><font color="#5cb85c">Class类分析</font></h3><ol>
<li>Class也是类，因此也继承Object类</li>
<li>Class类对象不是new出来的，而是系统创建的</li>
<li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成</li>
<li>通过Class可以完整地得到一个类的完整结构，通过一系列API</li>
<li>Class对象是存放在堆的</li>
<li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据(包括方法代码，变量名，方法名，访问权限等等)</li>
</ol>
<mark class="hl-label red">类图</mark> ：

<p><img src="/images/image-20220823231934277.png" alt="image-20220823231934277"></p>
<mark class="hl-label red">系统创建演示</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//Class类图</span></span><br><span class="line">        <span class="comment">//1、Class也是类，因此继承Object类</span></span><br><span class="line">        <span class="comment">//Class</span></span><br><span class="line">        <span class="comment">//2、Class类对象不是new出来的，而是系统创建的</span></span><br><span class="line">        <span class="comment">//传统new对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;// name :com.jth.question.Cat</span></span><br><span class="line"><span class="comment">            return loadClass(name, false);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//反射方式</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.jth.question.Cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是反射方式还是传统的new方式，都会进入loadClass由系统完成创建。</p>
<p>第三点某个类的Class对象只会加载一次，即<code>new Cat()</code>下面反射创建对象的时候系统就不会再创建一次<code>loadClass()</code>。在堆内存里面只会存在一份。具体看原理图。</p>
<ul>
<li>Class类的常用方法</li>
</ul>
<p><img src="/images/image-20220825153546061.png" alt="image-20220825153546061"></p>
<mark class="hl-label red">原理图更新</mark> ：

<p><img src="/images/image-20220825155417333.png" alt="image-20220825155417333"></p>
<h3 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a><font color="#5cb85c">Class类常用方法</font></h3><p>见上表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.jth.Car&quot;</span>; <span class="comment">//类的全路径</span></span><br><span class="line">        <span class="comment">//获取到Car类对应的Class类</span></span><br><span class="line">        <span class="comment">//&lt;?&gt;表示不确定的Java类型</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(classAllPath);</span><br><span class="line">        System.out.println(aClass); <span class="comment">//显示aclass对象，是哪个类的Class对象，class com.jth.Car</span></span><br><span class="line">        System.out.println(aClass.getClass());<span class="comment">//输出运行类型 class java.lang.Class</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        System.out.println(car.getClass());<span class="comment">//运行类型class com.jth.Car</span></span><br><span class="line">        <span class="comment">//得到包名</span></span><br><span class="line">        System.out.println(aClass.getPackage().getName());<span class="comment">//com.jth getName用不用都可以，</span></span><br><span class="line">        <span class="comment">//得到全类名</span></span><br><span class="line">        System.out.println(aClass.getName());<span class="comment">//com.jth.Car</span></span><br><span class="line">        <span class="comment">//生成对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> (Car)o;</span><br><span class="line">        System.out.println(car1);<span class="comment">//调用toString</span></span><br><span class="line">        <span class="comment">//通过反射获取属性</span></span><br><span class="line">        <span class="comment">//name</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;name&quot;</span>);<span class="comment">//Field这里理解为字段</span></span><br><span class="line">        System.out.println(name.get(car1)); <span class="comment">//宝马</span></span><br><span class="line">        <span class="comment">//通过反射给属性设值</span></span><br><span class="line">        name.set(car1, <span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">        System.out.println(name.get(car1)); <span class="comment">//输出奔驰</span></span><br><span class="line">        <span class="comment">//获取所有字段(属性)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========所有字段的属性===========&quot;</span>);</span><br><span class="line">        Field[] fields = aClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field.getName());<span class="comment">//属性字段的各个名称</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取Class对象六种方式"><a href="#获取Class对象六种方式" class="headerlink" title="获取Class对象六种方式"></a><font color="#5cb85c">获取Class对象六种方式</font></h3><ol>
<li>前提：已知一个类的全类名，且该类在路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException,实例：Class cls1 &#x3D; Class.forName(“java.lang.Cat”);<br>应用场景：多用于配置文件，读取类全路径，加载类。<br>全类名：包名和类名都知道。</li>
<li>前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高实例：Class cls2 &#x3D; Cat.class;<br>应用场景：多用于参数传递，比如通过反射得到对应构造器对象。</li>
<li>前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象，实例：Class class &#x3D; 对象.getClass();&#x2F;&#x2F;运行类型<br>应用场景：通过创建好的对象，获取Class对象。<br>这里也应证多态的运行类型看等号右边，<code>new</code>这部分</li>
<li>其他方式<br>ClassLoader cl &#x3D; 对象.getClass().getClassLoader();<br>Class class4 &#x3D; cl.loadClass(“类的全类名”);</li>
<li>基本数据(int, char, boolean, float, double, byte, long, short)按如下方式得到Class类对象<br>Class cls &#x3D; 基本数据类型.class</li>
<li>基本数据类型对应的包装类，可以通过.type得到Class类对象<br>Class cls &#x3D; 包装类.TYPE</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetClass_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1、通过全类名获取Class对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.jth.Car&quot;</span>;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(classAllPath);</span><br><span class="line">        System.out.println(aClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、通过类名.class 获取Class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass3 = Car.class;</span><br><span class="line">        System.out.println(aClass3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、对象.getClass(),应用场景，有对象实例的时候</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Car</span>&gt; aClass1 = car.getClass();</span><br><span class="line">        System.out.println(aClass1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、通过类加载器(有四种)来获取到类的Class对象</span></span><br><span class="line">        <span class="comment">//先得到类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//通过类加载器得到Class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass2 = classLoader.loadClass(classAllPath);</span><br><span class="line">        System.out.println(aClass2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面的Class对象都是同一个对象，因为一个类只能有一个Class对象</span></span><br><span class="line">        System.out.println(aClass2.hashCode());</span><br><span class="line">        System.out.println(aClass.hashCode());</span><br><span class="line">        System.out.println(aClass1.hashCode());</span><br><span class="line">        System.out.println(aClass3.hashCode());<span class="comment">//得出结论hash值都是一样的</span></span><br><span class="line">        <span class="comment">//基本数据的类对象</span></span><br><span class="line">        Class&lt;Integer&gt; integerClass = <span class="type">int</span>.class;</span><br><span class="line">        System.out.println(integerClass);<span class="comment">//int   都有自动拆箱和装箱过程</span></span><br><span class="line">        Class&lt;Character&gt; characterClass = <span class="type">char</span>.class;</span><br><span class="line">        System.out.println(characterClass);<span class="comment">//char</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//基本数据类型的类对象</span></span><br><span class="line">        Class&lt;Integer&gt; integerClass1 = Integer.TYPE;</span><br><span class="line">        System.out.println(integerClass1); <span class="comment">//还是int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出hashcode</span></span><br><span class="line">        System.out.println(integerClass.hashCode());<span class="comment">//两者的hashcode一样</span></span><br><span class="line">        System.out.println(integerClass1.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所以说Integer 和int 在底层数据结构会 自动拆箱和装箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<mark class="hl-label red">原理图更新</mark> ：</p>
<p><img src="/images/image-20220825232936966.png" alt="image-20220825232936966"></p>
<h3 id="哪些类型有Class对象"><a href="#哪些类型有Class对象" class="headerlink" title="哪些类型有Class对象"></a><font color="#5cb85c">哪些类型有Class对象</font></h3><ul>
<li>如下类型有Class对象</li>
</ul>
<ol>
<li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>数组</li>
<li>enum：枚举</li>
<li>annotation：注解</li>
<li>基本数据类型</li>
<li>void</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllTypeClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;String&gt; Class1 = String.class; <span class="comment">//外部类</span></span><br><span class="line">        Class&lt;Serializable&gt; Class2 = Serializable.class; <span class="comment">//接口</span></span><br><span class="line">        Class&lt;Integer[]&gt; Class3 = Integer[].class; <span class="comment">//数组</span></span><br><span class="line">        Class&lt;<span class="type">float</span>[][]&gt; Class4 = <span class="type">float</span>[][].class; <span class="comment">//二维数组</span></span><br><span class="line">        Class&lt;Deprecated&gt; Class5 = Deprecated.class; <span class="comment">//注解</span></span><br><span class="line">        Class&lt;Thread.State&gt; Class6 = Thread.State.class; <span class="comment">//枚举</span></span><br><span class="line">        Class&lt;Long&gt; Class7 = <span class="type">long</span>.class; <span class="comment">//长整形，基本数据类型</span></span><br><span class="line">        Class&lt;Void&gt; Class8 = <span class="keyword">void</span>.class; <span class="comment">//void类型</span></span><br><span class="line">        Class&lt;Class&gt; Class9 = Class.class; <span class="comment">//Class类</span></span><br><span class="line">        System.out.println(Class1);</span><br><span class="line">        System.out.println(Class2);</span><br><span class="line">        System.out.println(Class3);</span><br><span class="line">        System.out.println(Class4);</span><br><span class="line">        System.out.println(Class5);</span><br><span class="line">        System.out.println(Class6);</span><br><span class="line">        System.out.println(Class7);</span><br><span class="line">        System.out.println(Class8);</span><br><span class="line">        System.out.println(Class9);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态和静态加载"><a href="#动态和静态加载" class="headerlink" title="动态和静态加载"></a><font color="#5cb85c">动态和静态加载</font></h3><ul>
<li>基本说明</li>
</ul>
<p>反射机制是Java实现动态语言的关键，也就是通过反射实现类动态加载。</p>
<ol>
<li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强。</li>
<li>动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性</li>
</ol>
<mark class="hl-label red">静态加载</mark> ：

<p>用文本编译器编写这样一段代码。</p>
<p>import java.util.*;<br>public class ClassLoad_ {<br>    public static void main(String[] args) {<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        System.out.println(“请输入Key”);<br>        String key &#x3D; scanner.next();<br>        switch(key) {<br>            case “1” :<br>                Dog dog &#x3D; new Dog();&#x2F;&#x2F;静态加载<br>                dog.cry();<br>                break;<br>            case “2” :<br>                System.out.println(“ok”);<br>                break;<br>            default :<br>                System.out.println(“do nothing”);<br>                break;<br>        }<br>    }<br>}</p>
<p>运行时候</p>
<p><img src="/images/image-20220827191810228.png" alt="image-20220827191810228"></p>
<p>可以看出，我们不一定会使用dog这个类，如果我们输入1以外的数字，但是这里会报错，说明是静态加载的。依赖性太强。</p>
<mark class="hl-label red">动态加载</mark> ：

<p>将代码改成（使用反射）：</p>
<p>import java.util.<em>;<br>import java.lang.reflect.</em>;<br>public class ClassLoad_ {<br>    public static void main(String[] args) throws Exception {<br>        Scanner scanner &#x3D; new Scanner(System.in);<br>        System.out.println(“请输入Key”);<br>        String key &#x3D; scanner.next();<br>        switch(key) {<br>            case “1” :<br>                &#x2F;&#x2F;Dog dog &#x3D; new Dog();<br>                &#x2F;&#x2F;dog.cry();<br>                break;<br>            case “2” :<br>                Class cls &#x3D; Class.forName(“Person”); &#x2F;&#x2F;使用反射加载Person类<br>                Object o &#x3D; cls.newInstance();<br>                Method m &#x3D; cls.getMethod(“hi”);<br>                m.invoke(o);<br>                System.out.println(“ok”);<br>                break;<br>            default :<br>                System.out.println(“do nothing”);<br>                break;<br>        }<br>    }<br>}</p>
<p>编译能够成功：</p>
<p><img src="/images/image-20220827194423016.png" alt="image-20220827194423016"></p>
<p><img src="/images/image-20220827194444835.png" alt="image-20220827194444835"></p>
<p>说明，反射机制是动态加载的，没有加载到时候并不会报错。加载到时候才加载。</p>
<ul>
<li>类加载时机</li>
</ul>
<ol>
<li>当创建对象时(new) &#x2F;&#x2F;静态加载</li>
<li>当子类被加载时 &#x2F;&#x2F;静态加载</li>
<li>调用类中的静态成员时 &#x2F;&#x2F;静态加载</li>
<li>通过反射 &#x2F;&#x2F;动态加载</li>
</ol>
<h3 id="类加载流程图"><a href="#类加载流程图" class="headerlink" title="类加载流程图"></a><font color="#5cb85c">类加载流程图</font></h3><p><img src="/images/image-20220827211524987.png" alt="image-20220827211524987"></p>
<p><img src="/images/image-20220827212227033.png" alt="image-20220827212227033"></p>
<mark class="hl-label red">分析</mark> ：

<p>加载和连接阶段由JVM机决定，初始化可以由代码控制，比如静态代码块等。</p>
<ul>
<li>加载阶段</li>
</ul>
<p>JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件，也可能是jar包，甚至网络)转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p>
<ul>
<li>连接阶段-验证</li>
</ul>
<ol>
<li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li>
<li>包括：文件格式验证（是否以魔数oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</li>
<li>可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。</li>
</ol>
<p>魔数验证：</p>
<p><img src="/images/image-20220829145650965.png" alt="image-20220829145650965"></p>
<ul>
<li>连接阶段-准备</li>
</ul>
<ol>
<li>JVM会在该阶段对静态变量，分配内存并初始化(对应数据类型的默认初始值如0、0L、null、false等)。这些变量所使用的内存都将在方法区中进行分配</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//属性-成员变量-字段</span></span><br><span class="line">    <span class="comment">//老韩分析类加载的链接阶段-准备， 属性是如何处理的</span></span><br><span class="line">    <span class="comment">//1、n1是实例属性，不是静态变量，因此在准备阶段，是不会分配内存的</span></span><br><span class="line">    <span class="comment">//2、n2是静态变量，分配内存n2是默认初始化0，而不是20</span></span><br><span class="line">    <span class="comment">//3、n3是static final是常量，他和静态变量不一样，因为他一旦赋值就不会变了n3 = 30</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>连接阶段-解析</li>
</ul>
<ol>
<li>虚拟机(JVM)将常量池内的符号引用替换为直接引用（内存地址引用）的过程</li>
</ol>
<p><img src="/images/image-20220829153210439.png" alt="image-20220829153210439"></p>
<ul>
<li>Initialization(初始化)</li>
</ul>
<ol>
<li>到初始化阶段，才真正开始执行类中定义的Java程序代码，此阶段是执行clinit()方法的过程。</li>
<li>clinit()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有<font color="#5cb85c">静态变量</font>的赋值动作和静态代码块中的语句，并进行合并。</li>
<li>虚拟机会保证一个类的clinit()方法在多线程环境中被<font color="C02C38">正确地加锁，同步</font>。如果多个 线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待，直到活动线程执行clinit()方法完毕</li>
</ol>
<h3 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a><font color="#5cb85c">通过反射获取类的结构信息</font></h3><p><img src="/images/image-20220829231642343.png" alt="image-20220829231642343"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Test.api_01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一组方法API</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//1、获取Class对象</span></span><br><span class="line">        Class&lt;?&gt; person = Class.forName(<span class="string">&quot;com.jth.ReflectionUtils.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//得到全类名api</span></span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">        <span class="comment">//获取简单类名</span></span><br><span class="line">        System.out.println(person.getSimpleName());</span><br><span class="line">        <span class="comment">//得到所有public修饰的属性，也包括父类</span></span><br><span class="line">        Field[] fields = person.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">            System.out.println(f.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类(没有父类)的所有属性</span></span><br><span class="line">        Field[] declaredFields = person.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            System.out.println(field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类及父类的public方法</span></span><br><span class="line">        Method[] methods = person.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类的所有方法</span></span><br><span class="line">        Method[] declaredMethods = person.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(declaredMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类所有public修饰器</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = person.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取本类所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = person.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类&quot;</span> + declaredConstructor);<span class="comment">//上面使用getName就是只是输出名字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取包package ,返回包</span></span><br><span class="line">        System.out.println(<span class="string">&quot;包&quot;</span> + person.getPackage());</span><br><span class="line">        <span class="comment">//以Class形式返回父类信息</span></span><br><span class="line">        Class&lt;?&gt; superclass = person.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;父类&quot;</span> + superclass);</span><br><span class="line">        <span class="comment">//以Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = person.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接口信息&quot;</span> + anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        Annotation[] annotations = person.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有注解&quot;</span> + annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wuHu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String niuBi;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">w</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">wuHu</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">wuHu</span><span class="params">(String niuBi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.niuBi = niuBi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">wuHu</span> <span class="keyword">implements</span> <span class="title class_">A_</span>, B_&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sel;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A_</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B_</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220829233212094.png" alt="image-20220829233212094"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] declaredFields1 = person.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : declaredFields1) &#123;</span><br><span class="line">    System.out.println(field.getName());<span class="comment">//成员变量名字</span></span><br><span class="line">    System.out.println(field.getModifiers()); <span class="comment">//该属性的修饰符用int表示,</span></span><br><span class="line">    <span class="comment">// 规则上图有。如果某一个成员变量有两个修饰符则返回的int值由这两个修饰符对应的int相加</span></span><br><span class="line">    System.out.println(field.getType()); <span class="comment">//该属性的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Methods对应的方法，用法和上面差不多<br>在getMethods下使用。</li>
</ul>
<p><img src="/images/image-20220829234006270.png" alt="image-20220829234006270"></p>
<ul>
<li>第四组构造器</li>
</ul>
<p><img src="/images/image-20220829234727466.png" alt="image-20220829234727466"></p>
<h3 id="反射暴破创建实例"><a href="#反射暴破创建实例" class="headerlink" title="反射暴破创建实例"></a><font color="#5cb85c">反射暴破创建实例</font></h3><ol>
<li>方式一：调用类中的public修饰的无参构造器</li>
<li>方式二：调用类中的指定构造器</li>
<li>Class类相关方法</li>
</ol>
<p>​	newInstance：调用类中的无参构造器，获取对应类的对象</p>
<p>​	getConstructor(Class…clazz):根据参数列表，获取对应的构造器对象</p>
<p>​	getDecalaredConstructor(Class…clazz):根据参数列表，获取对应的所有构造对象</p>
<ol start="4">
<li>Constructor类相关方法</li>
</ol>
<p>​	setAccessible:爆破</p>
<p>​	newInstance(Object…obj):调用构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1、先获取User类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; UserClass = Class.forName(<span class="string">&quot;com.jth.ReflectCreateInstance.User&quot;</span>);</span><br><span class="line">        <span class="comment">//2、通过public的无参构造器创建实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> UserClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="comment">//3、通过public的有参构造器创建对象</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = UserClass.getConstructor(<span class="type">int</span>.class, String.class); <span class="comment">//获取public构造器</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> constructor.newInstance(<span class="number">88</span>,<span class="string">&quot;hh&quot;</span>);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        <span class="comment">//4、通过非public的有参构造器创建对象</span></span><br><span class="line">        Constructor&lt;?&gt; constructor1 = UserClass.getDeclaredConstructor(<span class="type">int</span>.class);<span class="comment">//获得所有类型的构造器</span></span><br><span class="line">        <span class="comment">//这也是反射的优点，正常情况new对象不能通过private的构造器。</span></span><br><span class="line">        constructor1.setAccessible(<span class="literal">true</span>);<span class="comment">//爆破，使用反射可以访问私有的private的构造器，反射面前都是纸老虎，破坏封装性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">90</span>);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;学习啊你在干什么&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射暴破操作属性"><a href="#反射暴破操作属性" class="headerlink" title="反射暴破操作属性"></a><font color="#5cb85c">反射暴破操作属性</font></h3><ul>
<li>访问属性</li>
</ul>
<ol>
<li>根据属性名获取Field对象<br>Field f &#x3D; clazz对象.getDeclaredField(属性名)；</li>
<li>暴破 ：f.setAccessible(true); &#x2F;&#x2F;f 是Field</li>
<li>访问<br>f.set(o,值)；<br>syso(f.get(o));</li>
<li>如果是静态属性，则set和get中的参数o，可以写成null。因为静态属性是和类相关，和对象无关</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1、创建Class对象</span></span><br><span class="line">        Class&lt;?&gt; Car = Class.forName(<span class="string">&quot;com.jth.Car&quot;</span>);</span><br><span class="line">        <span class="comment">//2、创建一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Car.getConstructor().newInstance(); <span class="comment">//直接newInstance()在jdk8以上已经被弃用</span></span><br><span class="line">        System.out.println(o.getClass()); <span class="comment">//class对象，也是运行类型 .. com.jth.Car</span></span><br><span class="line">        <span class="comment">//3、使用反射得到age属性对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> Car.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(o, <span class="number">999</span>); <span class="comment">//这就相当于将o这个对象的age属性设置成999</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(age.get(o)); <span class="comment">//通过属性得到对象的对应属性  结果是 999</span></span><br><span class="line">        <span class="comment">//4、使用反射操作name属性对象 (private的)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> Car.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//私有的属性操作会报错</span></span><br><span class="line">        <span class="comment">//需要使用暴破</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        name.set(o, <span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        System.out.println(name.get(o));</span><br><span class="line">        <span class="comment">//5、操作静态属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">color</span> <span class="operator">=</span> Car.getField(<span class="string">&quot;color&quot;</span>);</span><br><span class="line">        color.set(<span class="literal">null</span>, <span class="string">&quot;ss&quot;</span>);<span class="comment">//因为他是静态的，属于类的和对象无关，这里就无需填对象了</span></span><br><span class="line">        System.out.println(color.get(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">小结</mark> ：

<p>反射就是Class对象，就是类的一个反射（映射），在JVM机底层是一个个数组，使用Class相关API，可以操作很多东西。可以和对象相互指定，类包含对象。</p>
<h3 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a><font color="#5cb85c">通过反射访问类中的成员</font></h3><ul>
<li>访问方法</li>
</ul>
<ol>
<li>根据方法名和参数列表获取Method方法对象：Method m &#x3D; clazz.getDeclaredMethod(方法名， XX.class); &#x2F;&#x2F;得到</li>
<li>获取对象：Object o &#x3D; clazz.newInstance();</li>
<li>暴破：m.setAccessible(true);</li>
<li>访问：Object returnValue &#x3D; m.invoke(o, 实参列表);</li>
<li>注意：如果是静态方法，则invoke的参数o, 可以写成null!</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1、得到Car类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; Car = Class.forName(<span class="string">&quot;com.jth.Car&quot;</span>);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Car.newInstance();</span><br><span class="line">        <span class="comment">//调用方法public m1</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> Car.getDeclaredMethod(<span class="string">&quot;m1&quot;</span>, String.class);</span><br><span class="line">        m1.invoke(o, <span class="string">&quot;hah&quot;</span>); <span class="comment">//这里可以理解为这个m1方法指向对象o,因为由很多个对象。很好理解。</span></span><br><span class="line">        <span class="comment">//调用private static m2方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> Car.getDeclaredMethod(<span class="string">&quot;m2&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        m2.setAccessible(<span class="literal">true</span>); <span class="comment">//暴破private</span></span><br><span class="line">        m2.invoke(o, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//这里o也可以不写，因为他是static的 静态的。属于类的不用指向某个对象。</span></span><br><span class="line">        m2.invoke(<span class="literal">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//在反射中，如果有返回值，统一返回Object</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">Value</span> <span class="operator">=</span> m2.invoke(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Value.getClass());<span class="comment">//运行类型是 Integer 是和方法定义的返回类型值是一样的</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">大结</mark> ：

<p>这里的<code>invoke</code>方法很能证明，Class对象就是类的一个映射，invoke方法参数需要指向某个对象才行。不然不知道是那个对象调用了这个方法。就如：<code>newInstance</code>多搞几个实例就很体现。</p>
<h3 id="反射练习"><a href="#反射练习" class="headerlink" title="反射练习"></a><font color="#5cb85c">反射练习</font></h3><ul>
<li>练习1：通过反射修改私有成员变量</li>
</ul>
<ol>
<li>定义PrivateTest类，有私有name属性，并且属性值hellokitty</li>
<li>提供getName的公有方法</li>
<li>创建PrivateTest的类，利用Class类得到私有的name属性，修改私有的name属性值，并调用getName()的方法打印name属性值</li>
</ol>
<p><img src="/images/image-20220830202853605.png" alt="image-20220830202853605"></p>
<ul>
<li>练习2利用反射和File完成以下功能</li>
</ul>
<ol>
<li>利用Class类的forName方法得到File类的Class对象</li>
<li>在控制台打印File类的所有构造器</li>
<li>通过newInstance的方法创建File对象，并创建E:&#x2F;myNew.txt文件</li>
</ol>
</String></String>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>equal&amp;hashcode重写</title>
    <url>/2022/10/20/equal-hashcode%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<h1 id="hashcode在哪里使用，hashcode的作用"><a href="#hashcode在哪里使用，hashcode的作用" class="headerlink" title="hashcode在哪里使用，hashcode的作用"></a>hashcode在哪里使用，hashcode的作用</h1><p>Java中hashCode()方法是用来生成hashCode值,hashCode值是JDK根据对象的地址或者<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>或者数字算出来的int类型的数值。这个数值是为了提高集合类的性能</p>
<p>Java 底层的hashMap, hashSet(底层是调用hashMap)类都是实现了哈希表的，之所以采用hash表，因为他能克服链表和二叉树等数据结构在查询上的低效率问题。hash值就是根据hashcode算出来的，把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。即不同hashcode可能转换成相同的hash（散列值）。</p>
<p>那么哈希表是什么，是什么样子的</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是一种数据结构。也可以称之为散列表或者hash表。</p>
<p>哈希表用的是<strong>数组支持按照下标随机访问数据的特性</strong>，所以哈希表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p>
<p><strong>哈希表存储的是由键（key）和值（value）组成的数据。</strong></p>
<p>哈希表有一个hash table可以看作一个数组，每个索引可以看作一个桶子。可以在这个桶子里面装数据，</p>
<h1 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h1><p>hashcode是Java底层根据对象返回一串数字，返回机制是通过算法，然后在通过算法(无符号右移)得到hash。具体可以看Java hashMap集合的底层。</p>
<p>最后还需要通过算法得到索引。但是会有冲突，因为算法是固定的，极大可能出现索引值一样的对象。</p>
<p>但是hashcode是反应对象存在内存上的位置，不会相同，（前提是没有重写hashcode方法）</p>
<p>这种现象被称为哈希冲突，HashMap是通过链表法解决的，在hashtable的每个索引后面生成一个链表</p>
<p><strong>拓展</strong></p>
<p>解决hash冲突还有<strong>开放地址法</strong>或称<strong>开放寻址法</strong>，这种方法是指当冲突发生时，立刻计算出一个候补地址（数组上的位置）并将数据存进去。如果仍然有冲突，便继续计算下一个候补地址，直到有空地址为止，可以通过多次使用<strong>哈希函数</strong>或<strong>线性探测法</strong>等方法计算候补地址。在Java中，ThreadLocal就是用的<strong>开放地址法</strong></p>
<h1 id="equals和hashcode"><a href="#equals和hashcode" class="headerlink" title="equals和hashcode"></a>equals和hashcode</h1><p> 那么equals是什么呢</p>
<p><img src="/images/image-20221023133940731.png" alt="image-20221023133940731"></p>
<p>上图是不添加的情况</p>
<p>因为hashMap是不允许有重复对象的，在进行add方法时候会调用equals方法，Object类的默认equals是比较对象地址，但是我们程序员创建的对象，如果对象内容相同也应该归类为相同对象。这就要重写equals方法。我们也经常用到。</p>
<p>但是如果不重写hashcode方法就会有一个问题，不同的对象hashcode肯定不同，但是equals比较根据我们的需求，不一定要地址不同。所以这会导致equals比较的结果是认为这两个对象是内容相同的，但是hashcode却不是同一个对象。hashMap底层一旦看到hash不同，直接就添加进去了，这就不符合我们预期要去</p>
<p><img src="/images/image-20221023191550142.png" alt="image-20221023191550142"></p>
<p>可以看到底层一旦看到hash值不一样他就添加了。hash是对应hashcode的一个值。</p>
<h2 id="为什么要用equals"><a href="#为什么要用equals" class="headerlink" title="为什么要用equals"></a>为什么要用equals</h2><p>因为hash是hashcode的压缩，即使两个对象地址不同，也有可能出现hash相等的情况。好在hashMap底层还实现了equals。</p>
<p><img src="/images/image-20221023192040057.png" alt="image-20221023192040057"></p>
<p>要求是hash相等并且值为null或者equals原来的。就不添加这个数。</p>
<p>所以hash相等的两个对象不一定相等(还要根据equals)，但是hash不相等的两个对象一定不相等。</p>
<h1 id="为什么要重写hashcode"><a href="#为什么要重写hashcode" class="headerlink" title="为什么要重写hashcode"></a>为什么要重写hashcode</h1><p>hashcode 的作用是为了更快找到对象、提高效率。但是实际使用过程中，我们会有需求让两个不同对象但是内容相同的作为一个对象(即不用存在HashMap里面)。重写hashcode就是为了解决这个需求。让两个对象内容相同返回同一个hashcode值。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个Employee类，要求有两个private属性name，age</span></span><br><span class="line"><span class="comment"> * //添加三个Employee对象到Hashset中</span></span><br><span class="line"><span class="comment"> * 当name和age相同时候，认为是相同员工，不添加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;Object&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Employee_1</span>(<span class="string">&quot;李文涛&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Employee_1</span>(<span class="string">&quot;李文涛&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Employee_1</span>(<span class="string">&quot;李文涛&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Employee_1</span>(<span class="string">&quot;李文涛&quot;</span>, <span class="number">4</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Employee_1</span>(<span class="string">&quot;李文涛&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(hashSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee_1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee_1</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Employee_1</span> <span class="variable">that</span> <span class="operator">=</span> (Employee_1) o;</span><br><span class="line">        <span class="keyword">return</span> age == that.age &amp;&amp; Objects.equals(name, that.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果name和age相同则返回相同的hashcode值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee_1&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须也要重写equals。添加根据hashcode的hash和equals，不重写又比较两者地址去了。</p>
<p>重写hashcode方法里面是防止碰撞算法。</p>
<p><img src="/images/image-20221023193121982.png" alt="image-20221023193121982"></p>
]]></content>
      <categories>
        <category>集合</category>
        <category>底层</category>
      </categories>
      <tags>
        <tag>equals</tag>
        <tag>hashcode</tag>
      </tags>
  </entry>
  <entry>
    <title>String框架--AOP原理</title>
    <url>/2022/10/30/String%E6%A1%86%E6%9E%B6-AOP%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="AOP-简介"><a href="#AOP-简介" class="headerlink" title="AOP 简介"></a>AOP 简介</h1><p>AOP(Aspect Oriented Programming)意为面向切面变成，是OOP(Object Oriented Programming)面向对象编程的”进化版”。面向对象编程在拓展功能时，需要改变源码会影响到原有的功能。而AOP则是横向的在不改变原有功能(源码)的基础上增加新功能。能够对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>AOP底层使用的是动态代理机制。分两种情况1、是由接口。2、没有接口</p>
<p>1、有接口，使用JDK动态代理</p>
<p><img src="/images/image-20221030203439949.png" alt="image-20221030203439949"></p>
<p>2、没有接口，使用CGLB动态代理</p>
<p><img src="/images/image-20221030203901539.png" alt="image-20221030203901539"></p>
<p>具体JDK动态代理实现看笔记，动态代理在reflect包下。当然也使用了反射机制。</p>
<h2 id="那么使用动态代理的好处是什么？"><a href="#那么使用动态代理的好处是什么？" class="headerlink" title="那么使用动态代理的好处是什么？"></a>那么使用动态代理的好处是什么？</h2><p>代理故名思意，让代理对象完成对业务逻辑完成。我们在要增强业务逻辑的时候只需要改变增强代理对象的业务逻辑。实现了开闭原则(OCP) Open Close Principle，对扩展是开放的，对修改是关闭的。降低耦合度。</p>
<h2 id="动态代理和静态代理"><a href="#动态代理和静态代理" class="headerlink" title="动态代理和静态代理"></a>动态代理和静态代理</h2><p>所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 字节码不就是.class文件。在Java里面一提到动态，就是反射机制了。动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。 好处也显然易见，相较静态代理动态代理降低代码之间耦合度的能力更强。</p>
<h1 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h1><p>1、连接点</p>
<p>类里面哪些方法可以被增强，这些方法被称为连接点。</p>
<p>2、切入点</p>
<p>实际被真正增强的方法，称为切入点。有切入点表达式指定</p>
<p>3、通知</p>
<p>1）实际增强的逻辑部分称为通知(增强);</p>
<p>2）通知的多种类型</p>
<p>​	前置通知</p>
<p>​	后置通知</p>
<p>​	环绕通知</p>
<p>​	异常通知</p>
<p>​	最终通知</p>
<p>4、切面</p>
<p>把通知应用到切入点过程</p>
<p>其余XML配置文件，注解开发具体看笔记。</p>
]]></content>
      <categories>
        <category>课程小结</category>
        <category>面向切面编程</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>final关键字与引用类型</title>
    <url>/2022/10/19/final%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">final_</span> <span class="operator">=</span> stringBuilder;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        System.out.println(final_); <span class="comment">//输出testhaha</span></span><br><span class="line">        <span class="comment">//final修饰数组，但是数组是引用的，数据存在堆中，栈有一个引用指向他</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> [] ints = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//final修饰引用类型。只是引用不可变</span></span><br><span class="line">        <span class="type">int</span> [] ints1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//ints = ints1; //报错</span></span><br><span class="line">        <span class="comment">//但是可以更改被引用的数据</span></span><br><span class="line">        ints[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">        System.out.println(Arrays.toString(ints)); <span class="comment">//输出1，2，10</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出final修饰的引用类型对象，还是会被改变。</p>
<p>底层是如果final修饰的是引用类型的引用，那么只能保证在对其初始化之后便不能再让其指向另一个对象。</p>
<p>那为什么数组也是可以这样的呢，因为<font color="red">数组</font>也是引用方式来存的，堆中放数据，栈中是对象的引用。</p>
<h1 id="基本类型与包装类"><a href="#基本类型与包装类" class="headerlink" title="基本类型与包装类"></a>基本类型与包装类</h1><p>那么包装类是否也符合这个原则呢！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//各种包装类和String类都是final修饰的</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">45</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">45</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> integer2;</span><br><span class="line"><span class="comment">//integer1 = integer;  //报错因为是final修饰指向的对象不能更改</span></span><br><span class="line">integer2 = <span class="number">12</span>;</span><br><span class="line">System.out.println(integer1); <span class="comment">//还是45因为他是基本数据类型，数据传输和基本类型一样</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a2</span> <span class="operator">=</span> a1;</span><br><span class="line">a1 = <span class="number">11</span>;</span><br><span class="line">System.out.println(a2);<span class="comment">//输出10</span></span><br></pre></td></tr></table></figure>

<p>可以看出不符合</p>
<p>那是为什么呢，这就涉及数据传递的方法了</p>
<p>总所周知，传递方式有<font color="86749232123">值传递和引用传递</font>两种。一般在赋值和调用方法时用到</p>
<p>这里<code>int a2 = a1</code>就是传递。</p>
<p>值传递(pass by value)：在调用函数时，将实际参数复制一份传递到函数中，这样在函数中对参数进行修改，就不会影响到原来的实际参数；</p>
<p>引用传递(pass by reference):在调用函数时，将实际参数的地址直接传递到函数中。这样在函数中对参数进行的修改，就会影响到实际参数；</p>
<p><a href="https://zhuanlan.zhihu.com/p/102048219">https://zhuanlan.zhihu.com/p/102048219</a></p>
<p>基本数据类型传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改前的num值:&quot;</span>+num);</span><br><span class="line">        changeValue(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的num值:&quot;</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        num = <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;形参num值:&quot;</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改前的num值:<span class="number">3</span></span><br><span class="line">形参num值:<span class="number">5</span></span><br><span class="line">修改后的num值:<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20221019145637812.png" alt="image-20221019145637812"></p>
<p>传递引用对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">18</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改对象前:&quot;</span>+user);</span><br><span class="line">        changeUser(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改对象后:&quot;</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修改对象前:User&#123;age=<span class="number">18</span>, name=<span class="string">&#x27;zhangsan&#x27;</span>&#125;</span><br><span class="line">修改对象后:User&#123;age=<span class="number">20</span>, name=<span class="string">&#x27;lisi&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20221019145715524.png" alt="image-20221019145715524"></p>
<p>传递包装类和String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串修改前:&quot;</span>+str);</span><br><span class="line">        changeStr(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串修改后:&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeStr</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">字符串修改前:zhangsan</span><br><span class="line">字符串修改后:zhangsan</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20221019145905634.png" alt="image-20221019145905634"></p>
<p>在传递的时候都会创建一个副本.</p>
<p>具体看文章内容</p>
<p><strong>总结：</strong></p>
<p>从以上三个例子中，我们就能理解了，为什么Java中只有值传递，并没有引用传递。值传递，不论传递的参数类型是值类型还是引用类型，都会在调用栈上创建一个形参的副本。不同的是，对于值类型来说，复制的就是整个原始值的复制。而对于引用类型来说，由于在调用栈中只存储对象的引用，因此复制的只是这个引用，而不是原始对象。</p>
<p>最后，再次强调一下，传递参数是引用类型，或者说是对象时，并不代表它就是引用传递。引用传递不是用来形容参数的类型的，不要被“引用”这个词本身迷惑了。这就如同我们生活中说的地瓜不是瓜，而是红薯一样。</p>
<ol>
<li>参数传递时，是拷贝实参的副本，然后传递给形参。（值传递）</li>
<li>在函数中，只有修改了<strong>实参</strong>所指向的对象内容，才会影响到实参。以上第三种情况修改的实际上只是形参所指向的对象，因此不会影响实参。</li>
</ol>
<p>所以我们可以把包装类和基本数据类型和String分为一类，是一值的形式传递</p>
<p>其他可以说是<code>引用传递</code>.</p>
<p>也可以说改不改这个对象， 就是看有没有在同一个对象里面操作了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;23&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s;</span><br><span class="line">s = s + <span class="string">&quot;2&quot;</span>;</span><br><span class="line">System.out.println(s1);<span class="comment">//23</span></span><br><span class="line">s1 = s;</span><br><span class="line">System.out.println(s1);<span class="comment">//232</span></span><br></pre></td></tr></table></figure>

<p>所以String、包装类和基本数据类型都是直接传值。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用方法包括themes</title>
    <url>/2022/04/20/hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8C%85%E6%8B%ACthemes/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span>     //创建新的文章</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server          //本地服务器</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate          //搭建</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy            //部署生成 发布到GitHub</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="hexo-文章可配置属性"><a href="#hexo-文章可配置属性" class="headerlink" title="hexo 文章可配置属性"></a>hexo 文章可配置属性</h3><p><img src="/images/hexo%E6%96%87%E7%AB%A0%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7.png" alt="hexo文章可配置属性"></p>
<h2 id="butterfly-主题配置"><a href="#butterfly-主题配置" class="headerlink" title="butterfly 主题配置"></a>butterfly 主题配置</h2><h3 id="Page页面可配置属性"><a href="#Page页面可配置属性" class="headerlink" title="Page页面可配置属性"></a>Page页面可配置属性</h3><p><img src="/images/%E6%96%87%E7%AB%A0%E5%8F%AF%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7.png" alt="文章可配置属性"></p>
<h3 id="Post文章可配置属性"><a href="#Post文章可配置属性" class="headerlink" title="Post文章可配置属性"></a>Post文章可配置属性</h3><p><img src="/images/post%E9%85%8D%E7%BD%AE1.png" alt="Post1"> <img src="/images/post%E9%85%8D%E7%BD%AE2.png" alt="Post2"></p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>代码执行顺序--静态代码块、构造方法等及子父类相关问题</title>
    <url>/2022/07/30/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%AD%89%E5%8F%8A%E5%AD%90%E7%88%B6%E7%B1%BB%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a><font color="2474B5">问题引出</font></h1><p>在做题时遇到静态代码块和其他数据加载先后顺序问题，平时写程序没有遇到。所以在这总结一下。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><font color="2474B5">结论</font></h1><blockquote>
<p>执行顺序为</p>
<p>​	父类静态代码块、父类静态变量 ps：按照声明顺序执行（即先后顺序）</p>
<p>​	子类静态代码块、静态变量 ps：按声明顺序执行</p>
<p>​	父类局部代码块、成员变量ps：按声明顺序执行</p>
<p>​	父类构造器函数</p>
<p>​	子类局部代码块、成员变量ps：按声明顺序执行</p>
<p>​	子类构造函数</p>
</blockquote>
<h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a><font color="2474B5">代码测试</font></h1><ol>
<li>静态代码块和静态变量</li>
</ol>
<p><img src="/images/image-20220730144317566.png" alt="image-20220730144317566"></p>
<p><img src="/images/image-20220730144333226.png" alt="image-20220730144333226"></p>
<p>可以看出来，当静态变量在静态代码块上面的时候编译不会报错，反之会报错。说明两者并没有先后关系。而是并列关系。</p>
<ol start="2">
<li>成员变量和局部代码块 与 静态代码块</li>
</ol>
<p><img src="/images/image-20220730145114251.png" alt="image-20220730145114251"></p>
<p>可以看出即使普通成员变量声明顺序在静态代码块的前面还是无法引用，说明静态代码块的优先级高于普通成员变量。</p>
<ol start="3">
<li>整体来看</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="string">&quot;子类静态变量&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sss</span> <span class="operator">=</span> <span class="string">&quot;子类正常变量&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticTest</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类局部代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块&quot;</span>);</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类main方法&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticTest</span>();<span class="comment">//生成new子类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;父类静态变量&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span> <span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类局部代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="string">&quot;父类成员变量&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;父类静态代码块中的成员变量&quot;</span>;</span><br><span class="line">        <span class="comment">//System.out.println(ss);无法调用普通成员变量，因为静态代码块优先级高于它</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="/images/image-20220730145837459.png" alt="image-20220730145837459"></p>
<mark class="hl-label purple">总结</mark> ：

<p>与先前的结论一直。还需注意的是new一个子类对象的时候，会先调用父类的构造器然后再调用子类构造器。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>json、xml、Ajax简单理解</title>
    <url>/2022/11/30/json%E3%80%81xml%E3%80%81Ajax%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="JSON和XML"><a href="#JSON和XML" class="headerlink" title="JSON和XML"></a>JSON和XML</h1><p>JSON是Javascript的一种数据格式，全称JSON（ JavaScript Object Notation, JS对象简谱）是一种轻量级的数据交换格式。XML也是一种数据交互格式。XML (<strong>Extensible Markup Language</strong>) 是一种类似于 HTML 的标记语言，但是 XML 没有使用预定义的标记。XML较多用于配置文件，JSON较多用户数据交互格式。</p>
<p>因为JSON数据量少，简单。</p>
<p><img src="/images/image-20221130105628681.png" alt="image-20221130105628681"></p>
<h1 id="两者解析能力"><a href="#两者解析能力" class="headerlink" title="两者解析能力"></a>两者解析能力</h1><p>XML解析使用dom4j、xpath。dom就是一个文档，和html很像，使用文档解析。解析的时候将整个XML文件当作document，先读根标签。根标签就是类似于HTML中的HTML标签，是最外层的标签。然后获取子标签，一层一层的解析。</p>
<p>JSON两种格式：1、一种对象。2、一种数组。获取方式：对象： 使用对象.键获取值。数组for循环获取。</p>
<p>对象是放在{}中以键值对的形式存储，而数组是[]存储的是一个一个数据。</p>
<p>Java实体类和map转换成json对象就是JSON对象，list之类的就是JSON数组</p>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>Ajax 的全称是asynchronous javascript and xml</p>
<p>Ajax是一种用于创建快速动态网页的技术，使用JavaScript操作异步对象XMLHttpRequest，和服务器交换使用json数据格式。通过在后台与服务器进行少量数据交换，前后端数据交互。</p>
<p>简单来说：可以在页面不刷新就实现和服务器数据交互。</p>
]]></content>
      <categories>
        <category>数据交互格式</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>坦克大战</title>
    <url>/2022/06/07/%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Java绘图坐标体系"><a href="#Java绘图坐标体系" class="headerlink" title="Java绘图坐标体系"></a><font color="#1661AB">Java绘图坐标体系</font></h1><h2 id="坐标体系-介绍"><a href="#坐标体系-介绍" class="headerlink" title="坐标体系-介绍"></a><font color="61649f">坐标体系-介绍</font></h2><p>下图说明了Java坐标系。坐标原点位于左上角，以像素为单位。在Java坐标系中，第一个是x坐标，表示当前位置为水平方向，距离坐标原点x个像素；第二个是y坐标，表示当前位置为垂直方向，距离坐标原点y个像素。</p>
<p><img src="/images/image-20220607210358864.png" alt="image-20220607210358864"></p>
<h2 id="坐标体系-像素"><a href="#坐标体系-像素" class="headerlink" title="坐标体系-像素"></a><font color="61649f">坐标体系-像素</font></h2><p>像素是一个密度单位，而厘米是长度单位，两者无法比较。</p>
<h1 id="绘图入门和机制"><a href="#绘图入门和机制" class="headerlink" title="绘图入门和机制"></a><font color="#1661AB">绘图入门和机制</font></h1><h2 id="绘图原理"><a href="#绘图原理" class="headerlink" title="绘图原理"></a><font color="61649f">绘图原理</font></h2><ul>
<li><p>Component类提供了两个和绘图相关最重要的方法：</p>
<ol>
<li>paint(Graphics g)绘制组件的外观</li>
<li>repaint()刷新组件的外观</li>
</ol>
</li>
<li><p>当组件第一次在屏幕显示的时候，程序会自动的调用paint()方法来绘制组件。</p>
</li>
<li><p>在以下情况paint()将会被调用：</p>
<ol>
<li>窗口最小化，再最大化</li>
<li>窗口的大小发生变化</li>
<li>repaint函数被调用</li>
</ol>
</li>
</ul>
<mark class="hl-label red">案例</mark> ：<font color="681752">使用paint(Graphics g)在画板上画一个圆。</font>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawCircle</span>  <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123; <span class="comment">//JFrame对应窗口</span></span><br><span class="line">    <span class="comment">//定义一个面板</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyPanl</span> <span class="variable">mp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawCircle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawCircle</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="comment">//初始化面板。这样子分开写，在调用mp参数的时候可以多次调用</span></span><br><span class="line">        mp = <span class="keyword">new</span> <span class="title class_">MyPanl</span>();</span><br><span class="line">        <span class="comment">//下面的this可以不用写，写了更符合方法调用规则。对象.方法</span></span><br><span class="line">        <span class="built_in">this</span>.add(mp);<span class="comment">//把面板放入到窗口(画框)</span></span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">400</span>,<span class="number">300</span>);<span class="comment">//设置画框的大小</span></span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<span class="comment">//当点击窗口X（关闭）这个程序就完全退出</span></span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);<span class="comment">//让他可以显示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、先定义一个MyPanl，继承JPanl类，画图形，在面板上。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPanl</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> &#123;</span><br><span class="line">    <span class="comment">//1、MyPanel 对象就是一个画板</span></span><br><span class="line">    <span class="comment">//2、Graphics g可把g理解成画笔</span></span><br><span class="line">    <span class="comment">//3、Graphisc g提供了很多绘图的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;<span class="comment">//绘图方法</span></span><br><span class="line">        <span class="built_in">super</span>.paint(g); <span class="comment">//调用父类的方法完成初始化。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;paint方法被调用&quot;</span>);<span class="comment">//这里标记paint方法什么情况下被调用</span></span><br><span class="line">        g.drawOval(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//画出一个圆形。相关规则看API和下面的绘图方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">小结</mark> : 当窗口大小改变和最小化最大化时，会重新调用paint方法。通过倒数第二行代码直观展现

<h2 id="绘图方法"><a href="#绘图方法" class="headerlink" title="绘图方法"></a><font color="61649f">绘图方法</font></h2><ul>
<li><font color="681752">Graphics类</font></li>
</ul>
<p>​		Graphics类你可以理解就是画笔，为我们提供了各种绘制图形的方法:[参考jdk帮助文档]</p>
<p><img src="/images/image-20220628113530484.png" alt="image-20220628113530484"></p>
<mark class="hl-label orange">注意</mark> :

<ul>
<li><p>绘画图片的时候先要获取图片(不同JDk版本对绝对路径引用不同、这里是JDK17.MyPanl是<font color="61649f">绘图原理</font>中创建的类)。图片放在对应包下的<font color="681752">out</font>目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Image imag e=Toolkit.getDefaultToolkit().getImage(MyPanl.class.getResource(<span class="string">&quot;/bl1.gif&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置字体的颜色的时候用的是和设置绘画颜色一样的方法。Font是一个对象需要new一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">g.setColor(Color.BLUE);  <span class="comment">//这个也能用于设置字体的颜色</span></span><br><span class="line">g.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;楷书&quot;</span>,Font.BOLD,<span class="number">50</span>));<span class="comment">//设置字体(字体，粗体，大小)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="绘制坦克游戏区域"><a href="#绘制坦克游戏区域" class="headerlink" title="绘制坦克游戏区域"></a><font color="61649f">绘制坦克游戏区域</font></h2><p>通过自己写的类继承JPanel类，并通过重写paint方法，调用其中的fillRect()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.paint(g);</span><br><span class="line">    g.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1920</span>,<span class="number">1080</span>);<span class="comment">//游戏(画布大小)区域。填充矩形，默认黑色</span></span><br></pre></td></tr></table></figure>

<p>其中，fillRect()方法就是前面填充颜色方法，传入起始点和宽和高确定范围。并且他在最前面被调用，最先绘画，所以后面坦克就会呈现在它上面。</p>
<h2 id="绘制坦克"><a href="#绘制坦克" class="headerlink" title="绘制坦克"></a><font color="61649f">绘制坦克</font></h2><p>主要是根据Java：JPanel提供的方法规则来绘画。</p>
<mark class="hl-label orange">例子</mark> : 炮筒朝上的坦克。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">g.fill3DRect(x, y, <span class="number">10</span>, <span class="number">60</span>, <span class="literal">false</span>);<span class="comment">//左边的轮子 绘制一个填充有当前颜色的3D高亮矩形。矩形的边缘将被突出示，使其看起来好像边缘是从左上角倾斜并点亮。用于突出显示效果的颜色将根据当前颜色确定。</span></span><br><span class="line">g.fill3DRect(x+<span class="number">30</span>,y,<span class="number">10</span>,<span class="number">60</span>,<span class="literal">false</span>);<span class="comment">//右边的轮子</span></span><br><span class="line">g.fill3DRect(x+<span class="number">10</span>,y+<span class="number">10</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="literal">false</span>);<span class="comment">//坦克的盖子</span></span><br><span class="line">g.drawOval(x+<span class="number">10</span>,y+<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>);<span class="comment">//坦克小圆盖</span></span><br><span class="line">g.drawLine(x+<span class="number">20</span>,y+<span class="number">30</span>,x+<span class="number">20</span>,y);<span class="comment">//画出炮筒</span></span><br></pre></td></tr></table></figure>

<h1 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a><font color="#1661AB">事件处理机制</font></h1><h2 id="案例小球移动"><a href="#案例小球移动" class="headerlink" title="案例小球移动"></a><font color="61649f">案例小球移动</font></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> <span class="keyword">implements</span> <span class="title class_">KeyListener</span>&#123;</span><br><span class="line">    <span class="comment">//为了让小球可以移动，把他左上角的坐标设置成变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.paint(g);</span><br><span class="line">        g.fillOval(x,y,<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//键盘有字符输入，该方法就会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当某个键按下，该方法会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyPressed</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;按下&quot;+(char)(e.getKeyCode()));</span></span><br><span class="line">        <span class="comment">//根据用户按下的不同键，来处理小球的移动(上下左右键)</span></span><br><span class="line">        <span class="comment">//Java会给每个键分配一个键值(int)</span></span><br><span class="line">        <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_S) &#123;<span class="comment">//KeyEvent.VK_DOWN就是向下的箭头对应的code</span></span><br><span class="line">            y++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_W) &#123;</span><br><span class="line">            y--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_A) &#123;</span><br><span class="line">            x--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_D) &#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//面版重绘 repaint()方法调用</span></span><br><span class="line">        <span class="built_in">this</span>.repaint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当某个键松开，该方法会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyReleased</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label orange">解释</mark> ：

<p>由MyPanel类继承实现KeyListener接口，可以监听和读取键盘输入的键值。Java具体实现方法<font color="7E2065">有三种</font>。<code>keyTyped(KeyEvent e)</code> :键盘有字符输入，该方法启用。并传入参数KeyEvent</p>
<p><code>keyPressed(KeyEvent e)</code> :键盘有键按下，该方法启用。并传入参数KeyEvent</p>
<p><code>keyReleased(KeyEvent e)</code>:键盘有键释放，该方法启用。并传入参数KeyEvent</p>
<p>在完成上下左右移动后，还需要重新绘画，在前面<font color="61649f">绘图原理</font>中有说到，调用<code>repaint()</code>方法。能重新调用paint函数。</p>
<p>最后还需要在JFrame(窗口中)实现，这样就能在窗口中实现小球移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ballmove</span><span class="params">()</span> &#123;</span><br><span class="line">    mp = <span class="keyword">new</span> <span class="title class_">MyPanel</span>();</span><br><span class="line">    <span class="built_in">this</span>.add(mp);</span><br><span class="line">    <span class="built_in">this</span>.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">    <span class="comment">//窗口JFrame 对象可以监听键盘事件，即可以监听到面板发生的键盘事件</span></span><br><span class="line">    <span class="built_in">this</span>.addKeyListener(mp); <span class="comment">//多态机制</span></span><br><span class="line">    <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ballmove是一个继承JFrame的一个窗口类。在构造器中添加<code>this.addKeyListener(mp)</code>就实现在窗口中添加监听器。因为mp是一个M有Panel对象，上面代码中已经说到它继承了接口KeyListener。所以这也是<font color="EE4866">多态的写法</font>。</p>
<h2 id="Java事件处理机制"><a href="#Java事件处理机制" class="headerlink" title="Java事件处理机制"></a><font color="61649f">Java事件处理机制</font></h2><ul>
<li><p><font color="61649F">基本说明</font></p>
<blockquote>
<p>java事件处理是采取”委派事件模型”。当事件发生时,产生事件的对象,会把此”信息”传递给”事件的监听者”处理，这里所说的”信息”实际上就是 java.awt.event事件类库里某个类所创建的对象,把它称为”事件的对象”。</p>
</blockquote>
</li>
</ul>
<mark class="hl-label orange">示意图</mark> ：

<p><img src="/images/image-20220630135406271.png" alt="image-20220630135406271"></p>
<ul>
<li><p><font color="61649F">事件处理机制深入理解</font></p>
<ol>
<li><p><font color="0F59A4">事件源</font>：事件源是一个产生事件的对象，比如按钮，窗口等。</p>
</li>
<li><p><font color="0F59A4">事件</font>：事件就是承载事件源状态改变时的对象，比如当键盘事件、鼠标事件、窗口事件等等，会生成一个事件对象，该对象保存着当前事件很多信息，比如KeyEvent对象有含有被按下键的Code值。java.awt.event包和javax.swing.event包中定义了各种事件类型。</p>
</li>
<li><p><font color="0F59A4">事件类型</font>：查阅jdk文档</p>
<p><img src="/images/image-20220630142036233.png" alt="image-20220630142036233"></p>
</li>
<li><p><font color="0F59A4">事件监听器接口</font>：</p>
<ul>
<li>当事件源产生一个事件，可以传送给事件监听者处理</li>
<li>事件监听者实际上就是一个类，该类实现了某个事件监听器接口比如我们勤前面案例中MyPanel就是一个类，它实现了KeyListener接口，它就可以作为一个事件监听者，对接收到的事件进行处理</li>
<li>事件监听器接口有多种，不同的事件监听器接口可以监听不同的事件，一个类可以实现多个监听接口</li>
<li>这些接口在java.awt.event包和javax.swing.event包中定义。列出常用的事件监听接口，查看jdk文档</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="绘制坦克上下左右"><a href="#绘制坦克上下左右" class="headerlink" title="绘制坦克上下左右"></a><font color="61649f">绘制坦克上下左右</font></h2><p>这里和上面绘制坦克差不多，需要改方向即可。由于坦克是左右对称的上下只需改炮筒位置，左右也只需改炮筒位置即可</p>
<mark class="hl-label orange">例子</mark> ：炮筒向右的坦克

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">g.fill3DRect(x,y,<span class="number">60</span>,<span class="number">10</span>,<span class="literal">false</span>);</span><br><span class="line">g.fill3DRect(x,y+<span class="number">30</span>,<span class="number">60</span>,<span class="number">10</span>,<span class="literal">false</span>);</span><br><span class="line">g.fill3DRect(x+<span class="number">10</span>,y+<span class="number">10</span>,<span class="number">40</span>,<span class="number">20</span>,<span class="literal">false</span>);</span><br><span class="line">g.drawOval(x+<span class="number">20</span>,y+<span class="number">10</span>,<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">g.drawLine(x+<span class="number">30</span>,y+<span class="number">20</span>,x+<span class="number">60</span>,y+<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h2 id="坦克动起来"><a href="#坦克动起来" class="headerlink" title="坦克动起来"></a><font color="61649f">坦克动起来</font></h2><p>需要一个很重要的<font color="0F59A4">监听器</font><font color="FF9900">KeyListener</font>。在上面<font color="#1661AB">事件处理机制</font>有仔细讲，涉及接口继承和多态写法。这里与上面有区别的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span> &#123; ...</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">speed</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//控制坦克移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveUp</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//向上移动</span></span><br><span class="line">        y -= speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加了速度机制，并且将移动封装到Tank类中。是因为坦克坐标X，Y已经被封装。调取需要<code>set</code>和<code>get</code>。索性增加<font color="0F59A4">move()方法</font>并且增加速度变量与其结合。后面需要改参数，会设置更多<font color="0F59A4">变量</font></p>
<h1 id="本章作业"><a href="#本章作业" class="headerlink" title="本章作业"></a><font color="#1661AB">本章作业</font></h1><mark class="hl-label orange">目的</mark> ：

<p>在TankGame02的基础上画出三辆敌人的坦克，注意颜色。</p>
<mark class="hl-label purple">分析</mark> ：

<ol>
<li>因为敌人的坦克，是在MyPanel上，所以我们的代码在MyPanel</li>
<li>因为敌人的坦克，后面有自己特殊的属性和方法，可以单开一个<font color="EE3D4D">EnemyTank类</font></li>
<li>敌人坦克数量多，可以放入到<font color="EE3D4D">集合Vector</font>，因为考虑多线程问题</li>
</ol>
<p>代码见：idea的Tankbattle包。</p>
<h1 id="子弹发射"><a href="#子弹发射" class="headerlink" title="子弹发射"></a><font color="#1661AB">子弹发射</font></h1><p>子弹发射需要用到多线程知识：多线程收入到文章<font color="#1661AB">JAVA</font>中。</p>
<h2 id="我方子弹发射"><a href="#我方子弹发射" class="headerlink" title="我方子弹发射"></a><font color="61649f">我方子弹发射</font></h2><mark class="hl-label purple">思路</mark> ：

<blockquote>
<ol>
<li>当发射一颗子弹后，就相当于启动一个线程。</li>
<li>Hero有子弹的对象，当按下J时，我们就启动一个发射行为(线程)，让子弹不停的移动，形成一个设计的效果</li>
<li>我们MyPanel需要不停的重绘子弹，才能出现该效果。</li>
<li>当子弹移动到面板的边界时，就应该销毁(把启动的子弹的线程销毁)。</li>
</ol>
</blockquote>
<mark class="hl-label red">代码</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bullet</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">speed</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> direction;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLive</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bullet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDirection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDirection</span><span class="params">(<span class="type">int</span> direction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//在多线程中实现发射功能</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//子弹向上</span></span><br><span class="line">                    y -= speed;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//子弹向右</span></span><br><span class="line">                    x += speed;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//子弹向下</span></span><br><span class="line">                    y += speed;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//子弹向左</span></span><br><span class="line">                    x -= speed;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>); <span class="comment">//每次都休眠50ms</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;x坐标&quot;</span>+x+<span class="string">&quot;y坐标&quot;</span>+y);</span><br><span class="line">            <span class="keyword">if</span> (x &lt;=<span class="number">0</span> || x &gt;= <span class="number">1920</span> || y &lt;= <span class="number">0</span> || y &gt;= <span class="number">1080</span>) &#123;</span><br><span class="line">                isLive = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程退出&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">分析</mark> ：

<p>由于子弹有自己的生命周期，会消亡，并且与坦克移动<font color="D2568C">互不干扰</font>，所以需要开另外一个线程。</p>
<p>依据面向对象的思想，子弹是由坦克发射出来的，那么实现的方法要在类<code>hero</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">extends</span> <span class="title class_">Tank</span> &#123;</span><br><span class="line">    <span class="comment">//在hero坦克类中使用发射子弹 , 表示一个射击行为(线程)</span></span><br><span class="line">    <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y, direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hero</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shot</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Bullet；根据当前tank的方向</span></span><br><span class="line">        <span class="keyword">switch</span> (getDirection()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//当前tank方向为上</span></span><br><span class="line">                <span class="comment">//用创建对象的方式,所以用选用构造器传参更好，无需多个set</span></span><br><span class="line">                bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX()+<span class="number">20</span>,getY(),<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX()+<span class="number">60</span>,getY()+<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX()+<span class="number">20</span>,getY()+<span class="number">60</span>,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX(),getY()+<span class="number">20</span>,<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有东西初始化好就可以启动了</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span> (bullet).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是JPanel类中KeyListener中的判断</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode() == KeyEvent.VK_J) &#123;</span><br><span class="line">            hero.shot(); <span class="comment">//启动shot方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">分析</mark> ：

<p> 并且，这里是用创建对象的方式来传入参数，所以<code>Bullet</code>类中创建对应的<font color="D2568C">构造函数</font>即可。不用<code>get</code>和<code>set</code>方法。至于为什么写了<code>get</code>、<code>set</code>是因为后面绘画的时候需要调用，已经处理好的<code>private</code>X、Y坐标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> <span class="keyword">implements</span> <span class="title class_">KeyListener</span>, Runnable &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hero.bullet != <span class="literal">null</span> &amp;&amp; hero.bullet.isLive) &#123;</span><br><span class="line">        g.draw3DRect(hero.bullet.getX(), hero.bullet.getY(),<span class="number">2</span>,<span class="number">2</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.repaint(); <span class="comment">//每间隔50毫秒重写绘制</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">分析</mark> ：

<p>这步就是绘制子弹，由于需要子弹每走一步就需要重绘，所以需要每隔几毫秒的循环重画，但是又不能干扰坦克的绘画，比如在绘画坦克的方法中加while循环，子弹超出画面后跳出，但是会导致整个<font color="D2568C">线程阻塞</font>。所需要再开一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HspTankGame02</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HspTankGame02</span><span class="params">()</span>&#123;</span><br><span class="line">        mp = <span class="keyword">new</span> <span class="title class_">MyPanel</span>();</span><br><span class="line">        <span class="built_in">this</span>.add(mp); <span class="comment">// 把面板添加到窗口</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(mp).start(); <span class="comment">//启动不停绘制线程0</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">分析</mark> ：

<p>JPanel的线程启动，在他对应初始化的地方<code>start()</code>即可。</p>
<mark class="hl-label red">小结</mark> ：

<p>构造可以起到和<code>set</code>相同的作用，在需要<font color="D2568C">创建对象</font>的场景下，选用构造器更好。但是一次只能发射一颗子弹。</p>
<h2 id="敌方子弹发射"><a href="#敌方子弹发射" class="headerlink" title="敌方子弹发射"></a><font color="61649f">敌方子弹发射</font></h2><ul>
<li>增加功能</li>
</ul>
<ol>
<li>让敌人的坦克也能够发射子弹(<font color="#ED5A65">可以拥有多颗子弹</font>){使用Vector集合}</li>
<li>当我方坦克击中敌人坦克时，敌人的坦克就消失，如果能做出爆炸效果更好。</li>
<li>让敌人的坦克也可以自由随机的上下左右移动</li>
<li>控制我方坦克和敌人的坦克在规定的范围移动</li>
</ol>
 <mark class="hl-label blue">解析</mark> ：

<blockquote>
<p>在敌人坦克类，使用Vector保存多个shot；</p>
<p>当每创建一个敌人坦克对象，给该敌人坦克对象初始化一个Shot对象，同时启动Shot</p>
<p>在绘制敌人坦克时，需要遍历敌人坦克对象Vector，绘制所有的子弹，当子弹isLive&#x3D;&#x3D;false，就从Vector移除</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnmeyTank</span> <span class="keyword">extends</span> <span class="title class_">Tank</span>&#123;</span><br><span class="line">    Vector&lt;Bullet&gt; bullets = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">解析</mark> ：

<p>在敌人坦克中创建<code>Vector</code>集合属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; EnmeyTankSizes; i++) &#123;</span><br><span class="line">    <span class="comment">//创建敌人坦克</span></span><br><span class="line">    <span class="type">EnmeyTank</span> <span class="variable">enmeyTank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnmeyTank</span>(<span class="number">100</span> * (i + <span class="number">1</span>), <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//创建敌人坦克子弹</span></span><br><span class="line">    <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bullet</span>(enmeyTank.getX() + <span class="number">20</span>, enmeyTank.getY() + <span class="number">60</span>, enmeyTank.getDirection());</span><br><span class="line">    <span class="comment">//加入到enemyTank的Vector成员</span></span><br><span class="line">    enmeyTank.bullets.add(bullet);</span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(bullet).start();</span><br><span class="line">    enmeyTanks.add(enmeyTank);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">解析</mark> ：

<p>在创建敌人坦克的时候创建子弹对象，因为敌人子弹和敌人坦克可以看作是同一个对象，在创建坦克的时候，肯定需要new一个坦克，同时就是创建子弹，并用new的敌人坦克，来调用敌人坦克类中的Vector集合对象，所以写在创建敌人坦克下面比较合理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出敌人坦克属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; enmeyTanks.size(); i++) &#123;</span><br><span class="line">    <span class="type">EnmeyTank</span> <span class="variable">enmeyTank</span> <span class="operator">=</span> enmeyTanks.get(i);</span><br><span class="line">    <span class="comment">//画出敌人坦克</span></span><br><span class="line">    drawTank(enmeyTank.getX(), enmeyTank.getY(), g, enmeyTank.getDirection(), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//画出敌人坦克子弹(写在坦克里面是因为坦克没了肯定不发射子弹)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; enmeyTank.bullets.size(); j++) &#123;</span><br><span class="line">        <span class="comment">//取出子弹</span></span><br><span class="line">        <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> enmeyTank.bullets.get(j);</span><br><span class="line">        <span class="keyword">if</span> (bullet.isLive) &#123;</span><br><span class="line">            g.draw3DRect(bullet.getX(), bullet.getY(), <span class="number">1</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//移除子弹</span></span><br><span class="line">            enmeyTank.bullets.remove(bullet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">解析</mark> ：

<p>也是面向对象思想，将画子弹写在画坦克的下面，取坦克时候对象用到，同时也可以取子弹，没有敌人坦克对象取不了敌人的子弹，所以为什么敌人Vector集合写在敌人坦克类的外面，而敌人子弹写在敌人坦克的里面，因为敌人坦克和敌人子弹是同一个类，面向对象的思想很重要。<font color="#ED5A65">注重类图的使用。</font></p>
 <mark class="hl-label blue">留疑</mark> ：

<p>最后还需要移除子弹,老师说不移除会导致一直重绘，但是目前测试后是没有关系，可能是为了节省资源，移除后就直接不进入判断，或者以后需要别的功能。</p>
<h1 id="敌方坦克消失"><a href="#敌方坦克消失" class="headerlink" title="敌方坦克消失"></a><font color="#1661AB">敌方坦克消失</font></h1><ul>
<li>击中坦克方法</li>
</ul>
<p>​		由于击中坦克需要用到子弹和坦克，就将这个方法写在<font color="#1661AB">MyPanel</font>类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hitTank</span><span class="params">(Bullet bullet, EnmeyTank enmeyTank)</span> &#123;</span><br><span class="line">    <span class="comment">//判断子弹击中坦克</span></span><br><span class="line">    <span class="keyword">switch</span> (enmeyTank.getDirection()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//坦克向上</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//坦克向下</span></span><br><span class="line">            <span class="keyword">if</span> (bullet.getX() &gt; enmeyTank.getX() &amp;&amp; bullet.getX() &lt; enmeyTank.getX()+ <span class="number">40</span> &amp;&amp; bullet.getY() &gt; enmeyTank.getY() &amp;&amp; bullet.getY() &lt; enmeyTank.getY()+<span class="number">60</span>) &#123;</span><br><span class="line">                bullet.isLive = <span class="literal">false</span>;</span><br><span class="line">                enmeyTank.isLive  = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//坦克向右</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//坦克向左</span></span><br><span class="line">            <span class="keyword">if</span> (bullet.getX() &gt; enmeyTank.getX() &amp;&amp; bullet.getX() &lt; enmeyTank.getX()+ <span class="number">60</span> &amp;&amp; bullet.getY() &gt; enmeyTank.getY() &amp;&amp; bullet.getY() &lt; enmeyTank.getY()+<span class="number">40</span>) &#123;</span><br><span class="line">                bullet.isLive = <span class="literal">false</span>;</span><br><span class="line">                enmeyTank.isLive  = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">解析</mark> ：

<p>将坦克抽象化，给坦克一个受击框，就是一个长方体，由于不用方向的坦克受击框不同，先<code>getDeirction</code>获得当前坦克方向，上下方向受击框一样，所以将他们写在一起。</p>
<ul>
<li>调用受击方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用坦克被击中的方法</span></span><br><span class="line">        <span class="keyword">if</span> (hero.bullet != <span class="literal">null</span> &amp;&amp; hero.bullet.isLive) &#123;<span class="comment">// 当我的子弹还是存活的</span></span><br><span class="line">            <span class="comment">//遍历所有敌人的坦克</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; enmeyTanks.size(); i++) &#123;</span><br><span class="line">                <span class="type">EnmeyTank</span> <span class="variable">enmeyTank</span> <span class="operator">=</span> enmeyTanks.get(i);</span><br><span class="line">                hitTank(hero.bullet, enmeyTank);</span><br><span class="line">                <span class="keyword">if</span> (!(enmeyTank.isLive)) &#123;</span><br><span class="line">                    enmeyTanks.remove(enmeyTank);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.repaint(); <span class="comment">//每间隔50毫秒重写绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">解析</mark> ：

<p>在<font color="#1661AB">重绘线程</font>中，调用坦克被击中方法，相当于每隔50ms检测坦克是否被击中，需要用到<code>hero</code>坦克的子弹和敌人坦克，首先都是用<code>isLive</code>变量判断是否活着，最后还需要把被击中的坦克(isLive为false)，从集合中移除。不然他还是会存在。结合下面绘图，他只是没画了，但还是存在的。</p>
<ul>
<li>绘图方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (EnmeyTank enmeyTank : enmeyTanks) &#123;</span><br><span class="line">    <span class="comment">//判断当前敌人坦克是否活着 ，活着时画出敌人坦克</span></span><br><span class="line">    <span class="keyword">if</span> (enmeyTank.isLive) &#123;</span><br><span class="line">        drawTank(enmeyTank.getX(), enmeyTank.getY(), g, enmeyTank.getDirection(), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//画出敌人坦克子弹(写在坦克里面是因为坦克没了肯定不发射子弹)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; enmeyTank.bullets.size(); j++) &#123;</span><br><span class="line">            <span class="comment">//取出子弹</span></span><br><span class="line">            <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> enmeyTank.bullets.get(j);</span><br><span class="line">            <span class="keyword">if</span> (bullet.isLive) &#123;</span><br><span class="line">                g.draw3DRect(bullet.getX(), bullet.getY(), <span class="number">1</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//移除子弹</span></span><br><span class="line">                enmeyTank.bullets.remove(bullet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label blue">解析</mark> ：

<p>由于添加<code>isLive</code>属性，所以绘图方法可以添上<code>isLive</code>。</p>
<h1 id="坦克爆炸"><a href="#坦克爆炸" class="headerlink" title="坦克爆炸"></a><font color="#1661AB">坦克爆炸</font></h1><p>首先创建一个爆炸类：本质就是图片调用<code>drawImage();</code>方法</p>
<p>所以需要坐标x、y。还需要有生命周期(图片存在时间)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jth.tankgame02;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    坦克爆炸效果 .就是一张gif图或者多张图片有序播放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bomb</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y; <span class="comment">//爆炸图片的坐标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">life</span> <span class="operator">=</span> <span class="number">45</span>; <span class="comment">//生命周期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLive</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//是否还存活</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bomb</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//画出时间，因为他也是有生命周期的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">LifeDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.life &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.life--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.isLive = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Vector集合存放，避免线程安全。总体思想就是先搜集爆炸情况，然后存放在Vector集合中，最后遍历集合画出来，并用图片展示出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span> <span class="variable">image1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Vector&lt;Bomb&gt; bombs = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyPanel</span> <span class="params">()</span>&#123;<span class="comment">//构造器</span></span><br><span class="line">		······</span><br><span class="line">		 <span class="comment">//初始化爆炸效果图片</span></span><br><span class="line">    image1 =Toolkit.getDefaultToolkit().getImage(MyPanel.class.getResource(<span class="string">&quot;/jr10.gif&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//画出爆炸效果，因为在击中时候存放bomb效果，所以不用判断tank是否islive</span></span><br><span class="line"><span class="keyword">for</span> (Bomb bomb : bombs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bomb.isLive) &#123;</span><br><span class="line">        g.drawImage(image1, bomb.x, bomb.y, <span class="number">40</span>, <span class="number">60</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bomb.LifeDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">位置分析</mark> ：

<p>可以直接写在坦克被击中的下方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (enmeyTank.getDirection()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//坦克向上</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//坦克向下</span></span><br><span class="line">        <span class="keyword">if</span> (bullet.getX() &gt; enmeyTank.getX() &amp;&amp; bullet.getX() &lt; enmeyTank.getX()+ <span class="number">40</span> &amp;&amp; bullet.getY() &gt; enmeyTank.getY() &amp;&amp; bullet.getY() &lt; enmeyTank.getY()+<span class="number">60</span>) &#123;</span><br><span class="line">            bullet.isLive = <span class="literal">false</span>;</span><br><span class="line">            enmeyTank.isLive  = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Bomb</span> <span class="variable">bomb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bomb</span>(enmeyTank.getX(), enmeyTank.getY());</span><br><span class="line">            bombs.add(bomb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//······</span></span><br></pre></td></tr></table></figure>

<h1 id="敌方坦克自由移动"><a href="#敌方坦克自由移动" class="headerlink" title="敌方坦克自由移动"></a><font color="#1661AB">敌方坦克自由移动</font></h1> <mark class="hl-label blue">解析</mark> ：

<ol>
<li>因为要求敌人的坦克，可以自由移动，因此需要将敌人坦克当做线程使用。</li>
<li>我们需要EnemyTank implements Runnable。 </li>
<li>在run方法写上我们相应的业务代码。</li>
<li>在创建敌人坦克对象时，启动线程。</li>
</ol>
 <mark class="hl-label red">注意</mark> ：

<p>写并发程序的时候，一定要考虑清楚，该线程什么时候结束。当坦克线程为false的时候就退出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//改变敌人坦克速度</span></span><br><span class="line">        <span class="built_in">this</span>.setSpeed(<span class="number">5</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">direction</span> <span class="operator">=</span> Math.random()*<span class="number">4</span>;<span class="comment">//生成[0,1)的随机数 double类型</span></span><br><span class="line">        <span class="keyword">switch</span> ((<span class="type">int</span>) direction) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">this</span>.setDirection(<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">this</span>.moveUp();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">this</span>.setDirection(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">this</span>.moveRight();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">this</span>.setDirection(<span class="number">2</span>);</span><br><span class="line">                <span class="built_in">this</span>.moveDown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">this</span>.setDirection(<span class="number">3</span>);</span><br><span class="line">                <span class="built_in">this</span>.moveLeft();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isLive) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;敌人坦克线程退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启功线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MyPanel</span> <span class="params">()</span>&#123;<span class="comment">//构造器</span></span><br><span class="line">     <span class="comment">//····</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; EnmeyTankSizes; i++) &#123;</span><br><span class="line">            <span class="comment">//创建敌人坦克</span></span><br><span class="line">            <span class="type">EnmeyTank</span> <span class="variable">enmeyTank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnmeyTank</span>(<span class="number">100</span> * (i + <span class="number">1</span>), <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">//创建敌人坦克子弹</span></span><br><span class="line">            <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bullet</span>(enmeyTank.getX() + <span class="number">20</span>, enmeyTank.getY() + <span class="number">60</span>, enmeyTank.getDirection());</span><br><span class="line">            <span class="comment">//加入到enemyTank的Vector成员</span></span><br><span class="line">            enmeyTank.bullets.add(bullet);</span><br><span class="line">            <span class="comment">//启动子弹线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(bullet).start();</span><br><span class="line">            enmeyTanks.add(enmeyTank);</span><br><span class="line">            <span class="comment">//启动敌人坦克运动线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(enmeyTank).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制坦克移动范围"><a href="#控制坦克移动范围" class="headerlink" title="控制坦克移动范围"></a><font color="#1661AB">控制坦克移动范围</font></h1> <mark class="hl-label blue">思路</mark> ：

<ol>
<li>将坦克的<code>x、y</code>坐标限制在画布上，画布如果不能完全展示，需要全屏解决。</li>
<li>需要考虑坦克的长度宽度，因为坦克坐标在坦克的左上角，并且坦克不同<code>direction</code>的时候占用像素不同，需要分情况考虑。</li>
<li>移动方法控制着<code>hero</code>和<code>EnemyTank</code>的移动，所以直接改<code>move</code>方法解决，不用改<code>KeyLisener</code>的键盘控制。</li>
</ol>
 <mark class="hl-label purple">代码</mark> ：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Tank</span> &#123;</span><br><span class="line">    ······</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveUp</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//向上移动</span></span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span> &amp;&amp; isLive) &#123;</span><br><span class="line">            y -= speed;</span><br><span class="line">            <span class="keyword">if</span> (y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                y = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveDown</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//向下移动</span></span><br><span class="line">        <span class="keyword">if</span> (y &lt;= <span class="number">690</span> &amp;&amp; isLive) &#123;</span><br><span class="line">            y += speed;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; <span class="number">690</span>) &#123;</span><br><span class="line">                y = <span class="number">690</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveRight</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//向右移动</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">940</span> &amp;&amp; isLive) &#123;</span><br><span class="line">            x += speed;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">940</span>) &#123;</span><br><span class="line">                x = <span class="number">940</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveLeft</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//向左移动</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; isLive) &#123;</span><br><span class="line">            x -= speed;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                x = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ·······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="坦克发射多颗子弹"><a href="#坦克发射多颗子弹" class="headerlink" title="坦克发射多颗子弹"></a><font color="#1661AB">坦克发射多颗子弹</font></h1> <mark class="hl-label purple">思路</mark> ：

<p>和敌方发射坦克思路差不多，在原来基础上将多颗子弹放进Vector集合中，注意如果子弹消亡，需要把子弹从集合中移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector&lt;Bullet&gt; bullets = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">Bulletcap</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//子弹的上线    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shot</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bullets.size() == Bulletcap) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Bullet；根据当前tank的方向</span></span><br><span class="line">    <span class="keyword">switch</span> (getDirection()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//当前tank方向为上</span></span><br><span class="line">            <span class="comment">//用创建对象的方式,所以用选用构造器传参更好，无需多个set</span></span><br><span class="line">            bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX()+<span class="number">20</span>,getY(),<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX()+<span class="number">60</span>,getY()+<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX()+<span class="number">20</span>,getY()+<span class="number">60</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX(),getY()+<span class="number">20</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把新创建的shot放入到shots</span></span><br><span class="line">    bullets.add(bullet);</span><br><span class="line">    <span class="comment">//所有东西初始化好就可以启动了</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(bullet).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <mark class="hl-label red">注意</mark> ：

<p>线程的启动不用遍历集合，因为每调用一次<code>shot()</code>，就会开启一个线程，在<code>println()</code>调试中也可以看到，就是只创建了一个<code>Bullet</code>，所以当按下两次J键，由于是同一个对象，才会看到第一个类似消亡的现象。</p>
<p>下面就是画子弹：遍历集合进行<code>draw</code>或者<code>remove</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">·······</span><br><span class="line">    <span class="comment">//画出hero坦克的子弹</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hero.bullets.size(); i++) &#123;</span><br><span class="line">        <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> hero.bullets.get(i);</span><br><span class="line">        <span class="keyword">if</span> (bullet != <span class="literal">null</span> &amp;&amp; bullet.isLive) &#123;</span><br><span class="line">            g.draw3DRect(bullet.getX(), bullet.getY(),<span class="number">2</span>,<span class="number">2</span>,<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hero.bullets.remove(bullet);</span><br><span class="line">        &#125;</span><br><span class="line">········</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="敌方发射子弹"><a href="#敌方发射子弹" class="headerlink" title="敌方发射子弹"></a><font color="#1661AB">敌方发射子弹</font></h1> <mark class="hl-label blue">思路</mark> ：

<p>和<code>hero</code>坦克发射子弹差不多，不需要<code>KeyLisener</code>，面向对象思想，敌方发射的子弹写在<code>EnemyTank</code>类中比较好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">//多线程实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//实现敌人坦克子弹没了继续发射,条件还有是坦克必须活着</span></span><br><span class="line">        <span class="keyword">if</span> (bullets.size() &lt; BulletNumber &amp;&amp; <span class="built_in">this</span>.isLive) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>.getDirection()) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX()+<span class="number">20</span>,getY(),<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX()+<span class="number">60</span>,getY()+<span class="number">20</span>,<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX()+<span class="number">20</span>,getY()+<span class="number">60</span>,<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    bullet = <span class="keyword">new</span> <span class="title class_">Bullet</span>(getX(),getY()+<span class="number">20</span>,<span class="number">3</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这步骤将对象加入到集合中，这样不会丢失，因为每次指创建一个，不保存的话就没办法画出他们的轨迹</span></span><br><span class="line">            bullets.add(bullet);</span><br><span class="line">            <span class="comment">//启动线程，只需启动对象即可不用遍历集合。每次的对象都不同</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span> (bullet).start();</span><br><span class="line">            <span class="comment">//改变敌人坦克速度</span></span><br><span class="line">        &#125;</span><br><span class="line">        ······</span><br></pre></td></tr></table></figure>

<p>接下来也是画出来就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出敌人坦克属性</span></span><br><span class="line"><span class="keyword">for</span> (EnmeyTank enmeyTank : enmeyTanks) &#123;</span><br><span class="line">    <span class="comment">//判断当前敌人坦克是否活着 ，活着时画出敌人坦克</span></span><br><span class="line">    <span class="keyword">if</span> (enmeyTank.isLive) &#123;</span><br><span class="line">        drawTank(enmeyTank.getX(), enmeyTank.getY(), g, enmeyTank.getDirection(), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//画出敌人坦克子弹(写在坦克里面是因为坦克没了肯定不发射子弹)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; enmeyTank.bullets.size(); j++) &#123;</span><br><span class="line">            <span class="comment">//取出子弹</span></span><br><span class="line">            <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> enmeyTank.bullets.get(j);</span><br><span class="line">            <span class="keyword">if</span> (bullet.isLive) &#123;</span><br><span class="line">                g.draw3DRect(bullet.getX(), bullet.getY(), <span class="number">1</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//移除子弹</span></span><br><span class="line">                enmeyTank.bullets.remove(bullet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="我方被击中爆炸"><a href="#我方被击中爆炸" class="headerlink" title="我方被击中爆炸"></a><font color="#1661AB">我方被击中爆炸</font></h1> <mark class="hl-label purple">思路</mark> ：

<p>前面写的<code>hitEnemytank();</code>。可以改写成<code>hittank()</code>.因为敌人坦克和hero坦克本质一样，受击框也一样。这里可以巧妙的使用多态写法，只需将形参中的<code>Enemytank</code>改成<code>Tank</code>。因为hero和enemytank都继承Tank类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写子弹碰到坦克，坦克消失的方法，由于需要用到坦克的参数和子弹的参数，所以写在两者都创建的地方</span></span><br><span class="line"><span class="comment">//干脆在重绘的时候判断是否有坦克爆炸</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hitTank</span><span class="params">(Bullet bullet, Tank tank)</span> &#123;</span><br><span class="line">    <span class="comment">//判断子弹击中坦克</span></span><br><span class="line">    <span class="keyword">switch</span> (tank.getDirection()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//坦克向上</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//坦克向下</span></span><br><span class="line">            <span class="keyword">if</span> (bullet.getX() &gt; tank.getX() &amp;&amp; bullet.getX() &lt; tank.getX()+ <span class="number">40</span> &amp;&amp; bullet.getY() &gt; tank.getY() &amp;&amp; bullet.getY() &lt; tank.getY()+<span class="number">60</span>) &#123;</span><br><span class="line">                bullet.isLive = <span class="literal">false</span>;</span><br><span class="line">                tank.isLive  = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">Bomb</span> <span class="variable">bomb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bomb</span>(tank.getX(), tank.getY());</span><br><span class="line">                bombs.add(bomb);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//坦克向右</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//坦克向左</span></span><br><span class="line">            <span class="keyword">if</span> (bullet.getX() &gt; tank.getX() &amp;&amp; bullet.getX() &lt; tank.getX()+ <span class="number">60</span> &amp;&amp; bullet.getY() &gt; tank.getY() &amp;&amp; bullet.getY() &lt; tank.getY()+<span class="number">40</span>) &#123;</span><br><span class="line">                bullet.isLive = <span class="literal">false</span>;</span><br><span class="line">                tank.isLive  = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">Bomb</span> <span class="variable">bomb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bomb</span>(tank.getX(), tank.getY());</span><br><span class="line">                bombs.add(bomb);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//敌方子弹击中我方坦克时</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; enmeyTanks.size(); i++) &#123; <span class="comment">//取出敌方坦克</span></span><br><span class="line">    <span class="type">EnmeyTank</span> <span class="variable">enmeyTank</span> <span class="operator">=</span> enmeyTanks.get(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; enmeyTank.bullets.size(); j++) &#123; <span class="comment">//分别取出敌方坦克的子弹</span></span><br><span class="line">        <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> enmeyTank.bullets.get(j);</span><br><span class="line">        <span class="keyword">if</span> (bullet != <span class="literal">null</span> &amp;&amp; bullet.isLive &amp;&amp; hero.isLive) &#123; <span class="comment">//如果敌方有子弹并且时isLive状态时候，并且我方坦克是isLive</span></span><br><span class="line">            hitTank(bullet, hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Mypanel的多线程run方法中调用也就是每隔50ms检测一次。也可将这个封装成方法写入到hero类中。</p>
<h1 id="坦克大战0-5版"><a href="#坦克大战0-5版" class="headerlink" title="坦克大战0.5版"></a><font color="#1661AB">坦克大战0.5版</font></h1><ul>
<li>增加功能</li>
</ul>
<ol>
<li>防止敌人坦克重叠运动</li>
<li>记录玩家的成绩，存盘退出【io流】</li>
<li>记录当时的敌人坦克坐标，存盘退出【io】</li>
<li>玩游戏时，可以选择是开新游戏还是继续上一局游戏</li>
</ol>
<h2 id="防止敌人坦克重叠"><a href="#防止敌人坦克重叠" class="headerlink" title="防止敌人坦克重叠"></a><font color="#1661AB">防止敌人坦克重叠</font></h2><p>思路就是敌人坦克向前移动时候，判断前面有没有敌方坦克。这需要获取敌人坦克的坐标位置。</p>
<p>所以将方法写到<code>Enemytank</code>类中，并且需要实时获得敌人坦克的坐标，所以需要获得在<code>panel</code>中的<code>EnemyTanks</code>的Vector集合，这里可以使用构造器获得，或者使用<code>set</code>方法。这里使用构造器方法。</p>
<p>情况分析：</p>
<p><img src="/images/image-20220810145022464.png" alt="image-20220810145022464"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTouchTank</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.getDirection()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//向上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; enemyTanks.size(); i++) &#123;</span><br><span class="line">                <span class="comment">//遍历并获取当前敌人坦克向量</span></span><br><span class="line">                <span class="type">EnemyTank</span> <span class="variable">enemyTank</span> <span class="operator">=</span> enemyTanks.get(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span> != enemyTank) &#123;  <span class="comment">//如果不是当前坦克本身</span></span><br><span class="line">                    <span class="keyword">if</span> (enemyTank.getDirection() == <span class="number">0</span> || enemyTank.getDirection() == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="comment">//另外一个坦克的朝向是上或者下的时候</span></span><br><span class="line">                        <span class="comment">//此时this坦克的上边坐标是：this.getX()和this.getX()+40</span></span><br><span class="line">                        <span class="comment">//另外一个坦克的判定框为：enemyTank.getX()~enemyTank.getX()+40 &amp;&amp; enemyTank.getY()~enemyTank.getY()+60</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() &lt;= enemyTank.getX() + <span class="number">40</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &lt;= enemyTank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//左上角点在另一个坦克内部</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() + <span class="number">40</span> &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() + <span class="number">40</span> &lt;= enemyTank.getX() + <span class="number">40</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &lt;= enemyTank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enemyTank.getDirection() == <span class="number">1</span> || enemyTank.getDirection() == <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() &lt;= enemyTank.getX() + <span class="number">60</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &lt;= enemyTank.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() + <span class="number">40</span> &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() + <span class="number">40</span> &lt;= enemyTank.getX() + <span class="number">60</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &lt;= enemyTank.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//向右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; enemyTanks.size(); i++) &#123;</span><br><span class="line">                <span class="comment">//遍历并获取当前敌人坦克向量</span></span><br><span class="line">                <span class="type">EnemyTank</span> <span class="variable">enemyTank</span> <span class="operator">=</span> enemyTanks.get(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span> != enemyTank) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (enemyTank.getDirection() == <span class="number">0</span> || enemyTank.getDirection() == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX()+<span class="number">60</span> &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX()+<span class="number">60</span> &lt;= enemyTank.getX() + <span class="number">40</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &lt;= enemyTank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX()+<span class="number">60</span> &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX()+<span class="number">60</span> &lt;= enemyTank.getX() + <span class="number">40</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">40</span> &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">40</span> &lt;= enemyTank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (enemyTank.getDirection() == <span class="number">1</span> || enemyTank.getDirection() == <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX()+<span class="number">60</span> &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX()+<span class="number">60</span> &lt;= enemyTank.getX() + <span class="number">60</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &lt;= enemyTank.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX()+<span class="number">60</span> &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX()+<span class="number">60</span> &lt;= enemyTank.getX() + <span class="number">60</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">40</span> &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">40</span> &lt;= enemyTank.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//向下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; enemyTanks.size(); i++) &#123;</span><br><span class="line">                <span class="comment">//遍历并获取当前敌人坦克向量</span></span><br><span class="line">                <span class="type">EnemyTank</span> <span class="variable">enemyTank</span> <span class="operator">=</span> enemyTanks.get(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span> != enemyTank) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (enemyTank.getDirection() == <span class="number">0</span> || enemyTank.getDirection() == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() &lt;= enemyTank.getX() + <span class="number">40</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">60</span> &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">60</span> &lt;= enemyTank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX()+<span class="number">40</span> &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX()+<span class="number">40</span> &lt;= enemyTank.getX() + <span class="number">40</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">60</span> &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">60</span> &lt;= enemyTank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (enemyTank.getDirection() == <span class="number">1</span> || enemyTank.getDirection() == <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() &lt;= enemyTank.getX() + <span class="number">60</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">60</span> &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">60</span> &lt;= enemyTank.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX()+<span class="number">40</span> &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX()+<span class="number">40</span> &lt;= enemyTank.getX() + <span class="number">60</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">60</span> &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">60</span> &lt;= enemyTank.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//向左</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; enemyTanks.size(); i++) &#123;</span><br><span class="line">                <span class="comment">//遍历并获取当前敌人坦克向量</span></span><br><span class="line">                <span class="type">EnemyTank</span> <span class="variable">enemyTank</span> <span class="operator">=</span> enemyTanks.get(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span> != enemyTank) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (enemyTank.getDirection() == <span class="number">0</span> || enemyTank.getDirection() == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() &lt;= enemyTank.getX() + <span class="number">40</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &lt;= enemyTank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() &lt;= enemyTank.getX() + <span class="number">40</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">40</span> &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">40</span> &lt;= enemyTank.getY() + <span class="number">60</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (enemyTank.getDirection() == <span class="number">1</span> || enemyTank.getDirection() == <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() &lt;= enemyTank.getX() + <span class="number">60</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY() &lt;= enemyTank.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.getX() &gt;= enemyTank.getX()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getX() &lt;= enemyTank.getX() + <span class="number">60</span></span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">40</span> &gt;= enemyTank.getY()</span><br><span class="line">                                &amp;&amp; <span class="built_in">this</span>.getY()+<span class="number">40</span> &lt;= enemyTank.getY() + <span class="number">40</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于传入Mypanel初始化好的向量集合enemyTanks传入到这里</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnemyTanks</span><span class="params">(Vector&lt;EnemyTank&gt; enemyTanks)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.enemyTanks = enemyTanks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EnemyTank</span> <span class="variable">enemyTank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnemyTank</span>(node.getX(), node.getY(), node.getDirection());</span><br><span class="line"><span class="comment">//enemyTanks.add(enemyTank);出现bug的原因add了两次</span></span><br><span class="line"><span class="comment">//将敌人坦克集合传入到EnemyTank类</span></span><br><span class="line">enemyTank.setEnemyTanks(enemyTanks);</span><br></pre></td></tr></table></figure>

<h2 id="记录玩家成绩"><a href="#记录玩家成绩" class="headerlink" title="记录玩家成绩"></a><font color="#1661AB">记录玩家成绩</font></h2><p>需要用到IO流。将方法封装到类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tankgame05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    该类用于记录我方坦克击毁敌人坦克数</span></span><br><span class="line"><span class="comment">    游戏结束时，将文件写入到文件(IO).myRecord.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recorder</span> &#123;</span><br><span class="line">    <span class="comment">//定义变量，记录我方坦克数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">allEnemyTankNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义IO对象准备写数据到文件中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">recordFile</span> <span class="operator">=</span> <span class="string">&quot;D:/myRecord.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;EnemyTank&gt; enemyTanks = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//定义一个Node的Vector,用于保存敌人的信息Node。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//当游戏退出时，将allEnemyTankNum保存到文件src..</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">keepRecord</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(recordFile));</span><br><span class="line">            bw.write(allEnemyTankNum + <span class="string">&quot;\r\n&quot;</span>);<span class="comment">//类属性调用</span></span><br><span class="line">            <span class="keyword">if</span> (enemyTanks != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Recorder.enemyTanks.size(); i++) &#123;</span><br><span class="line">                    <span class="type">EnemyTank</span> <span class="variable">enemyTank</span> <span class="operator">=</span> Recorder.enemyTanks.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (enemyTank.isLive) &#123; <span class="comment">//建议判断</span></span><br><span class="line">                        bw.write(enemyTank.getX() + <span class="string">&quot; &quot;</span> + enemyTank.getY() + <span class="string">&quot; &quot;</span> + enemyTank.getDirection() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addallEnemyTankNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//击毁一个敌人坦克的时候++</span></span><br><span class="line">        Recorder.allEnemyTankNum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getAllEnemyTankNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> allEnemyTankNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setAllEnemyTankNum</span><span class="params">(<span class="type">int</span> allEnemyTankNum)</span> &#123;</span><br><span class="line">        Recorder.allEnemyTankNum = allEnemyTankNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setEnemyTanks</span><span class="params">(Vector&lt;EnemyTank&gt; enemyTanks)</span> &#123;</span><br><span class="line">        Recorder.enemyTanks = enemyTanks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法在继续上局游戏的时候调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;Node&gt; <span class="title function_">getNodesAndEnemyTankRec</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(recordFile));</span><br><span class="line">            allEnemyTankNum = Integer.parseInt(br.readLine());</span><br><span class="line">            <span class="comment">//循环读取文件，生成nodes集合</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                String[] xyd = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.parseInt(xyd[<span class="number">0</span>]),</span><br><span class="line">                        Integer.parseInt(xyd[<span class="number">1</span>]), Integer.parseInt(xyd[<span class="number">2</span>]));</span><br><span class="line">                nodes.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中读取参数，用到正则表达式，并将对方tank参数抽象成node类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tankgame05;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一个Node对象，表示一个敌人坦克的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> direction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDirection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDirection</span><span class="params">(<span class="type">int</span> direction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是选择继续游戏还是开始游戏，使用最先构造器在print界面选择。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HspTankGame05</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    mp = <span class="keyword">new</span> <span class="title class_">MyPanel</span>(key);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MyPanel</span> <span class="params">(String key)</span>&#123;<span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//将敌人坦克集合传入到Recorder类</span></span><br><span class="line">    Recorder.setEnemyTanks(enemyTanks);</span><br><span class="line">    <span class="comment">//读取上局游戏</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/myRecord.txt&quot;</span>).exists()) &#123;</span><br><span class="line">        nodes = Recorder.getNodesAndEnemyTankRec();<span class="comment">//读取分数，和返回敌人坦克位置集合</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件丢失，重新开始游戏&quot;</span>);</span><br><span class="line">        key = <span class="string">&quot;N&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;J&quot;</span>:</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">                <span class="type">EnemyTank</span> <span class="variable">enemyTank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnemyTank</span>(node.getX(), node.getY(), node.getDirection());</span><br><span class="line">                <span class="comment">//enemyTanks.add(enemyTank);出现bug的原因add了两次</span></span><br><span class="line">                <span class="comment">//将敌人坦克集合传入到EnemyTank类</span></span><br><span class="line">                enemyTank.setEnemyTanks(enemyTanks);</span><br><span class="line">                <span class="comment">//创建敌人坦克子弹</span></span><br><span class="line">                <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bullet</span>(enemyTank.getX() + <span class="number">20</span>, enemyTank.getY() + <span class="number">60</span>, enemyTank.getDirection());</span><br><span class="line">                <span class="comment">//加入到enemyTank的Vector成员</span></span><br><span class="line">                enemyTank.bullets.add(bullet);</span><br><span class="line">                <span class="comment">//启动子弹线程</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(bullet).start();</span><br><span class="line">                enemyTanks.add(enemyTank);</span><br><span class="line">                <span class="comment">//启动敌人坦克运动线程</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(enemyTank).start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;N&quot;</span> : <span class="comment">//新游戏</span></span><br><span class="line">        <span class="comment">//for 循环遍历装填</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; EnmeyTankSizes; i++) &#123;</span><br><span class="line">            <span class="comment">//创建敌人坦克</span></span><br><span class="line">            <span class="type">EnemyTank</span> <span class="variable">enemyTank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnemyTank</span>(<span class="number">100</span> * (i + <span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将敌人坦克集合传入到EnemyTank类</span></span><br><span class="line">            enemyTank.setEnemyTanks(enemyTanks);</span><br><span class="line">            <span class="comment">//创建敌人坦克子弹</span></span><br><span class="line">            <span class="type">Bullet</span> <span class="variable">bullet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bullet</span>(enemyTank.getX() + <span class="number">20</span>, enemyTank.getY() + <span class="number">60</span>, enemyTank.getDirection());</span><br><span class="line">            <span class="comment">//加入到enemyTank的Vector成员</span></span><br><span class="line">            enemyTank.bullets.add(bullet);</span><br><span class="line">            <span class="comment">//启动子弹线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(bullet).start();</span><br><span class="line">            enemyTanks.add(enemyTank);</span><br><span class="line">            <span class="comment">//启动敌人坦克运动线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(enemyTank).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;输入指令有误&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样就简单的完成选择。</p>
<p>坦克大战就先告一段落，有时间可以拓展。</p>
]]></content>
      <categories>
        <category>Java游戏开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>关于子父类初始化问题</title>
    <url>/2022/08/11/%E5%85%B3%E4%BA%8E%E5%AD%90%E5%A4%AB%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>虚拟机规范严格规定了有且只有五种情况必须立即对类进行“初始化”</p>
<ol>
<li>使用new关键字<font color="ED5A65">实例化对象</font>的时候、读取或设置一个类的<font color="ED5A65">静态字段</font>的时候，已经调用一个类的<font color="ED5A65">静态方法</font>的时候。（静态加载）</li>
<li>使用java.lang.reflect包的方法对类进行<font color="ED5A65">反射调用</font>的时候，如果类没有初始化，则需要先触发其初始化。<font color="ED5A65">（动态加载）</font></li>
<li>当初始化一个类的时候，如果发现其<font color="ED5A65">父类没有被初始化</font>就会<font color="ED5A65">先初始化</font>它的父类。(静态加载)</li>
<li>当虚拟机启动的时候，用户需要指定一个要执行的主类<font color="ED5A65">（就是包含main()方法的那个类）</font>，虚拟机会先初始化这个类；</li>
<li>使用<font color="ED5A65">Jdk1.7动态语言</font>支持的时候的一些情况。</li>
</ol>
<p><font color="ED5A65">反射动态加载具体情况在Java文章中有提及。</font></p>
<p>除了这五种之外，其他的所有引用类的方式都不会触发初始化，称为被动引用。下面是被动引用的三个例子：</p>
<p>\1.   通过子类引用父类的的静态字段，不会导致子类初始化。</p>
<p>\2.   通过数组定义来引用类，不会触发此类的初始化。</p>
<p>public class NotInitialization { </p>
<p>  public static void main(String[] args) { </p>
<p>​    SuperClass[] sca &#x3D; new SuperClass[10]; </p>
<p>  }  </p>
<p>}</p>
<p>\3.   常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<p>public class ConstClass { </p>
<p>  static { </p>
<p>​    System.out.println(“ConstClass init!”); </p>
<p>  } </p>
<p>  public static final int value &#x3D; 123; </p>
<p>} </p>
<p>public class NotInitialization{ </p>
<p>  public static void main(String[] args) { </p>
<p>​    int x &#x3D; ConstClass.value; </p>
<p>  } </p>
<p>} </p>
<p>上述代码运行之后，也没有输出“ConstClass init！”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。参考资料：<a href="https://blog.csdn.net/qq_22771739/article/details/86348962">https://blog.csdn.net/qq_22771739/article/details/86348962</a></p>
<p><img src="/images/image-20220811195944140.png" alt="image-20220811195944140"></p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>增强for出现ConcurrentModificationException</title>
    <url>/2022/08/04/%E5%A2%9E%E5%BC%BAfor%E5%87%BA%E7%8E%B0ConcurrentModificationException/</url>
    <content><![CDATA[<ul>
<li>问题复现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        vector.add(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">        vector.add(<span class="string">&quot;ss1&quot;</span>);</span><br><span class="line">        vector.add(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">        <span class="comment">//增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String s : vector) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            vector.remove(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220804172251868.png" alt="image-20220804172251868"></p>
<p>这是由于增强for循环底层调用的是迭代器的next和hasnext方法来遍历的，移除元素后，无法预知到元素的位置。这也是增强for的缺点，不能获取下标，不能动态删除集合中的内容。</p>
<p>解决办法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">List&lt;String&gt; list_remove = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"> <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="string">&quot;q&quot;</span>.equals(s))&#123;</span><br><span class="line">     list_remove.add(s); <span class="comment">//把要移除的统一放在一个集合</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//统一移除</span></span><br><span class="line"> list.removeAll(list_remove);</span><br><span class="line"> System.out.println(list);<span class="comment">//[h, y]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多用户通信系统</title>
    <url>/2022/08/10/%E5%A4%9A%E7%94%A8%E6%88%B7%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>为什么选择这个项目</li>
</ul>
<ol>
<li><p>有趣</p>
</li>
<li><p>涉及到Java各个方面的技术</p>
</li>
<li><p>项目框架设计</p>
<p>​		Java面向对象编程</p>
<p>​		网络编程</p>
<p>​		多线程</p>
<p>​		IO流</p>
<p>​		Mysql&#x2F;使用集合充当内存数据库</p>
</li>
<li><p>巩固旧知识，学习新知识</p>
</li>
</ol>
<h1 id="项目开发流程"><a href="#项目开发流程" class="headerlink" title="项目开发流程"></a>项目开发流程</h1><p>需求分析- - &gt; 设计阶段 - - &gt; 编码实现 - -&gt; 测试阶段 - - &gt; 实施阶段</p>
<mark class="hl-label blue">示意图</mark> ：

<p><img src="/images/image-20220810205517070.png" alt="image-20220810205517070"></p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><ol>
<li>用户登录<br><img src="/images/image-20220810211254265.png" alt="image-20220810211254265"></li>
<li>拉取在线用户列表<br><img src="/images/image-20220810211309402.png" alt="image-20220810211309402"></li>
<li><font color="ED5A65">无异常</font>退出(客服端、服务器端System.exit(0)不行)</li>
<li>私聊<br><img src="/images/image-20220810211334570.png" alt="image-20220810211334570"></li>
<li>群聊<br><img src="/images/image-20220810211408168.png" alt="image-20220810211408168"></li>
<li>发文件<br><img src="/images/image-20220810211508797.png" alt="image-20220810211508797"></li>
<li>服务器推送新闻<br><img src="/images/image-20220810211543871.png" alt="image-20220810211543871"></li>
</ol>
<h1 id="通信系统整体分析"><a href="#通信系统整体分析" class="headerlink" title="通信系统整体分析"></a>通信系统整体分析</h1><mark class="hl-label blue">示意图</mark> ：

<p><img src="/images/image-20220810213209973.png" alt="image-20220810213209973"></p>
<h1 id="QQ用户登录"><a href="#QQ用户登录" class="headerlink" title="QQ用户登录"></a>QQ用户登录</h1><ul>
<li>功能实现-用户登录</li>
</ul>
<ol>
<li><p>功能说明</p>
<p>因为还没有学习数据库，我们人为规定用户名&#x2F;id &#x3D; 100，密码123456就可以登陆，其他用户不能登录<br>后面使用HashMap模拟数据库，可以多个用户登录。</p>
<p><img src="/images/image-20220810211254265.png" alt="image-20220810211254265"></p>
</li>
<li><p>思路分析+程序框架图</p>
</li>
<li><p>代码实现</p>
</li>
</ol>
<p>放github上吧</p>
<p>思路分析</p>
<p>Socket放到线程中，并用集合管理，</p>
<p>放到线程中是，线程就是为了同时干多件事情，集合管理是为了拓展，如果有多个功能就需要用集合管理。</p>
<p>不断的运行用线程run - while死循环体现。</p>
<mark class="hl-label blue">注意</mark> ：

<p>QQcommon包如果是序列化需要共享，那么在不同模块下路径必须一样，而且名字要一样。或者就写在单独一个包也行。</p>
<p><img src="/images/image-20220818154345814.png" alt="image-20220818154345814"></p>
<mark class="hl-label blue">注意</mark> ：

<p>DB本来用数据库，这里用集合替代。</p>
<h1 id="无异常退出"><a href="#无异常退出" class="headerlink" title="无异常退出"></a>无异常退出</h1><p><img src="/images/image-20220818161158690.png" alt="image-20220818161158690"></p>
<h1 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h1><p><img src="/images/image-20220820152728366.png" alt="image-20220820152728366"></p>
<h1 id="服务器推送消息"><a href="#服务器推送消息" class="headerlink" title="服务器推送消息"></a>服务器推送消息</h1>]]></content>
      <categories>
        <category>Java网络编程</category>
        <category>JavaIO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>子类父类构造器问题</title>
    <url>/2022/07/30/%E5%AD%90%E7%B1%BB%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a><font color="428675">问题引出</font></h1><p>牛客网题库中遇到这个问题：<font color="ED5A65">子类不但可以继承父类的无参构造函数也可以继承父类的有参构造函数?</font></p>
<p>第一次时判断错了，这个问题本身是错误的。</p>
<h1 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a><font color="428675">知识储备</font></h1><ol>
<li>虽然子类会继承父类的成员、方法等。但是不会继承构造器。构造方法只能被调用，不被继承。子类默认是调用父类的无参构造器，若需要调用父类有参构造器，则需要用<code>super(形参)</code>来调用。并且需写在子类构造器代码的第一行。</li>
<li>任何类，如果没有写任何构造器，JVM则会提供一个对应的无参构造器。如果了有了有参构造器，则不会提供无参构造器，需要自己写。</li>
<li>有参构造器不一定需要将所有成员都写入，根据业务需求传参。</li>
</ol>
<h1 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a><font color="428675">情况分析</font></h1><p>1、父类没有任何构造器</p>
<p>​	子类无法通过有参构造器初始化父类的成员变量。</p>
<p>​	子类可以使用有参构造器，默认会调用父类的无参构造器，即时没写JVM会提供一个无参构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 子父类构造器问题 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AA</span>(<span class="string">&quot;s&quot;</span>);<span class="comment">//调用子类有参构造器</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;s&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AA</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label blue">输出</mark> 

<p>​	父类无参构造器<br>​	子类有参构造器<br>​	父类无参构造器<br>​	子类无参构造器</p>
<p>这里用<code>System.out.println(&quot;父类无参构造器&quot;);</code>来展示子类是否调用了父类的无参构造器。根据结果结论是无论子类使用<font color="ED5A65">有参构造器</font>还是使用无参构造器，默认都会调用父类的无参构造器然后调用自己对应的构造器。</p>
<p>2、证明JVM提供的无参构造器</p>
<p><img src="/images/image-20220730161607971.png" alt="image-20220730161607971"></p>
<p>当父类只有有参构造器时候，编译报错，因为JVM判断你有构造器，则不提供无参构造器。则子类默认调用的无参构造器无了-&gt;报错。</p>
<p><img src="/images/image-20220730161739351.png" alt="image-20220730161739351"></p>
<p>当父类没有任何东西的时候，JVM又会提供无参构造器，则编译通过。</p>
<p>3、子类调用父类有参构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AA</span><span class="params">(String age, String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(age);</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    System.out.println(<span class="string">&quot;子类有参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">注意</mark> 

<p><code>super()</code>写在第一行即可。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>常用类String</title>
    <url>/2023/02/24/%E5%B8%B8%E7%94%A8%E7%B1%BBString/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2022/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数据结构与算法的关系"><a href="#数据结构与算法的关系" class="headerlink" title="数据结构与算法的关系"></a>数据结构与算法的关系</h1><p><img src="/images/image-20220831200641252.png" alt="image-20220831200641252"></p>
<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p><img src="/images/image-20220831202036316.png" alt="image-20220831202036316"></p>
<blockquote>
<p>这里连续指的是内存地址连续的。</p>
</blockquote>
<h1 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h1><p><img src="/images/image-20220831202048458.png" alt="image-20220831202048458"></p>
<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><p><img src="/images/image-20220831202747749.png" alt="image-20220831202747749"></p>
<p><img src="/images/image-20220831202819503.png" alt="image-20220831202819503"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先创建一个原始数组</span></span><br><span class="line">        <span class="comment">//二维数组是有很多行组成的</span></span><br><span class="line">        <span class="comment">//0: 没有棋子 1:表示黑子 2：表示蓝子</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        chessArr[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);  <span class="comment">//System.out.printf(&quot;%d/t&quot;, data);</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();<span class="comment">//换行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换成稀疏数组</span></span><br><span class="line">        <span class="comment">//1、先遍历二维数组，得到非 0 数据的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> chessArr.length;<span class="comment">//输出二维数组的行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : chessArr) &#123;</span><br><span class="line">            cow = ints.length;<span class="comment">//二维数组每一行的长度，</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                <span class="keyword">if</span> (anInt != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、创建对应的稀疏数组</span></span><br><span class="line">        <span class="type">int</span> sparseArr [][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//3、给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = row;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = cow;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cow; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : sparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();<span class="comment">//换行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将稀疏数组转换成二维数组</span></span><br><span class="line">        <span class="type">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr1[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.deepToString(chessArr1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展：使用io流</p>
<p><img src="/images/image-20220831223711151.png" alt="image-20220831223711151"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:/map.data&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] ints : sparseArr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">        System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        fileWriter.write(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fileWriter.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    System.out.println();<span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line">fileWriter.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从磁盘读取稀疏数组</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/map.data&quot;</span>);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line"><span class="type">int</span> <span class="variable">lineNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> [][] sparseArr1 = <span class="literal">null</span>;</span><br><span class="line">String[] split = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span>((context = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lineNumber == <span class="number">0</span>) &#123;</span><br><span class="line">        split = context.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.println(split[<span class="number">2</span>]);</span><br><span class="line">        sparseArr1 = <span class="keyword">new</span> <span class="title class_">int</span>[Integer.parseInt(split[<span class="number">2</span>]) + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArr1[<span class="number">0</span>][<span class="number">0</span>] = Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line">        sparseArr1[<span class="number">0</span>][<span class="number">1</span>] = Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">        sparseArr1[<span class="number">0</span>][<span class="number">2</span>] = Integer.parseInt(split[<span class="number">2</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            split = context.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            sparseArr1[lineNumber][i] = Integer.parseInt(split[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lineNumber++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;======&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] ints : sparseArr1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">        System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;=====&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>数组不用字节流，直接用字符流即可。用上正则表达式，用”\t”、”\n”区分各个数，各个行。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><img src="/images/image-20220905110534552.png" alt="image-20220905110534552"></p>
<p>用数组存储是顺序存储。</p>
<p>用链表存储是链式存储。</p>
<h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p><img src="/images/image-20220905110803288.png" alt="image-20220905110803288"></p>
<p><img src="/images/image-20220905111031334.png" alt="image-20220905111031334"></p>
<p>代码：一次性队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>; <span class="comment">//接受用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show) : 显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit) : 退出队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add) : 添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get) : 从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head) : 查看队列头的数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>); <span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> :</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> :</span><br><span class="line">                    <span class="comment">//退出程序</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> :</span><br><span class="line">                    System.out.println(<span class="string">&quot;输出一个数&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    arrayQueue.add(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span> :</span><br><span class="line">                    <span class="comment">//因为get这个方法会有异常这里用try-catch</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> arrayQueue.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;取出的数据是&quot;</span> + res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">//抛出异常</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span> :</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrayQueue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;头部数据是&quot;</span> + i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组模拟队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="comment">//表示数组最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">//指向队列的头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> font;</span><br><span class="line">    <span class="comment">//指向队列的尾部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">//模拟队列的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="built_in">this</span>.font = -<span class="number">1</span>;  <span class="comment">//指向队列头部，分析出font是指向队列头的前一个位置</span></span><br><span class="line">        <span class="built_in">this</span>.rear = -<span class="number">1</span>;  <span class="comment">//指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> font == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="comment">//        if (!isFull()) &#123;</span></span><br><span class="line"><span class="comment">//            arr[rear + 1] = value;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        rear++;</span></span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已经满了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队列、或者叫获取队列的数据</span></span><br><span class="line">    <span class="comment">//伪取数据，没有删除队列里面的数据、只是font后移</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空，不能取数据&quot;</span>); <span class="comment">//throw本身就有return的作用，下面就不用写东西了</span></span><br><span class="line">        &#125;</span><br><span class="line">        font++;</span><br><span class="line">        <span class="keyword">return</span> arr[font];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空的，无数据！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//结束方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++ ) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列头的数据,不是取出数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空，没有数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[font + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>数据不能重复使用。没有达到复用的效果。</p>
<p>将这个数组使用算法，改进成一个环形的队列：取模的方式 % 。</p>
<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p>条件：</p>
<p><img src="/images/image-20220905201935420.png" alt="image-20220905201935420"></p>
<p>为什么队列满的时候用这个算法：</p>
<p>首先这个原理，是需要预留一个空位的。再这个队列弄成一个环，就是中间空一格的环，那么就会出现两种情况，第一是rear大于front，当然也会出现front大于rear。但是实际上rear一直指向数组的最后一个，要求它必须大于front。</p>
<p>所以在判断是否为满的时候，只要判断front和rear是否差一格就行，无需谁在上。</p>
<p>在判断有效个数的时候，就需要两种情况分开来看，</p>
<p>+maxSize是为了当rear在front上面时准备的。</p>
<p>%maxSize是为了当rear在front上面时准备的。</p>
<p>还是要注意最大值时maxSize-1需要预留一个位置。这样好判断为空的情况和满的情况。图上font和rear是从-1开始。其实不太对也对的。</p>
<p>因为如果是-1的话计算就会出问题。</p>
<p><img src="/images/image-20220905211624863.png" alt="image-20220905211624863"></p>
<p>这里图就非常明显，这就是为什么要空一个的原因，因为初始值指针是0，添加一个元素后，指针会超过一个身为。其实默认值-1也行，这样就能和值一起移动，但是font是-1.还是默认为0的好理解一点。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleArrayQueue</span> &#123;</span><br><span class="line">    <span class="comment">//表示数组最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">//指向队列的头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">//指向队列的尾部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">//模拟队列的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleArrayQueue</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        <span class="comment">//front 和rear指针默认为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了，不能添加数据&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[rear] = value;</span><br><span class="line">            rear = (rear + <span class="number">1</span>) % maxSize;<span class="comment">//要考虑到如果指针在最后面的话，下一个就必须移动到数组的第一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队列、或者叫获取队列的数据</span></span><br><span class="line">    <span class="comment">//伪取数据，没有删除队列里面的数据、只是font后移</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空，不能取数据&quot;</span>); <span class="comment">//throw本身就有return的作用，下面就不用写东西了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里需要分析出front是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">//1、先把front对应的值保留到一个临时变量中去</span></span><br><span class="line">        <span class="comment">//2、将front后移，考虑取模，不然会报数组越界</span></span><br><span class="line">        <span class="comment">//3、将临时保存的变量返回</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> front;</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> arr[count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示数组所有元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//思路：从front开始遍历到rear结束</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分类遍历</span></span><br><span class="line">        <span class="comment">//1、rear大于front</span></span><br><span class="line">        <span class="keyword">if</span> (rear &gt; front) &#123;</span><br><span class="line">            <span class="comment">//因为默认指针从0开始，所以rear指针上面是没有数的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; rear; i++) &#123;</span><br><span class="line">                System.out.println(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、如果front大于rear</span></span><br><span class="line">        <span class="keyword">if</span> (front &gt; rear) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; maxSize; i++) &#123;</span><br><span class="line">                System.out.println(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rear; i++) &#123;</span><br><span class="line">                System.out.println(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，没有元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//思路：从front开始，需要遍历多少个元素</span></span><br><span class="line">        <span class="comment">//前面分析过是(rear + maxSize -front) % maxSize; 解决两种情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.println(arr[i % maxSize]); <span class="comment">//取余解决数组越界问题。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效队列个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize -front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示队列头元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有head&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里默认front 和 rear是0. 与第一张图不符合，那张图就看一下就好了。</p>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p><img src="/images/image-20220910231504905.png" alt="image-20220910231504905"></p>
<p><img src="/images/image-20220910231626542.png" alt="image-20220910231626542"></p>
<p><img src="/images/image-20220911110150869.png" alt="image-20220911110150869"></p>
<p>代码实现思路：</p>
<p><img src="/images/image-20220910232338044.png" alt="image-20220910232338044"></p>
<p>注意：遍历时候是使用辅助指针。</p>
<p>第二种添加方式：排序并添加</p>
<p><img src="/images/image-20220911110303698.png" alt="image-20220911110303698"></p>
<p>删除：</p>
<p> <img src="/images/image-20220911130337642.png" alt="image-20220911130337642"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jth.LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;ni&quot;</span>, <span class="string">&quot;in&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;ni1&quot;</span>, <span class="string">&quot;in1&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;ni2&quot;</span>, <span class="string">&quot;in2&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;ni3&quot;</span>, <span class="string">&quot;in3&quot;</span>);</span><br><span class="line">        SingleLinkedListDemo list= <span class="keyword">new</span> <span class="title class_">SingleLinkedListDemo</span>();</span><br><span class="line"><span class="comment">//        list.add(hero1);</span></span><br><span class="line"><span class="comment">//        list.add(hero4);</span></span><br><span class="line"><span class="comment">//        list.add(hero3);</span></span><br><span class="line"><span class="comment">//        list.add(hero2);</span></span><br><span class="line">        list.addByOrder(hero1);</span><br><span class="line">        list.addByOrder(hero4);</span><br><span class="line">        list.addByOrder(hero3);</span><br><span class="line">        list.addByOrder(hero2);</span><br><span class="line">        list.show();</span><br><span class="line">        list.update(<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;ni4&quot;</span>, <span class="string">&quot;in4&quot;</span>));</span><br><span class="line">        list.update(<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;ni4&quot;</span>, <span class="string">&quot;in4&quot;</span>));</span><br><span class="line">        list.remove(<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;ni4&quot;</span>, <span class="string">&quot;ni4&quot;</span>));</span><br><span class="line">        list.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个单链表类用于管理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="comment">//先初始化一个head节点这个节点不能动，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">headNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写链表add方法</span></span><br><span class="line">    <span class="comment">//当不考虑编号顺序的时候</span></span><br><span class="line">    <span class="comment">//1、找到当前链表的最后一个节点</span></span><br><span class="line">    <span class="comment">//2、在最后一个节点的next添加一个HeroNode对象即可；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助遍历temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> headNode; <span class="comment">//有一个HeroNode指向head节点</span></span><br><span class="line">        <span class="comment">//遍历链表，找到链表的最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断链表是否为空 ,只有链表最后一个next指向null，或者是链表本身为空</span></span><br><span class="line">            <span class="keyword">if</span> (temp.Next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.Next; <span class="comment">//不是最后一个就往后移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        temp.Next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，还是需要一个辅助指针来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找到的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> headNode;</span><br><span class="line">        <span class="comment">//定义一个boolean类型用于判断这个数是否已经存在</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.Next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明是最后一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.Next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到合适的位置插入,因为这个添加本身已经是有序的了就不用管前面的。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.Next.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//说明这节点已经有了</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加数据即可</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据已经存在&quot;</span> + heroNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入数据的next指向temp的下一个</span></span><br><span class="line">            <span class="comment">//temp的下一个指向插入数据</span></span><br><span class="line">            heroNode.Next = temp.Next;</span><br><span class="line">            temp.Next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息，根据no编号更改，即no编号不能改。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headNode.Next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还是一样用一个变量遍历数组</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> headNode;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.Next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历完整个链表了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.Next.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到了</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始修改</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">           temp.Next.name = heroNode.name;</span><br><span class="line">           temp.Next.nickname = heroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到对应的节点&quot;</span>+ heroNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (headNode.Next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还是一样先遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> headNode;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.Next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明已经到了最后一个了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.Next.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到符合条件的</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.Next = temp.Next.Next; <span class="comment">//如果是要删除最后一个元素，那么他会指向null。正好符合</span></span><br><span class="line">            <span class="comment">//JVM 的垃圾回收机制会回收</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到符合删除条件的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示链表【遍历】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headNode.Next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断链表是否为空</span></span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助变量temp，因为头节点不能动</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> headNode;  <span class="comment">//这里最好指向headNode，不能指向headNode.Next</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            temp = temp.Next;</span><br><span class="line">            <span class="comment">//判断是否到了最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个HeroNode 对象，每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;   <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode Next; <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span> <span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><img src="/images/image-20220911131409172.png" alt="image-20220911131409172"></p>
<ol>
<li><p>获取所有节点数（不包含head节点）</p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;获取当前链表的有效节点个数<br>public int getNums(HeroNode headNode) {<br>if (headNode.Next &#x3D;&#x3D; null) {<br>    &#x2F;&#x2F;链表里面没有数据<br>    return 0;<br>}<br>&#x2F;&#x2F;感觉就是遍历吧<br>HeroNode temp &#x3D; headNode;<br>int count &#x3D; 0;<br>while (true) {<br>    if (temp.Next !&#x3D; null) {<br>        count++;<br>    }<br>    if (temp.Next &#x3D;&#x3D; null) {<br>        break;<br>    }<br>    temp &#x3D; temp.Next;<br>}<br>return count;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 获取倒数k的节点</span><br><span class="line"></span><br><span class="line">4. ```java</span><br><span class="line">   //查找单链表中的倒数第k个节点</span><br><span class="line">   public HeroNode ReturnByReciprocal (int k, HeroNode headNode) &#123;</span><br><span class="line">       int nums = getNums(headNode);</span><br><span class="line">       int goal = nums - k + 1;</span><br><span class="line">       return ReturnByK(goal, headNode);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //返回链表第k个节点</span><br><span class="line">   public HeroNode ReturnByK (int k, HeroNode headNode) &#123;</span><br><span class="line">       int nums = getNums(headNode);</span><br><span class="line">       //判断是否为空</span><br><span class="line">       if (headNode.Next == null) &#123;</span><br><span class="line">           System.out.println(&quot;链表为空&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (k &gt; nums || k &lt;=0) &#123;</span><br><span class="line">           System.out.println(&quot;输入的K不在该链表的范围内&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //遍历</span><br><span class="line">       int count = 0;</span><br><span class="line">       HeroNode temp = headNode;  //不算头节点</span><br><span class="line">       HeroNode result = null;</span><br><span class="line">       while (temp.Next != null) &#123;</span><br><span class="line">           count++;</span><br><span class="line">           temp = temp.Next;</span><br><span class="line">           if (k == count) &#123;</span><br><span class="line">               result = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝与深拷贝</title>
    <url>/2023/02/24/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>日记--随想录</title>
    <url>/2022/05/27/%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<h2 id="基于chrome浏览器开发插件的比赛小总结。"><a href="#基于chrome浏览器开发插件的比赛小总结。" class="headerlink" title="基于chrome浏览器开发插件的比赛小总结。"></a>基于chrome浏览器开发插件的比赛小总结。</h2></blockquote>
<mark class="hl-label green">2022-06-01</mark>  <mark class="hl-label orange">星期三</mark>  <mark class="hl-label default">小雨</mark>  

<hr>
<p>先说说心路历程吧，这次比赛可以说是我人生中第一次的<strong>失败</strong>，在我整个学习生涯中，全部时间都花在“课堂学习”中。每天都是完成学科作业，没有精力去向外拓展学一些自己感兴趣的东西，还有是家庭环境、学校环境给我传输的就是学好课程努力应试，考上好学校就有前途。再者说，自己能力不够成绩也是很好。还有就是初高中一直浑浑噩噩，没有给自己定目标，基本是脚踩西瓜皮一样，能考出什么样的成绩就怎么样吧<img class="inline-img" src="http://tva3.sinaimg.cn/large/006GJQvhgy1g0971ke4n7j30jg0jgdip.jpg" style="height:50px">。而这次不同，踏入大学，生活变得自由，在大一享受过后，就在这次寒假我感受到了就业的压力。对以后生活充满迷茫，也想着去学点东西参加点竞赛。可能是我交际能力差，大学很多资源没有把握住，也可能是我学校资源差（浙江省末流二本），根本找不到ACM社团之类的。最后，看到这次稀土掘金的比赛，几乎是零基础开始学的，前端js、css、html语法都没学，只会java一点点语法。只能硬着头皮上，就当学习的一个输出结果不重要。忘记说的是，先前学了差不多一学期Java，刚开始学是真头疼我自己内心很讨厌线下课（自己专业开设的课程，先前也有开设过C语言课程），我真是有点<em>社恐</em><img class="inline-img" src="http://tva3.sinaimg.cn/large/006ARE9vgy1fzbon0fpv5g305k05ke3e.gif" style="height:50px">。注意力很难集中，Jaa的一些面向对象知识很是头疼。然后，自己又在寒假学了会（自己也是对这个感兴趣，学起来比c语言有意思，Java给人一种很严谨的感觉）。怀着试试看的心态报名了<img class="inline-img" src="http://tva3.sinaimg.cn/large/78b88159gy1g6bo7nbmg8g204g04gaa3.gif" style="height:50px">，途中也想过放弃，自己什么都不会。插件方面得从零基础开始学，并且Java刚学到一半。但是想了想这是给自己找借口，高插件并不影响自己学习Java。只是自己喜欢活在舒适圈吧。提交自己作品的时候是最平静的，看到别人作品的时候是慌张的，有点自卑。别人都是vue框架，自己就一点点css js、jquery。啥也不是。很难受啊那时候。毫无疑问的是，第一轮就被刷掉了<img class="inline-img" src="http://tva3.sinaimg.cn/large/006APoFYly1g29glxyyj6j3052055jrl.jpg" style="height:50px">, 这次和以往所有考试都不同，让我感受到了极大的失落感，一方面是急着想要有比赛经历，失败了就相当于白干。另一方面是这是出于对这一段时间以来的检测。失败带来极大的失落感。甚至是高考都没这样无助的感觉（除非高考什么学校都没考上哈哈哈）<img class="inline-img" src="http://tva3.sinaimg.cn/large/006m97Kgly1fke2mg92ypj30j60j6ju2.jpg" style="height:50px">。付出之后一点回报没有是最让我无助和自我怀疑的，但这次除去表面上的排名我收获很大<img class="inline-img" src="http://tva3.sinaimg.cn/large/0068Lfdegy1fzxo1w0mxyj30j10hd0td.jpg" style="height:50px">（巨他妈大）。就光光了解网页的表现形式，和chrome浏览器的一堆监听器就够让我吃一壶。更重要的是自学能力，能够静下心来看一些自己没有接触过的领域。能力的提升最为重要，计算机软件发展这么快，新的东西不断的涌出。谁也无法预测未来。 </p>
<blockquote>
<p>你不知道什么东西对你以后工作有用，你要广泛涉猎，都去学一些，什么都看（有些增删，大概是这意思）          —平安银行首席架构师一次访谈中的话</p>
</blockquote>
<blockquote>
<p>失败总是贯穿这个人生，这就是人生                   ——showmaker</p>
</blockquote>
<mark class="hl-label red">儿童节快乐六级加油不摆烂</mark> 

<hr>
<blockquote>
<h1 id="2022-6-02-日记"><a href="#2022-6-02-日记" class="headerlink" title="2022-6-02 日记"></a>2022-6-02 日记</h1></blockquote>
<mark class="hl-label green">2022-06-02</mark>  <mark class="hl-label orange">星期四</mark>  <mark class="hl-label default">阴</mark> 

<p>  今天过得还算自律，早上6点30睡醒，在强烈的精神斗争下。还是觉得体育学分重要，睡梦中爬起来。<img class="inline-img" src="http://tva3.sinaimg.cn/large/ceeb653ejw1faqa8uruamj20c80c8gm3.jpg" style="height:50px">在床下缓了好久，发现时间已经来不及了，脸都不洗就出门了。跑步过程中，整个人都是梦游状态，呼吸都是睡觉那种大喘气。出都出来了，肯定要买领先全校99%人的早餐了，眼镜没带，眼睛里面还很多眼屎，边搓着迷糊的眼睛<img class="inline-img" src="http://tva3.sinaimg.cn/large/ceeb653ely8gzvf2c0eg8j20dw0dlt9c.jpg" style="height:50px">对卖包子阿姨要一个烧卖和茶叶蛋~。由于是超越全校99%的早餐，店铺基本没啥人，阿姨也在和同事闲聊。没听清又向我确认了一遍。昨晚12点睡，早上6点半起导致我一直半梦半醒。强顶着写了一篇六级的仔细阅读，不得不说一看英语就犯困。巨他妈难啊！<img class="inline-img" src="http://tva3.sinaimg.cn/large/0068Lfdely1gka6io7q4ij30j60j6q47.jpg" style="height:50px">。本来六级就没几天了，但还是学不进去(根本不会)。就写了点控制理论的大作业。一早上也就这么混过去了~~！。<img class="inline-img" src="http://tva3.sinaimg.cn/large/006m97Kgly1fu87w4uaspj305i05imxq.jpg" style="height:50px"> 中午吃了😋的台湾美食。食堂的pro max ulta版本。便宜好吃，还就在我们寝室楼下。简直宝藏店铺，鞋子都不用穿直接跑下去买都行。<img class="inline-img" src="http://tva3.sinaimg.cn/large/005TGG6vly1fgw1vm794hj302f02sjr6.jpg" style="height:50px"> 下午本来打算学会Java，然后再写一篇英语阅读的。但是终究是抵挡不过诱惑啊，开黑去了。<img class="inline-img" src="http://tva3.sinaimg.cn/large/005XSXmNgy1fdxqyn1bzcj30fk0g8dhb.jpg" style="height:50px"> 。还是得吐槽一下这个吊毛寝室，你妈的现在这个天气，贼闷，可能是宿舍太小了，而且完全不通风，不如大一寝室宽敞而且通风。夏天简直要热死人。外面是热血短袖，里面就是铁壁汗蒸。<img class="inline-img" src="http://tva3.sinaimg.cn/large/9e31678cly1g3co7pvw3aj21400u0acc.jpg" style="height:50px"> 。最离谱的是，太阳是找不到我们阳台的，离谱了就照不到还那么热，我想晒个被子都没得地方(太阳）。wdnmd<img class="inline-img" src="http://tva3.sinaimg.cn/large/006APoFYly8gx94nuk7rjj30g40hsq39.jpg" style="height:50px"> 。然后就导致我下午更困了，打的时候额头冒汗，打完头晕脑涨。晚上去拿快递买水果的时候直接放飞自我了。都不社恐了，已经累到不在乎自己了。核酸啥的就不说了，已经成为习惯了，最后就是总结，今天总体还行。明天继续努力吧。<img class="inline-img" src="http://tva3.sinaimg.cn/large/006r3PQBjw1fazsjczrfnj30b40b4dgb.jpg" style="height:50px"> </p>
<mark class="hl-label red">端午节快乐六级加油不摆烂</mark> 

<blockquote>
<h1 id="2022-6-03-日记"><a href="#2022-6-03-日记" class="headerlink" title="2022-6-03 日记"></a>2022-6-03 日记</h1></blockquote>
<mark class="hl-label green">2022-06-03</mark>  <mark class="hl-label orange">星期五</mark>  <mark class="hl-label default">阴</mark> 

<p>  今天过的巨难受，太纠结了。简直是选择困难症<img class="inline-img" src="http://tva3.sinaimg.cn/large/006Mi9iRgy1gpzv642b38j30k00kjjso.jpg" style="height:50px"> 。早上睡梦中关闭了闹钟，但是记忆中根本没有睁开过眼睛的感觉。今天正常假期作息，八点四十起床刷牙洗脸。还是改不了一贯的拖延症，明天试着把手机放下，高效一点。导致早上接近11点才开始写作业，一天过程半天。先写六级英语，本以为翻译会好下手一些，但是对我来说还是好困难，”改革开放”、”到2014年”、”实施”。卧槽我一个都不会，好多生词<img class="inline-img" src="http://tva3.sinaimg.cn/large/0068Lfdely1gka6io7q4ij30j60j6q47.jpg" style="height:50px">。英语最重要的还是单词啊！写翻译就和写天书一样，让老师给你”填空”，直接反客为主。忘记说了（拖延症太严重，都是凌晨写日记迷迷糊糊的），昨天吃了蓝莓——人生第一次啊。蓝色的食物确实难见到，准确来说蓝莓应该偏向黑紫色，和葡萄颜色差不多。口感嘛，不好说没啥味（多少带点臭——无端联想）。就一两颗可能有点酸味。我妈真是关心人，当我妈发了一个蓝莓视频之后，我就随口说了一句没吃过，她就立马快递送过来两盒。本来是拒绝的，只要一盒就够了。吃不完而且学校有卖（太贵了一次没买过蓝莓）。在一顿拉扯过后，肯定是拉扯不过我妈的，我妈还有点强迫症，说服她需要高超的技术。下午嘛就把形势政策的考试考了，第一次是81分，感觉不够多。努努力重新考了个85.5。考完当时就头疼（天气太热了），直接就不管了，也没精力再考一次了。晚上硬着头皮刷了几篇毛概<img class="inline-img" src="http://tva3.sinaimg.cn/large/9150e4e5gw1f8yv983c8yg208w06oe6t.gif" style="height:50px">，下礼拜就考试了！。还有就是不要没有需求创造需求，这学期的书费退了有370块钱，在加上618心里一直想买东西，本来都没有啥需求，结果今天花410多。还是好心疼！尤其是在选鞋子的时候最头疼，便宜的感觉不符合心理预期，贵的又买不去，看的鞋子越多越难抉择真的是选择困难症<img class="inline-img" src="http://tva3.sinaimg.cn/large/006APoFYjw1fb3gtt5qfkj30b40b4weu.jpg" style="height:50px">。也没啥了，今天就是没有学Java了，好吧明天一定不拖延了。！<img class="inline-img" src="http://tva3.sinaimg.cn/large/006APoFYjw1fcg5hcgv0fg308c08c0sr.gif" style="height:50px"></p>
<mark class="hl-label red">端午节快乐六级加油不摆烂</mark> 

<blockquote>
<h1 id="2022-6-24-大二下期末段小总结"><a href="#2022-6-24-大二下期末段小总结" class="headerlink" title="2022-6-24 大二下期末段小总结"></a>2022-6-24 大二下期末段小总结</h1></blockquote>
<mark class="hl-label green">2022-06-24</mark> <mark class="hl-label orange">星期五</mark>  <mark class="hl-label red">晴</mark> 

<p>  今天终于完成了期末考试了，将近有半个月没更新了，主要是用于完成课程设计。事情是真的繁杂，加上疫情的原因，本身有两个礼拜的课程设计时间，现在压缩成一个礼拜。就是上个礼拜，整个人一直泡在实验室，完全没有休息时间<img class="inline-img" src="http://tva3.sinaimg.cn/large/006r3PQBjw1fbr0edsy0hj30c80950t4.jpg" style="height:50px">。哼哼，首先讲一下收获最大的模电研讨，要求是各小组完成四个主题任务，每次派一个人上去汇报，并且不能重复。也就是说每个人都必须汇报一次。可以说是从他开学提到这个问题的时候我就很担心，我从来没有完成过一次好的上台讲话，就是那种上台站都站不稳的情况<img class="inline-img" src="http://tva3.sinaimg.cn/large/6af89bc8gw1f8u10bg2dhg201d01dq2p.gif" style="height:50px">。由于期间我们学校出现了一例阳性，直接将三次的研讨压缩到最后一礼拜。最难熬的是，汇报前一晚，睡都睡不好，还有汇报前几分钟。在这之前我看了“如何上台演讲不紧张”、“如何改善发音”、、、最担心的时候说话不清楚一卡壳，并且是用的话筒，当音响传出陌生的并且卡壳的声音，就会巨紧张<img class="inline-img" src="http://tva3.sinaimg.cn/large/ceeb653ely1g1tagxgunyg20aw0awe81.gif" style="height:50px">。也反复听了自己在录音的声音，为了就是保证熟悉感。还有就是上台前几分钟，心理一直暗示自己能行，没有人听的。但是还是按捺不住紧张。那时候心理闪过很多想法，第一个就是演讲不好丢脸，还有就是想起高中上台唱歌却一言不发。但当我开始将的时候，借助着PPT就像讲题目一样，一直往外倒出来就好。总结一下就是，第一次完整讲完了，并且途中，并没有大问题。我也不知道别人是什么感觉，反正也没几个人听，都在忙着做课程设计。也许以后我也能成为，健谈并且幽默风趣，说话能和别人对视（这个我觉得好难啊，我就没对视过几次）。可能我内心是不想和别人聊天，表现出来的就是板着脸，可能没有人愿意和严肃脸交谈。另外说一句，下午地铁站的一个女生好好看，眼睛好好看。最后在总结一下，各个课程设计，模电的电路设计。一句话，全都在焊电路板，最大收货：学会了怎么使用焊接。电路图由于时间关系都是老师给排版好的，我们只管焊接。唯一困难的就是，测试。如果第一次没有完成实验目标的话，我对着个电路板调试只有头疼两个字。宁愿重新焊接一个也不愿意调试。<img class="inline-img" src="http://tva3.sinaimg.cn/large/006Cmetyly1fmecp47b1mj30d30d3dio.jpg" style="height:50px">。还有一个就是，单片机的课程设计，最最让我无语的是单片机的开发板有些是坏的，完全看运气（这一点是真的不爽）。我都无法象形要是最后一次抽到的板子是坏的我该怎么办<img class="inline-img" src="http://tva3.sinaimg.cn/large/003MWcpMly8gudbj7gnraj60g30gagm802.jpg" style="height:50px">。还有这门课程还有一个小小的答辩，就是把你课程设计给老师看，回答问题。我居然把&amp;&amp; 和||搞反了。我一个打算学软件的居然这个搞反，认识到自己的基础太薄弱了。还有就是他的问，主要是试探你，他看我一个代码多写了就问我是不是抄别人的，这句话是最让我难受的，又这么看不起人的吗。<img class="inline-img" src="http://tva3.sinaimg.cn/large/415f82b9ly1glozkiyu0tj20c80a3wes.jpg" style="height:50px"> </p>
<p>  人总是要成长的，一些外在言论不需要过多在意，有些事情的结果也不用在意。重在过程。自己脚踏实地走过来，学会总结和分析。别人抄过来的答案就算比我成绩高又如何，没有任何意义。我坚定这条道路，并且现在的反馈就是，做事情越来越有条不稳。就今天的乘坐地铁，提前1小时到站，自己一个人坐地铁、坐公交。很稳的完成任务。还得吐槽一句今天是真你妈热，还晒<img class="inline-img" src="http://tva3.sinaimg.cn/large/006APoFYjw1fakybyuv9cj30b4022mx7.jpg" style="height:50px"> 。</p>
<mark class="hl-label red">暑假在家也要好好学习</mark>  <mark class="hl-label red">加油</mark> 

<blockquote>
<h1 id="2022-7-16-暑假在家学习情况小总结"><a href="#2022-7-16-暑假在家学习情况小总结" class="headerlink" title="2022-7-16 暑假在家学习情况小总结"></a>2022-7-16 暑假在家学习情况小总结</h1></blockquote>
<mark class="hl-label green">2022-07-16</mark> <mark class="hl-label orange">星期六</mark>  <mark class="hl-label red">晴</mark> 

<p>  先说下规划吧25号前学完JavaEE吧，Java基础基本过了两边，虽然有点满了，两个月的课程，并且大二上有学校有开设课程，但是一遍一遍重新看，能学到很多东西，温故而知新吧。大二上可以说才理解函数的传参，刚开始学Java是真的抽象，现在回头看发现挺简单自己进度也太慢了。现在才刚刚理解什么是面向对象，学校教的课程也太水了，还有一个就是上课效率问题，大一C语言老师推荐的一个网站，我当时根本就没听，大二自学的时候，发现这个网站挺好。然后室友提起来这个网站大一老师有推荐过，自己是真不认真。<img class="inline-img" src="http://tva3.sinaimg.cn/large/6a2a7a61ly1h39wdti9l4g206o06oqge.gif" style="height:50px"></p>
<p>  接着就是学习效率问题吧，在家里很吵，主要是家里人打扰，另外就是自己自觉性问题，前段时间一天学习时间可能2小时都没。开直播学习是真不错，至少能注意力集中，虽然没人看哈，就当有人监控下，这几天学习效率就相当可以。<img class="inline-img" src="http://tva3.sinaimg.cn/large/005J4OU5ly1h3r8jpm3wyg30b40b475d.gif" style="height:50px"></p>
<p>  最后就是规划和计划很重要，就现在选了一个好老师自学Java，讲的是真的细节。太棒了。马上大三，考研也必须提上日程，真开学了自己连考什么学校，考什么科目都不知道就尴尬了。暑假英语单词也要背起来了。算法也可刷起来，就明后两天吧，学完集合里面的链表。<img class="inline-img" src="http://tva3.sinaimg.cn/large/003MWcpMly8gu85769054j60u010c76a02.jpg" style="height:50px"></p>
<p>  碎谈一下，生活方面的吧，父母对我很好，一日三餐都准备的很好。也很关心我，最重要的是不会因为我打游戏而和以前一样，你怎么又在打游戏啊，或者在打游戏中打断你说帮我干个事情，而是会说打完了吗。有点事情要做。真的是梦中情母。再说一说作息，我愿称之为纺锤形，刚来家还挺自律，然后就慢慢的1点钟睡觉，整个人都没精神，现在就发现不行，对身体不好，而且一直长痘痘，就渐渐恢复作息。每天也都健身，还有最近的鬼天气，一动就汗如雨下，真的受不了。<img class="inline-img" src="http://tva3.sinaimg.cn/large/6a2a7a61ly1h39wdt0d84g206o06o4b0.gif" style="height:50px"></p>
<mark class="hl-label red">暑假在家也要好好学习</mark>  <mark class="hl-label red">加油</mark> 
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>随想录</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题</title>
    <url>/2022/07/04/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><font color="#6dc1f7">双指针</font></h1><blockquote>
<p>双指针，就是<strong>定义两个指针在指定的数组&#x2F;链表上游走，在做一些自定义的操作</strong>。 如果要细分的话，双指针有 左右指针 ， 快慢指针 ， 滑动窗口 三种类型，一般时间复杂度为O (n)，空间复杂度为O (1),这就是双指针的精妙之处。</p>
<p>不用再去创建一个数组。</p>
</blockquote>
<mark class="hl-label orange">案例1</mark> ：在数组中移除对应对应的数(val)——快慢指针判断有条件判断指针2是否前进

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElementcorrection</span><span class="params">(<span class="type">int</span> [] nums , <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      双指针思想</span></span><br><span class="line"><span class="comment">      个人理解： 两个指针都会遍历数组 一个用来比较是否是要移除的元素 第二个指针相当于新建一个数组：大小和原来一样</span></span><br><span class="line"><span class="comment">      并且如果是符合这个数组（即不等于要被移除的数）那么第二个指针就会自增1 那么有多少个数符合那么第二个指针就会有多长</span></span><br><span class="line"><span class="comment">      最坏的情况就是这个数组没有要移除的数那么两个指针都会遍历数组一遍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left1</span> <span class="operator">=</span> <span class="number">0</span> ; left1 &lt; len ; left1++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left1] != val) &#123;</span><br><span class="line">            nums[left] = nums[left1];</span><br><span class="line">            left++;    <span class="comment">//即完成移除元素 也记录了符合的数的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8C%E6%8C%87%E9%92%88.png" alt="双指针经典案例"></p>
<mark class="hl-label orange">案例2</mark> ：类似双指针——两个数组双指针(快慢指针)

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *一个升序数组要求加入一个元素后还是升序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] paixu(<span class="type">int</span>[] arr, Scanner sc) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  1、第一步找位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= arr[i]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">//关键不然一直要么是最后一个要么是倒数第二个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==-<span class="number">1</span>) &#123;</span><br><span class="line">            index = len;   <span class="comment">//没有找到位置那就是最后一个啦</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  2、数组扩容</span></span><br><span class="line">        <span class="type">int</span> [] Newarr = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 3、 类似双指针  最外层指针在扩容数组上 里面一层在旧数组上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>; i&lt; Newarr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">                Newarr [i] = arr [j];</span><br><span class="line">                j++;  <span class="comment">//非常的关键一步很牛叉的思想</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;   <span class="comment">// else 就说明是要插入的位置</span></span><br><span class="line">                 Newarr [i] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Newarr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label purple">总结</mark> 

<blockquote>
<p>这是两个指针在不同数组上的应用，最明显的作用是减少代码量。<code>j++</code>这个很关键。</p>
</blockquote>
<mark class="hl-label orange">案例3</mark> ：对给定的<font color="F07C82">有序数组</font> \textit{nums}nums 删除重复元素，在删除重复元素之后，每个元素只出现一次，并返回新的长度，上述操作必须通过<font color="F07C82">原地修改</font>数组的方法，使用 O(1)O(1) 的空间复杂度完成。

<mark class="hl-label red">关键词</mark> ：原地修改、有序数组、<font color="F07C82">快慢指针</font>。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">1</span>; <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[fast-<span class="number">1</span>]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<mark class="hl-label red">小结</mark> ：双指针，一个指针用于指定新数组的位置(替换符合的数据)，另一个指针用于遍历原来数组(判断是否符合条件)。巧妙的无需创建新的数组，用两个快慢指针遍历一个数组完成。

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单JVM内存</title>
    <url>/2022/10/13/%E7%AE%80%E5%8D%95JVM%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="简单JVM内存模型图"><a href="#简单JVM内存模型图" class="headerlink" title="简单JVM内存模型图"></a>简单JVM内存模型图</h1><p><img src="/images/image-20221013225543790.png" alt="image-20221013225543790"></p>
<p>堆区：存放的使用new关键字创建的类或者数组的(含成员变量)；类对象也保存在堆中</p>
<p>栈区：存放的是局部变量(注:形参也是局部变量的一种)和对象的声明引用;</p>
<p>方法区(常量池):存放的是字符串，其他基本数据类型的常量，方法区包含所有的class（类信息)，方法区中包含的都是在程序中永远的唯一的元素（String字符串类型也是哦）所以字符串类型是不变的</p>
<p>final修饰的变量也放在方法区</p>
<p>静态域:静态变量</p>
<p><font color="red">老韩解读:</font></p>
<p>JDK8以前：类对象放在方法区里面<br>JDK8以后:   类对象放在堆里面。 Static 变量保存在Class实例的尾部，这个Class对象在堆中。</p>
<p><img src="/images/image-20221013232033771.png" alt="image-20221013232033771"></p>
<p><img src="/images/image-20220822234037124.png" alt="image-20220822234037124"></p>
<h1 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h1><p>假设内存中没有连续的20MB空间。但不连续的空间很大，此时有一个长度为20的数据，每个下标放了一个1MB对象，请问这个内存能否放下这个数组！</p>
<p>答案是可以的。数组放的是对象的引用，对象分散存在堆中间的，然后他的引用是连续的但是占不了很多空间的。所以这个能放下。</p>
]]></content>
      <categories>
        <category>-JVM</category>
      </categories>
      <tags>
        <tag>-JVM -堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>补码反码原码</title>
    <url>/2022/09/28/%E8%A1%A5%E7%A0%81%E5%8F%8D%E7%A0%81%E5%8E%9F%E7%A0%81/</url>
    <content><![CDATA[<h1 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h1><p>计算处理的是补码</p>
<p>我们传入的参数是原码</p>
<p>反码是对原码的按位取反</p>
<p>重要的：</p>
<p>为了表示有符号的数字在计算机中：即有负数和正数；</p>
<p>设计人将数的二进制最高位改为表示符号:</p>
<p>​	0表示正数</p>
<p>​	1表示负数</p>
<p>由于没有0 和 -0 将一个数表达成两种情况，所有补码&#x3D;反码+1。看下图也能看出来</p>
<p><img src="/images/image-20220928202102484.png" alt="image-20220928202102484"></p>
<p>上图非常巧妙</p>
<p>为什么高位1表示负数，这个和时钟很像，一个循环的表示。</p>
<h1 id="关于Java取反的符号"><a href="#关于Java取反的符号" class="headerlink" title="关于Java取反的符号~"></a>关于Java取反的符号~</h1><p>先给出结论</p>
<p>答案是</p>
<p>~X &#x3D; -（X+1）</p>
<p>比如X&#x3D;5（int类型）</p>
<p>因为java都是有符号的,表示出来就是<br>00000000  00000000 00000000 00000101 (原码，补码，反码)</p>
<p>取反就是</p>
<p>11111111  11111111  11111111  11111010 (补码)</p>
<p>负数的补码等于反码+1</p>
<p>反过来求出反码 （-1）</p>
<p>11111111  11111111  11111111  11111001</p>
<p>算出原码并显示</p>
<p>10000000  00000000  00000000  00000110 &#x3D; -6</p>
<h1 id="gt-gt-运算符"><a href="#gt-gt-运算符" class="headerlink" title="&gt;&gt; 运算符"></a>&gt;&gt; 运算符</h1><p>注意一下这个符号</p>
<p>3 &gt;&gt; 56;</p>
<p>将3这个数右移动56位</p>
<p>因为int类型就4个字节，就32位</p>
<p>所以他会先把56mod32之后再进行右移动</p>
<p>当然还有左移动，&lt;&lt; </p>
<p>上面的高位都是用符号位填充</p>
<p>下面这个就是高位全是0填充只有&gt;&gt;&gt;右移动。没有左移动</p>
<p><img src="/images/image-20220928204451169.png" alt="image-20220928204451169"></p>
]]></content>
      <categories>
        <category>书籍整理</category>
      </categories>
      <tags>
        <tag>Java核心技术卷1</tag>
      </tags>
  </entry>
</search>
